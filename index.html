<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Vault Heist — Part1 (Fixed)</title>

<!-- Stable three.js + controls -->
<script src="https://unpkg.com/three@0.164.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.164.0/examples/js/controls/PointerLockControls.js"></script>
<script src="https://unpkg.com/three@0.164.0/examples/js/controls/OrbitControls.js"></script>

<style>
  html,body{height:100%;margin:0;padding:0;background:#07101a;color:#eaeaea;font-family:system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif}
  #app{position:fixed;inset:0;display:flex;flex-direction:column}
  header{height:56px;padding:8px 12px;background:linear-gradient(90deg,#07101a,#0b1220);display:flex;align-items:center}
  header h1{margin:0;font-size:16px}
  #sceneWrap{flex:1;position:relative;overflow:hidden}
  canvas#main3d{width:100%;height:100%;display:block;touch-action:none} /* touch-action none to avoid scroll conflicts */
  #hud{position:absolute;right:12px;top:72px;background:rgba(5,7,10,0.7);padding:10px;border-radius:8px;z-index:50}
  #minimap{position:absolute;left:12px;top:72px;width:150px;height:150px;background:rgba(0,0,0,0.45);padding:8px;border-radius:8px;z-index:50}
  #controlsUI{position:absolute;left:12px;bottom:12px;z-index:60;display:flex;gap:12px}
  .btn{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.02);padding:8px 10px;border-radius:8px;color:inherit;cursor:pointer}
  .notif{position:absolute;right:12px;bottom:12px;z-index:99;background:rgba(0,0,0,0.6);padding:8px 10px;border-radius:10px}
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>Vault Heist — Part1 (Fixed)</h1>
    <div style="margin-left:auto;display:flex;gap:8px">
      <button id="btnNew" class="btn">新しいマップ</button>
      <button id="btnSave" class="btn">保存</button>
    </div>
  </header>

  <div id="sceneWrap">
    <canvas id="main3d"></canvas>

    <div id="minimap">
      <canvas id="miniCanvas" width="300" height="300" style="width:100%;height:100%"></canvas>
      <div style="font-size:12px;color:#cbd6dc;margin-top:6px">ミニマップ</div>
    </div>

    <div id="hud">
      <div>お金: <span id="money">¥0</span></div>
      <div>金庫数: <span id="vaultCount">0</span></div>
    </div>

    <div id="controlsUI">
      <button id="btnInteract" class="btn">行動</button>
      <button id="btnFire" class="btn">発砲</button>
    </div>

    <div id="notif" class="notif" style="display:none"></div>
  </div>
</div>

<script>
/* Fixed Part1 — robust initialization and camera controls fallback.
   Save this file as index.html and open in browser. */

function log(msg){ console.log('[VaultFix]', msg); }
function showNotif(msg, t=2200){
  const el = document.getElementById('notif');
  el.textContent = msg; el.style.display = 'block';
  clearTimeout(window._notifTO); window._notifTO = setTimeout(()=> el.style.display='none', t);
}

/* utilities */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const rand = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const fmtMoney = n => '¥' + Math.floor(n).toLocaleString('ja-JP');

const state = {
  mapSize:600,
  player: { x:300, z:300, money:12000, guns:1 },
  buildings: [], vaults: []
};

/* assets path (B mode) */
const ASSET_BASE = './assets';
const ASSETS = {
  safe_dial: `${ASSET_BASE}/safe_dial.png`,
  safe_body: `${ASSET_BASE}/safe_body.png`,
  led_green: `${ASSET_BASE}/led_green.png`,
  led_red: `${ASSET_BASE}/led_red.png`,
  click: `${ASSET_BASE}/click.mp3`,
  latch: `${ASSET_BASE}/latch_open.mp3`,
  alarm: `${ASSET_BASE}/alarm.mp3`
};

/* preloader (images only, audio optional) */
const preloaded = { images: {} };
function preloadImages(keys, cb){
  let done=0, tot=keys.length;
  if (tot===0) return cb();
  keys.forEach(k=>{
    const img = new Image();
    img.onload = ()=> { preloaded.images[k]=img; if(++done===tot) cb(); };
    img.onerror = ()=> { console.warn('missing asset', k); if(++done===tot) cb(); };
    img.src = ASSETS[k];
  });
}

/* THREE init */
let renderer, scene, camera, clock, playerMesh, buildingGroup, orbitControls, pointerControls, usingPointerLock=false;
function initThree(){
  const canvas = document.getElementById('main3d');
  // create renderer after DOM ready
  renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias:true });
  const dpr = Math.min(window.devicePixelRatio||1, 2);
  renderer.setPixelRatio(dpr);
  renderer.setSize(window.innerWidth, window.innerHeight, false);
  renderer.outputEncoding = THREE.sRGBEncoding;

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x071825);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(state.player.x - 50, 120, state.player.z + 120);
  camera.lookAt(state.player.x, 0, state.player.z);

  // lights
  const ambient = new THREE.AmbientLight(0xffffff, 0.7);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 0.5);
  dir.position.set(120,300,200);
  scene.add(dir);

  // ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(state.mapSize, state.mapSize), new THREE.MeshStandardMaterial({ color:0x142a36 }));
  ground.rotation.x = -Math.PI/2; scene.add(ground);

  playerMesh = new THREE.Mesh(new THREE.CylinderGeometry(6,6,16,8), new THREE.MeshStandardMaterial({ color:0xffc857 }));
  playerMesh.position.set(state.player.x - state.mapSize/2, 8, state.player.z - state.mapSize/2);
  scene.add(playerMesh);

  buildingGroup = new THREE.Group(); scene.add(buildingGroup);

  // controls: try pointer lock (desktop), otherwise orbit for mouse/touch rotate
  try {
    pointerControls = new THREE.PointerLockControls(camera, document.body);
    // request pointer on click (desktop only)
    renderer.domElement.addEventListener('click', (e)=>{
      if (!isMobile() && document.pointerLockElement !== document.body) {
        try { document.body.requestPointerLock(); } catch(e){ console.warn('pointer lock request failed', e); }
      }
    });
    document.addEventListener('pointerlockchange', ()=> {
      usingPointerLock = document.pointerLockElement === document.body;
      log('pointerLock changed: ' + usingPointerLock);
    });
  } catch(e){ log('PointerLockControls unavailable'); }

  // OrbitControls fallback (for mobile and debugging)
  orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
  orbitControls.enableDamping = true;
  orbitControls.dampingFactor = 0.08;
  orbitControls.enablePan = false;
  orbitControls.enabled = isMobile() || !usingPointerLock; // will toggle in animate

  // ensure canvas does not allow page scrolling via touch
  renderer.domElement.style.touchAction = 'none';

  window.addEventListener('resize', ()=> {
    const w = window.innerWidth, h = window.innerHeight;
    camera.aspect = w/h; camera.updateProjectionMatrix();
    renderer.setSize(w,h,false);
  });
}

function isMobile(){ return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent); }

/* Map generation + building visuals (guaranteed visible) */
function generateMap(){
  state.buildings = []; state.vaults = [];
  const cell = 60; const cols = Math.floor(state.mapSize / cell);
  for (let r=0;r<cols;r++){
    for (let c=0;c<cols;c++){
      const x = c*cell + rand(8, cell-8);
      const z = r*cell + rand(8, cell-8);
      const roll = Math.random();
      let k='dummy';
      if (roll < 0.02) k='bank';
      else if (roll < 0.07) k='conbini';
      else if (roll < 0.11) k='pachinko';
      else if (roll < 0.14) k='carshop';
      state.buildings.push({ kind:k, x, z, sx:rand(10,36), sz:rand(10,36) });
      if (k==='bank'||k==='conbini'||k==='pachinko'){
        state.vaults.push({ buildingIndex: state.buildings.length-1, locked:true, attempts:0, dialSolution:[rand(0,9),rand(0,9),rand(0,9),rand(0,9)], reward:(k==='bank'?50000:(k==='pachinko'?15000:4200)) });
      }
    }
  }
  if (!state.buildings.some(b=>b.kind==='bank')){
    const x=rand(80, state.mapSize-80), z=rand(80, state.mapSize-80);
    state.buildings.push({ kind:'bank', x, z, sx:56, sz:56 });
    state.vaults.push({ buildingIndex: state.buildings.length-1, locked:true, attempts:0, dialSolution:[rand(0,9),rand(0,9),rand(0,9),rand(0,9)], reward:50000 });
  }
  document.getElementById('vaultCount').textContent = state.vaults.length;
}

function buildWorldVisuals(){
  // remove existing meshes
  while(buildingGroup.children.length) {
    const m = buildingGroup.children.pop();
    if (m.geometry) { m.geometry.dispose(); }
    if (m.material) { m.material.dispose(); }
  }
  // add new
  state.buildings.forEach((b,i)=>{
    const color = kindColor(b.kind);
    const h = rand(18, 80);
    const geo = new THREE.BoxGeometry(b.sx, h, b.sz);
    const mat = new THREE.MeshStandardMaterial({ color });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(b.x - state.mapSize/2, h/2, b.z - state.mapSize/2);
    mesh.userData = { idx:i, kind: b.kind };
    buildingGroup.add(mesh);
    // label as sprite
    const label = makeLabel(b.kind);
    label.position.set(b.x - state.mapSize/2, h + 6, b.z - state.mapSize/2);
    buildingGroup.add(label);
  });
}

function kindColor(k){ switch(k){ case 'bank': return 0x2ecc71; case 'conbini': return 0x3498db; case 'pachinko': return 0xe67e22; case 'carshop': return 0x9b59b6; default: return 0x95a5a6; } }
function makeLabel(text){
  const c = document.createElement('canvas'); c.width=256; c.height=64;
  const ctx = c.getContext('2d'); ctx.clearRect(0,0,256,64); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.font='18px sans-serif'; ctx.textAlign='center'; ctx.fillText(text,128,38);
  const tex = new THREE.CanvasTexture(c); const mat = new THREE.SpriteMaterial({ map: tex, transparent:true }); const s = new THREE.Sprite(mat); s.scale.set(36,10,1); return s;
}

/* minimap */
const mini = document.getElementById('miniCanvas'), mctx = mini.getContext('2d');
function drawMinimap(){
  const W = mini.width, H = mini.height;
  mctx.fillStyle = '#02111a'; mctx.fillRect(0,0,W,H);
  const s = W / state.mapSize;
  state.buildings.forEach(b=>{
    const x = b.x * s, y = b.z * s, w = clamp(b.sx * s, 3, 18), h = clamp(b.sz * s, 3, 18);
    mctx.fillStyle = (b.kind==='bank'?'#2ecc71':(b.kind==='conbini'?'#3498db':(b.kind==='pachinko'?'#e67e22':'#95a5a6')));
    mctx.fillRect(x-w/2, y-h/2, w, h);
  });
  const px = state.player.x * s, pz = state.player.z * s;
  mctx.beginPath(); mctx.fillStyle = '#ffde59'; mctx.arc(px,pz,6,0,Math.PI*2); mctx.fill();
}

/* input and movement */
let input = { x:0, y:0, fire:false };
function setupInput(){
  // keyboard
  window.addEventListener('keydown', e=>{
    if (e.key==='w'||e.key==='ArrowUp') input.y=-1;
    if (e.key==='s'||e.key==='ArrowDown') input.y=1;
    if (e.key==='a'||e.key==='ArrowLeft') input.x=-1;
    if (e.key==='d'||e.key==='ArrowRight') input.x=1;
    if (e.code==='Space') { input.fire=true; setTimeout(()=>input.fire=false,120); }
  });
  window.addEventListener('keyup', e=>{
    if (['w','s','ArrowUp','ArrowDown'].includes(e.key)) input.y=0;
    if (['a','d','ArrowLeft','ArrowRight'].includes(e.key)) input.x=0;
  });

  // simple touch rotate: only enable orbitControls for mobile
  if (isMobile()) {
    orbitControls.enabled = true;
    // don't request pointer lock on mobile
  }
}

/* interaction */
document.getElementById('btnNew').addEventListener('click', ()=>{
  generateMap(); buildWorldVisuals(); drawMinimap(); showNotif('New map created');
});
document.getElementById('btnSave').addEventListener('click', ()=>{
  try{ localStorage.setItem('vh_quick', JSON.stringify({player:state.player, buildings:state.buildings, vaults:state.vaults})); showNotif('Saved'); }catch(e){ showNotif('Save failed'); }
});
document.getElementById('btnInteract').addEventListener('click', tryInteractNearby);
document.getElementById('btnFire').addEventListener('click', ()=> { input.fire = true; setTimeout(()=>input.fire=false,150); });

function tryInteractNearby(){
  let nearest=null, nd=1e9, idx=-1;
  state.buildings.forEach((b,i)=>{ const d=Math.hypot(b.x-state.player.x, b.z-state.player.z); if(d<nd){ nd=d; nearest=b; idx=i; } });
  if (nearest && nd < 40) {
    showNotif('Nearby: ' + nearest.kind);
    // if vault-bearing, open vault modal via enhancedOpenVaultModal if exists
    const vault = state.vaults.find(v=>v.buildingIndex===idx && v.locked);
    if (vault && window.enhancedOpenVaultModal) { window.enhancedOpenVaultModal(vault); } else if (vault) { document.getElementById('notif').textContent='Vault found (no UI hook)'; document.getElementById('notif').style.display='block'; }
  } else showNotif('No building nearby');
}

/* main loop */
let last = performance.now();
function animate(now){
  requestAnimationFrame(animate);
  const dt = (now - last) / 1000; last = now;

  // toggle orbit depending on pointer lock state
  if (pointerControls && document.pointerLockElement === document.body) {
    orbitControls.enabled = false;
  } else {
    orbitControls.enabled = true;
  }

  // movement
  const sp = 2.0;
  if (input.x !== 0 || input.y !== 0) {
    state.player.x += input.x * sp * 40 * dt;
    state.player.z += input.y * sp * 40 * dt;
    state.player.x = clamp(state.player.x, 0, state.mapSize);
    state.player.z = clamp(state.player.z, 0, state.mapSize);
    playerMesh.position.set(state.player.x - state.mapSize/2, playerMesh.position.y, state.player.z - state.mapSize/2);
  }

  // camera follow smooth 3rd-person
  const target = new THREE.Vector3(state.player.x - 50, 110, state.player.z + 120);
  camera.position.lerp(target, 0.08);
  camera.lookAt(new THREE.Vector3(state.player.x - state.mapSize/2, 0, state.player.z - state.mapSize/2));

  // update orbit damping
  if (orbitControls.enabled) orbitControls.update();

  // call downstream updates if present
  try { if (window._part2_update) window._part2_update(dt); if (window._part3_update) window._part3_update(dt); } catch(e){ console.warn('part updates error', e); }

  // render (Part3 may override via window._vh_render)
  try {
    if (window._vh_render && window.interiorActive) {
      window._vh_render(); // Part3 interior render
    } else {
      renderer.render(scene, camera);
    }
  } catch(e) {
    console.error('render error', e);
  }
}

/* init sequence */
preloadImages(['safe_dial','safe_body','led_green','led_red'], ()=>{
  try {
    initThree();
    generateMap();
    buildWorldVisuals();
    setupInput();
    drawMinimap();
    requestAnimationFrame(animate);
    showNotif('Ready — Part1 fixed');
    log('Initialization complete');
  } catch(ex) {
    console.error('Init failed', ex); showNotif('Initialization failed: see console');
  }
});

</script>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>
</body>
</body>
</html>
