<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>3D Escape Part1 — Local WebGL Engine</title>
<style>
body {
    margin:0;
    background:#000;
    overflow:hidden;
    touch-action:none;
}
#gameCanvas {
    width:100vw;
    height:100vh;
    display:block;
    background:#000;
}
#minimap {
    position:absolute;
    top:10px;
    left:10px;
    width:120px;
    height:120px;
    background:rgba(0,0,0,0.4);
    border:2px solid #fff;
}
#stick {
    position:absolute;
    bottom:40px;
    left:40px;
    width:140px;
    height:140px;
    background:rgba(255,255,255,0.1);
    border-radius:50%;
    border:2px solid #888;
}
#stickInner {
    position:absolute;
    width:60px;
    height:60px;
    background:rgba(255,255,255,0.5);
    border-radius:50%;
    left:40px;
    top:40px;
}
#debug {
    position:absolute;
    right:10px;
    top:10px;
    color:#0f0;
    font-size:12px;
    font-family:monospace;
}
</style>
</head>

<body>
<canvas id="gameCanvas"></canvas>
<canvas id="minimap"></canvas>
<div id="stick"><div id="stickInner"></div></div>
<div id="debug"></div>

<script>
// ===========================
// WebGL 初期化（黒画面防止）
// ===========================
const canvas = document.getElementById("gameCanvas");
const gl = canvas.getContext("webgl", {alpha:false});

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);
}
resize();
window.addEventListener("resize", resize);

if(!gl){
    alert("WebGLが無効です。学校タブレットで制限されている可能性があります。");
}

// ==================================
// シェーダー（完全ローカル 3D Engine）
// ==================================
const vertSrc = `
attribute vec3 pos;
attribute vec3 normal;
uniform mat4 mvp;
varying float vL;
void main(){
    vec3 light = normalize(vec3(0.2,1.0,0.3));
    vL = max(dot(normal,light),0.2);
    gl_Position = mvp * vec4(pos,1.0);
}
`;

const fragSrc = `
precision mediump float;
varying float vL;
void main(){
    gl_FragColor = vec4(vec3(0.6,0.7,0.9) * vL, 1.0);
}
`;

function createShader(src,type){
    const sh = gl.createShader(type);
    gl.shaderSource(sh,src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
        console.log(gl.getShaderInfoLog(sh));
    }
    return sh;
}

const vs = createShader(vertSrc,gl.VERTEX_SHADER);
const fs = createShader(fragSrc,gl.FRAGMENT_SHADER);

const prog = gl.createProgram();
gl.attachShader(prog,vs);
gl.attachShader(prog,fs);
gl.linkProgram(prog);
gl.useProgram(prog);

// =====================
// マップデータ（拡大版）
// =====================
const map = [
  [1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,0,1,0,1,0,1],
  [1,0,0,0,0,1,0,1,0,1],
  [1,0,1,0,1,0,0,0,0,1],
  [1,0,1,0,0,0,1,1,0,1],
  [1,0,0,0,1,0,0,0,0,1],
  [1,1,1,0,1,0,1,1,0,1],
  [1,0,0,0,0,0,0,1,0,1],
  [1,1,1,1,1,1,1,1,1,1],
];

// =============================
// 壁メッシュ作成（ローカル製）
// =============================
function makeCube(x,y,z){
    const size = 1.0;
    const hs = size/2;
    const verts = [
        // front
        -hs,0, hs,  0,0,1,
         hs,0, hs,  0,0,1,
         hs,1, hs,  0,0,1,
        -hs,1, hs,  0,0,1,

        // back
        -hs,0,-hs,  0,0,-1,
         hs,0,-hs,  0,0,-1,
         hs,1,-hs,  0,0,-1,
        -hs,1,-hs,  0,0,-1,
    ];
    const idx = [
        0,1,2,  0,2,3,
        4,5,6,  4,6,7
    ];
    return {verts,idx, pos:[x,y,z]};
}

// =============================
// 壁を全て生成
// =============================
let objects = [];
for(let j=0;j<10;j++){
    for(let i=0;i<10;i++){
        if(map[j][i] === 1){
            objects.push(makeCube(i,0,j));
        }
    }
}

// ===========================
// WebGL バッファ構築
// ===========================
let vboList=[];
let iboList=[];
let transformList=[];

objects.forEach(obj=>{
    const vb = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER,vb);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(obj.verts),gl.STATIC_DRAW);

    const ib = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ib);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(obj.idx),gl.STATIC_DRAW);

    transformList.push(obj.pos);
    vboList.push(vb);
    iboList.push(ib);
});

// attribute pointer
const posLoc = gl.getAttribLocation(prog,"pos");
const normalLoc = gl.getAttribLocation(prog,"normal");
gl.enableVertexAttribArray(posLoc);
gl.enableVertexAttribArray(normalLoc);

// ===========================
// カメラ・移動
// ===========================
let px=2.5, py=0.4, pz=2.5;
let rot=0;
let vx=0, vz=0;

// ========== 仮想スティック ==========
const stick = document.getElementById("stick");
const inner = document.getElementById("stickInner");
let stickActive=false;
let sx=0, sy=0;

stick.addEventListener("touchstart", e=>{
    stickActive=true;
});

stick.addEventListener("touchmove", e=>{
    const r = 70;
    const rect = stick.getBoundingClientRect();
    const tx = e.touches[0].clientX - (rect.left + r);
    const ty = e.touches[0].clientY - (rect.top + r);

    const dist = Math.min(Math.sqrt(tx*tx + ty*ty), r);
    const ang = Math.atan2(ty,tx);

    inner.style.left = (dist*Math.cos(ang)+r-30)+"px";
    inner.style.top  = (dist*Math.sin(ang)+r-30)+"px";

    sx = (dist/r)*Math.cos(ang);
    sy = (dist/r)*Math.sin(ang);
});

stick.addEventListener("touchend", e=>{
    stickActive=false;
    inner.style.left = "40px";
    inner.style.top = "40px";
    sx=0; sy=0;
});

// ==============================
// カメラ行列生成（行列自前）
// ==============================
function matMul(a,b){
    const r = new Float32Array(16);
    for(let i=0;i<4;i++){
        for(let j=0;j<4;j++){
            r[i*4+j]=
                a[i*4+0]*b[0*4+j]+
                a[i*4+1]*b[1*4+j]+
                a[i*4+2]*b[2*4+j]+
                a[i*4+3]*b[3*4+j];
        }
    }
    return r;
}

function matIdentity(){
    const m=new Float32Array(16);
    m[0]=m[5]=m[10]=m[15]=1;
    return m;
}

function matTranslate(tx,ty,tz){
    const m=matIdentity();
    m[12]=tx; m[13]=ty; m[14]=tz;
    return m;
}

function matRotateY(a){
    const m=matIdentity();
    const c=Math.cos(a), s=Math.sin(a);
    m[0]=c; m[2]=s;
    m[8]=-s; m[10]=c;
    return m;
}

function matPerspective(fov,aspect,near,far){
    const f = 1/Math.tan(fov/2);
    const m = new Float32Array(16);
    m[0]=f/aspect;
    m[5]=f;
    m[10]=(far+near)/(near-far);
    m[11]=-1;
    m[14]=(2*far*near)/(near-far);
    return m;
}

const mvpLoc = gl.getUniformLocation(prog,"mvp");

// ===========================
// 毎フレーム処理
// ===========================
const mini = document.getElementById("minimap");
const miniCtx = mini.getContext("2d");
const debug = document.getElementById("debug");

function loop(){
    requestAnimationFrame(loop);

    // ========== 移動 ==========
    const speed = 0.05;
    vx = Math.cos(rot)*sy + Math.sin(rot)*sx;
    vz = Math.sin(rot)*sy - Math.cos(rot)*sx;

    // 壁貫通防止
    let nx = px + vx*speed;
    let nz = pz + vz*speed;

    if(map[Math.floor(pz)][Math.floor(nx)] === 0) px = nx;
    if(map[Math.floor(nz)][Math.floor(px)] === 0) pz = nz;

    // ========== 描画 ==========
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);

    const proj = matPerspective(1.0, canvas.width/canvas.height, 0.1, 100.0);
    const view = matMul(matRotateY(rot), matTranslate(-px,-py,-pz));

    for(let i=0;i<vboList.length;i++){
        gl.bindBuffer(gl.ARRAY_BUFFER, vboList[i]);
        gl.vertexAttribPointer(posLoc,3,gl.FLOAT,false,24,0);
        gl.vertexAttribPointer(normalLoc,3,gl.FLOAT,false,24,12);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboList[i]);

        const t = matTranslate(
            transformList[i][0],
            transformList[i][1],
            transformList[i][2]
        );

        const mvp = matMul(proj, matMul(view, t));
        gl.uniformMatrix4fv(mvpLoc,false,mvp);

        gl.drawElements(gl.TRIANGLES,12,gl.UNSIGNED_SHORT,0);
    }

    // ========== ミニマップ ==========
    miniCtx.fillStyle="black";
    miniCtx.fillRect(0,0,120,120);

    for(let j=0;j<10;j++){
        for(let i=0;i<10;i++){
            if(map[j][i]===1){
                miniCtx.fillStyle="#fff";
                miniCtx.fillRect(i*12,j*12,12,12);
            }
        }
    }
    miniCtx.fillStyle="red";
    miniCtx.beginPath();
    miniCtx.arc(px*12,pz*12,4,0,Math.PI*2);
    miniCtx.fill();

    // ========== デバッグ ==========
    debug.innerText=
        `x:${px.toFixed(2)} z:${pz.toFixed(2)} rot:${rot.toFixed(2)}`;
}
loop();

// ========== 画面ドラッグで視点回転 ==========
let drag=false, lx=0;
document.addEventListener("mousedown",e=>{ drag=true; lx=e.clientX; });
document.addEventListener("mouseup",e=>{ drag=false; });
document.addEventListener("mousemove",e=>{
    if(drag){
        const dx = e.clientX - lx;
        rot -= dx*0.005;
        lx = e.clientX;
    }
});

// スマホ用視点
document.addEventListener("touchmove",e=>{
    if(e.touches.length===2){
        const dx = e.touches[1].clientX - e.touches[0].clientX;
        rot -= dx*0.0008;
    }
});

</script>
</body>
</html>
