<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Vault Heist ‚Äî GitHub Pages Optimized (Part1)</title>

<!--
  Part1:
    - head, styles, safe script loaders
    - deferred initialization wrapper (window.onload -> initGame())
    - pointerLock safe wrapper
    - lightweight loading UI (0% handling fix)
  Note: This is Part1. You MUST append Part2..N after this to form the full index.html.
-->

<!-- Use secure https CDNs; keep as-is so Babylon & Howler are available -->
<script id="babylonjs" src="https://cdn.babylonjs.com/babylon.js"></script>
<script id="babylon-loaders" src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
<script id="babylon-gui" src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
<script id="howler" src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>

<style>
  :root{
    --bg:#071026; --accent:#ffd166; --panel:rgba(255,255,255,0.04);
    --hud-font: "Noto Sans JP", "Helvetica", "Arial", sans-serif;
  }
  html,body{ margin:0; height:100%; width:100%; background:linear-gradient(#071026,#07182a); color:#fff; font-family:var(--hud-font); -webkit-font-smoothing:antialiased; -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color:transparent;}
  #renderCanvas{ width:100%; height:100vh; display:block; touch-action:none; background:transparent; }
  /* HUD */
  #hud{ position:fixed; left:12px; top:12px; z-index:110; display:flex; gap:8px; align-items:center; pointer-events:none; }
  .badge{ background:rgba(0,0,0,0.45); padding:8px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); color:var(--accent); font-weight:700; pointer-events:auto; }
  .small{ font-size:12px; color:#cfe; font-weight:600; }
  #shopBtn{ position:fixed; right:12px; top:12px; z-index:110; padding:8px 12px; background:rgba(0,0,0,0.45); border-radius:8px; color:#fff; border:1px solid rgba(255,255,255,0.03); pointer-events:auto; }
  #controls{ position:fixed; left:12px; right:12px; bottom:12px; display:flex; justify-content:space-between; align-items:flex-end; z-index:115; pointer-events:none; gap:6px; }
  #joystick{ width:110px; height:110px; background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), rgba(0,0,0,0.08)); border-radius:999px; pointer-events:auto; opacity:0.95; border:1px solid rgba(255,255,255,0.03); }
  .action-buttons{ pointer-events:auto; display:flex; gap:8px; }
  .act{ background:rgba(0,0,0,0.6); color:#fff; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.04); font-weight:700; }
  #crosshair{ position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); width:12px; height:12px; border-radius:50%; background:#fff; opacity:0.85; z-index:105; pointer-events:none; }
  #notice{ position:fixed; left:50%; bottom:140px; transform:translateX(-50%); z-index:120; color:#f66; display:none; background: rgba(0,0,0,0.55); padding:8px 14px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); pointer-events:none; }
  .modal{ position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); background:rgba(8,10,14,0.95); color:#fff; padding:12px; border-radius:12px; z-index:130; display:none; width:min(820px,94%); max-width:820px; border:1px solid rgba(255,255,255,0.04); box-shadow:0 6px 24px rgba(0,0,0,0.6); pointer-events:auto; }
  .modal h2{ margin:0 0 10px 0; font-size:18px; }
  /* Loading UI (top center) */
  #loadingWrap{ position:fixed; left:50%; top:8px; transform:translateX(-50%); z-index:140; width:360px; max-width:92%; pointer-events:none; }
  #loadingBar{ height:10px; background:rgba(255,255,255,0.06); border-radius:8px; overflow:hidden; border:1px solid rgba(255,255,255,0.03); }
  #loadingFill{ width:0%; height:100%; background:linear-gradient(90deg,#ffd166,#ffb86b); transition:width 300ms ease; }
  #loadingLabel{ margin-top:6px; text-align:center; font-size:13px; color:#dfe; }
  @media (max-width:640px){
    #crosshair{ width:8px; height:8px; }
    .badge{ padding:6px 8px; font-size:13px; }
    #joystick{ width:96px; height:96px; }
  }
</style>

</head>
<body>
  <canvas id="renderCanvas" touch-action="none"></canvas>

  <div id="hud">
    <div class="badge">ÊâÄÊåÅÈáë: <span id="money">0</span> ÂÜÜ</div>
    <div class="badge small">„É©„Ç§„Éï: <span id="life">3</span></div>
    <div class="badge small">Ë≠¶Â†±: <span id="alarm">0</span></div>
  </div>

  <button id="shopBtn" class="act">SHOP</button>

  <div id="controls">
    <div id="joystick"></div>
    <div class="action-buttons">
      <div class="act" id="btnAction">Êìç‰Ωú</div>
      <div class="act" id="btnFire">ÊíÉ„Å§</div>
      <div class="act" id="btnEnter">‰πó„Çã/Èôç„Çä„Çã</div>
    </div>
  </div>

  <div id="crosshair"></div>
  <div id="notice"></div>

  <div id="shopModal" class="modal">
    <h2>SHOP</h2>
    <div class="shop-grid" id="shopContent"></div>
    <div style="width:100%; text-align:right; margin-top:8px;"><button class="act" id="shopClose">Èñâ„Åò„Çã</button></div>
  </div>

  <!-- Loading UI -->
  <div id="loadingWrap" aria-hidden="false">
    <div id="loadingBar"><div id="loadingFill"></div></div>
    <div id="loadingLabel">Ë™≠„ÅøËæº„Åø‰∏≠... 0%</div>
  </div>

<script>
/* Part1 runtime bootstrap & safe initializers
   - Provides robust loading percent handling (fixes 0% freeze)
   - Adds try/catch wrappers around Babylon init
   - Ensures pointerLock is called only when available (no TypeError)
   - Prepares placeholder exports/objects for Part2 to extend
*/

/* ---------- safe DOM refs ---------- */
const $canvas = document.getElementById('renderCanvas');
const $loadingFill = document.getElementById('loadingFill');
const $loadingLabel = document.getElementById('loadingLabel');
const $loadingWrap = document.getElementById('loadingWrap');

let ASSET_TOTAL = 0;
let ASSET_LOADED = 0;
let LOADED_MANUALLY = false;

/* update loading UI (safe - never stuck at 0 permanently) */
function setLoadingProgress(pct, label){
  pct = Math.max(0, Math.min(100, Math.round(pct)));
  $loadingFill.style.width = pct + '%';
  $loadingLabel.innerText = (label || 'Ë™≠„ÅøËæº„Åø‰∏≠...') + ' ' + pct + '%';
  // hide after fully loaded
  if(pct >= 100){
    $loadingWrap.style.opacity = '0';
    setTimeout(()=> $loadingWrap.style.display='none', 500);
  }
}

/* fallback incremental progress incrementer:
   When external asset trackers stall, this will slowly nudge the bar
   so the user sees activity, then Part2 will call markAssetLoaded(true) when ready.
*/
let _progressTicker = null;
function startProgressTicker(){
  if(_progressTicker) return;
  _progressTicker = setInterval(()=>{
    const pct = ASSET_TOTAL === 0 ? Math.min(95, ASSET_LOADED + Math.round(Math.random()*8)) : Math.min(95, Math.round((ASSET_LOADED/Math.max(1,ASSET_TOTAL))*100) + 2);
    setLoadingProgress(pct);
  }, 600);
}
function stopProgressTicker(){
  if(_progressTicker){ clearInterval(_progressTicker); _progressTicker = null; }
}

/* Called by Part2 to register number of expected assets (models/textures/sounds).
   If not used, default ticker prevents freeze.
*/
function registerExpectedAssets(n){
  ASSET_TOTAL = Math.max(0, Math.floor(n));
  ASSET_LOADED = 0;
  if(ASSET_TOTAL > 0) startProgressTicker();
}

/* Called by Part2 each time an asset actually finished or errored.
   If finishAll true, immediately set to 100%.
*/
function markAssetLoaded(finishAll){
  if(finishAll){
    ASSET_LOADED = ASSET_TOTAL;
    setLoadingProgress(100, 'Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü');
    stopProgressTicker();
    return;
  }
  ASSET_LOADED++;
  if(ASSET_TOTAL > 0){
    const pct = Math.round((ASSET_LOADED/ASSET_TOTAL)*100);
    setLoadingProgress(pct, 'Ë™≠„ÅøËæº„Åø‰∏≠...');
    if(ASSET_LOADED >= ASSET_TOTAL){
      setLoadingProgress(100, 'Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü');
      stopProgressTicker();
    }
  } else {
    // no expected assets -> just complete
    setLoadingProgress(100, 'Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü');
    stopProgressTicker();
  }
}

/* pointer lock safe wrapper */
function safeRequestPointerLock(){
  try{
    const c = (engine && engine.getRenderingCanvas) ? engine.getRenderingCanvas() : $canvas;
    if(c && typeof c.requestPointerLock === 'function'){
      c.requestPointerLock();
    } else if(c && typeof c.msRequestPointerLock === 'function'){
      c.msRequestPointerLock();
    } else {
      // not available in iframe environments (JSFiddle) or some mobile browsers - silently ignore
      // no exception thrown
    }
  }catch(e){
    console.warn('pointerLock failed (ignored):', e);
  }
}

/* small helper to ensure Babylon modules are loaded */
function ensureBabylonReady(timeoutMs = 3500){
  return new Promise((resolve, reject) => {
    if(typeof BABYLON !== 'undefined'){
      return resolve();
    }
    // wait for libs to load (rare edge-case on slow CDN)
    let waited = 0;
    const iv = setInterval(()=>{
      waited += 200;
      if(typeof BABYLON !== 'undefined'){ clearInterval(iv); resolve(); }
      else if(waited >= timeoutMs){ clearInterval(iv); reject(new Error('Babylon.js load timeout')); }
    }, 200);
  });
}

/* ---------- engine & scene placeholders (defined in Part2) ---------- */
// engine, scene, cameras and many objects will be created in Part2's initGame()
// we declare placeholders here to avoid ReferenceErrors when Part1 helpers are used earlier.
let engine = null;
let scene = null;
let mainCamera = null;

/* ---------- robust init: wait until window.onload then start initGame (Part2 must provide) ---------- */
window.addEventListener('load', async () => {
  // show loading immediately and start ticker to avoid 0% freeze
  $loadingWrap.style.display = 'block';
  $loadingWrap.style.opacity = '1';
  setLoadingProgress(3, 'ÂàùÊúüÂåñ‰∏≠...');
  startProgressTicker();

  try{
    // ensure Babylon libs loaded
    await ensureBabylonReady(4000);
  }catch(err){
    // Babylon not available: show clear message and stop
    setLoadingProgress(100, 'Babylon.js Ë™≠„ÅøËæº„ÅøÂ§±Êïó');
    stopProgressTicker();
    console.error('Babylon.js failed to load:', err);
    const el = document.createElement('div'); el.style.cssText = 'position:fixed; left:50%; top:48%; transform:translate(-50%,-50%); z-index:9999; background:#111; color:#fff; padding:16px; border-radius:12px; box-shadow:0 6px 24px rgba(0,0,0,0.6);';
    el.innerHTML = '<strong>Babylon.js „ÇíË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</strong><br>CDN„Åå„Éñ„É≠„ÉÉ„ÇØ„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÅ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÅÆÂïèÈ°å„Åß„Åô„ÄÇ';
    document.body.appendChild(el);
    return;
  }

  // Now call the real initializer (implemented in Part2)
  try{
    if(typeof initGame === 'function'){
      await initGame({
        canvas: $canvas,
        markAssetLoaded,
        registerExpectedAssets,
        safeRequestPointerLock,
        setLoadingProgress
      });
      // mark final loaded if Part2 didn't explicitly mark
      markAssetLoaded(true);
    } else {
      console.error('initGame not found: ensure Part2..N are appended and define initGame()');
      setLoadingProgress(100, 'ÂàùÊúüÂåñ„Ç®„É©„Éº');
      stopProgressTicker();
      const el = document.createElement('div'); el.style.cssText = 'position:fixed; left:50%; top:48%; transform:translate(-50%,-50%); z-index:9999; background:#111; color:#fff; padding:16px; border-radius:12px;';
      el.innerHTML = '<strong>„Ç≤„Éº„É†ÂàùÊúüÂåñÈñ¢Êï∞„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ</strong><br>index.html „ÅÆ„Éë„Éº„ÉÑ„ÅåÊèÉ„Å£„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
      document.body.appendChild(el);
    }
  }catch(initErr){
    console.error('initGame failed:', initErr);
    setLoadingProgress(100, 'ÂàùÊúüÂåñÂ§±Êïó');
    stopProgressTicker();
    const el = document.createElement('div'); el.style.cssText = 'position:fixed; left:50%; top:48%; transform:translate(-50%,-50%); z-index:9999; background:#111; color:#fff; padding:16px; border-radius:12px;';
    el.innerHTML = `<strong>ÂàùÊúüÂåñ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ</strong><br>${(initErr && initErr.message) ? initErr.message : 'Ë©≥Á¥∞„ÅØ„Ç≥„É≥„ÇΩ„Éº„É´'}`;
    document.body.appendChild(el);
  }
});
</script>

<!-- Part1 END -->
<!-- Append Part2 (game logic, scene creation, event handlers, runtime) after this line -->
<!-- Part2: „Ç≤„Éº„É†Êú¨‰ΩìÔºàinitGameÂÆüË£ÖÔºâ -->
<script>
/*
  Part2:
    - exports initGame(options)
    - creates engine, scene, cameras, lights
    - builds procedural city (many buildings)
    - player/collider/camera, vehicle primitive, weapon visuals
    - shop UI, safe minigame, police AI, bullets
    - integrates with Part1's loading helpers via options.markAssetLoaded/registerExpectedAssets
*/

async function initGame(opts = {}) {
  // receive helpers from Part1
  const markAssetLoaded = opts.markAssetLoaded || function(){};
  const registerExpectedAssets = opts.registerExpectedAssets || function(){};
  const safeRequestPointerLock = opts.safeRequestPointerLock || function(){};
  const setLoadingProgress = opts.setLoadingProgress || function(){};

  return new Promise((resolveInit, rejectInit) => {
    try{
      // ---------- engine & scene ----------
      engine = new BABYLON.Engine(opts.canvas || document.getElementById('renderCanvas'), true, { preserveDrawingBuffer:true, stencil:true });
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.03,0.07,0.12);

      // basic cameras
      const camFP = new BABYLON.UniversalCamera("camFP", new BABYLON.Vector3(0,1.6,-6), scene);
      camFP.minZ = 0.1; camFP.attachControl(opts.canvas, true);
      camFP.speed = 0;
      const camFollow = new BABYLON.ArcRotateCamera("camFollow", -Math.PI/2, Math.PI/3.6, 8, BABYLON.Vector3.Zero(), scene);
      camFollow.lowerRadiusLimit = 3; camFollow.upperRadiusLimit = 18;

      mainCamera = camFP;
      scene.activeCamera = mainCamera;

      // lights
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene); hemi.intensity = 0.9;
      const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.6,-1,0.3), scene); dir.position = new BABYLON.Vector3(40,60,20); dir.intensity = 0.95;
      dir.shadowEnabled = true;

      // shadow generator - moderate quality
      const shadowGen = new BABYLON.ShadowGenerator(1024, dir);
      shadowGen.useBlurExponentialShadowMap = true;
      shadowGen.blurKernel = 16;

      // ground
      const ground = BABYLON.MeshBuilder.CreateGround("ground",{width:1400, height:1400}, scene);
      const gmat = new BABYLON.StandardMaterial("gmat", scene);
      gmat.diffuseColor = new BABYLON.Color3(0.04,0.08,0.12);
      ground.material = gmat;
      ground.receiveShadows = true;

      // ---------- persistent state ----------
      let money = Number(localStorage.getItem('vh_money') || 0);
      let life = Number(localStorage.getItem('vh_life') || 3);
      let alarmLevel = Number(localStorage.getItem('vh_alarm') || 0);

      function saveAll(){ localStorage.setItem('vh_money', String(money)); localStorage.setItem('vh_life', String(life)); localStorage.setItem('vh_alarm', String(alarmLevel)); }
      function updateHUD(){ document.getElementById('money').innerText = money.toLocaleString(); document.getElementById('life').innerText = life; document.getElementById('alarm').innerText = Math.round(alarmLevel); }
      updateHUD();

      // ---------- helper utilities ----------
      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
      function randRange(a,b){ return a + Math.random()*(b-a); }

      // register assets = 0 (we are procedural), but keep 1 to show progress smoothness
      registerExpectedAssets(1);

      // ---------- player collider ----------
      const player = BABYLON.MeshBuilder.CreateCapsule("playerCol", {height:1.0, radius:0.28, capSubdivisions:4}, scene);
      player.isVisible = false; player.position = new BABYLON.Vector3(0,0.5,0);

      let playerState = { onFoot:true, weapon:'pistol' };

      // ---------- create procedural city ----------
      const BUILDINGS = [];
      function createBuilding(x,z,type,reward){
        const height = 6 + Math.random()*18;
        const box = BABYLON.MeshBuilder.CreateBox(type + "_b_" + x + "_" + z, {height: height, width: 24, depth:24}, scene);
        box.position = new BABYLON.Vector3(x, height/2, z);
        const m = new BABYLON.StandardMaterial('mat_'+x+'_'+z, scene);
        // colors by type
        if(type==='bank') m.diffuseColor = new BABYLON.Color3(0.2,0.45,1);
        else if(type==='casino') m.diffuseColor = new BABYLON.Color3(1,0.28,0.45);
        else if(type==='conveni') m.diffuseColor = new BABYLON.Color3(0.2,1,0.6);
        else if(type==='gunshop') m.diffuseColor = new BABYLON.Color3(0.6,0.55,0.2);
        else m.diffuseColor = new BABYLON.Color3(0.7,0.7,0.75);
        box.material = m;
        box.receiveShadows = true;
        shadowGen.addShadowCaster(box);

        const door = BABYLON.MeshBuilder.CreateBox('door_'+x+'_'+z, {height:2.2,width:1.6,depth:0.2}, scene);
        door.material = new BABYLON.StandardMaterial('dmat', scene); door.material.diffuseColor = new BABYLON.Color3(0.08,0.08,0.08);
        door.position = box.position.add(new BABYLON.Vector3(0, -height/2 + 1.1, 12.1));

        const safe = BABYLON.MeshBuilder.CreateBox('safe_'+x+'_'+z, {height:1,width:1,depth:1}, scene);
        const sm = new BABYLON.StandardMaterial('smat', scene); sm.diffuseColor = new BABYLON.Color3(0.55,0.55,0.55);
        safe.material = sm;
        safe.position = box.position.add(new BABYLON.Vector3(0, -height/2 + 1.0, 10.8));
        safe._isSafe = true;

        const label = new BABYLON.DynamicTexture('lbl_'+x+'_'+z, {width:512,height:128}, scene);
        label.drawText(type.toUpperCase(), null, 64, "bold 32px Arial", "#ffd166", "transparent", true);
        const lmat = new BABYLON.StandardMaterial('lmat_'+x+'_'+z, scene); lmat.diffuseTexture = label; lmat.emissiveColor = new BABYLON.Color3(1,0.85,0.4);
        const plane = BABYLON.MeshBuilder.CreatePlane('plane_'+x+'_'+z, {width:4,height:0.9}, scene);
        plane.material = lmat; plane.position = box.position.add(new BABYLON.Vector3(0, height/2 + 1.0, 0)); plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

        BUILDINGS.push({mesh:box, safe, type, reward, opened:false});
      }

      function generateCity(centerX=0, centerZ=0, blocks=4){
        const spacing = 30;
        for(let ix=-blocks; ix<=blocks; ix++){
          for(let iz=-blocks; iz<=blocks; iz++){
            const r = Math.random();
            let type='shop', reward=10000;
            if(r < 0.06){ type='bank'; reward = 120000; }
            else if(r < 0.14){ type='casino'; reward = 45000; }
            else if(r < 0.30){ type='conveni'; reward = 8000; }
            else if(r < 0.42){ type='gunshop'; reward = 20000; }
            else if(r < 0.50){ type='carshop'; reward = 30000; }
            else { type='shop'; reward = 5000 + Math.floor(Math.random()*20000); }

            const x = centerX + ix*spacing + (Math.random()*6-3);
            const z = centerZ + iz*spacing + (Math.random()*6-3);
            createBuilding(x,z,type,reward);
          }
        }
      }
      generateCity(0,0,5);

      // ---------- vehicle primitive ----------
      function createVehicle(){
        const root = new BABYLON.TransformNode('vehRoot', scene);
        const body = BABYLON.MeshBuilder.CreateBox('vehBody', {height:0.5,width:2.0,depth:3.6}, scene);
        body.parent = root; body.position.y = 0.25;
        const mat = new BABYLON.StandardMaterial('vehMat', scene); mat.diffuseColor = new BABYLON.Color3(0.8,0.12,0.12); body.material = mat;

        for(let sx of [-0.9,0.9]){
          for(let sz of [-1.4,1.4]){
            const w = BABYLON.MeshBuilder.CreateCylinder('wheel',{height:0.28, diameter:0.9, tessellation:12}, scene);
            w.rotation.z = Math.PI/2; w.parent = root; w.position = new BABYLON.Vector3(sx,-0.1,sz);
            w.material = new BABYLON.StandardMaterial('wmat', scene); w.material.diffuseColor = new BABYLON.Color3(0.05,0.05,0.05);
          }
        }
        return root;
      }
      const vehicle = createVehicle();
      vehicle.position = new BABYLON.Vector3(0,0.5,-10);
      shadowGen.addShadowCaster(vehicle);

      let vehicleState = { vel:0, dir:0, steerAngle:0, onCar:false, maxSpeed:80, accel:45, brake:80, wheelbase:1.6 };

      function updateVehicle(dt, input){
        const throttle = clamp(input.throttle, -1, 1);
        const steer = clamp(input.steer, -1, 1);
        if(throttle > 0) vehicleState.vel += vehicleState.accel * throttle * dt;
        else vehicleState.vel *= (1 - 0.02*dt*60);
        if(input.brake) vehicleState.vel -= vehicleState.brake * dt;
        vehicleState.vel = clamp(vehicleState.vel, -12, vehicleState.maxSpeed);
        const speedFactor = Math.max(0.12, 1 - (vehicleState.vel/vehicleState.maxSpeed));
        vehicleState.steerAngle = 0.45 * steer * speedFactor;
        if(Math.abs(vehicleState.steerAngle) > 0.001){
          const R = vehicleState.wheelbase / Math.tan(vehicleState.steerAngle);
          const angVel = vehicleState.vel / R;
          vehicleState.dir += angVel * dt;
        }
        vehicle.position.x += Math.sin(vehicleState.dir) * vehicleState.vel * dt;
        vehicle.position.z += Math.cos(vehicleState.dir) * vehicleState.vel * dt * -1;
        vehicle.rotation.y = vehicleState.dir;
      }

      // ---------- weapons procedural ----------
      const WEAPONS = {
        pistol: {name:'„Éî„Çπ„Éà„É´', dmg:1, rate:0.7, owned:true, model:null},
        smg: {name:'SMG', dmg:1, rate:0.22, owned:false, model:null},
        rifle: {name:'„É©„Ç§„Éï„É´', dmg:2, rate:0.9, owned:false, model:null},
        shotgun: {name:'„Ç∑„Éß„ÉÉ„Éà„Ç¨„É≥', dmg:3, rate:1.4, owned:false, model:null},
      };

      function createGunVisual(k){
        const root = new BABYLON.TransformNode('gun_'+k, scene);
        const body = BABYLON.MeshBuilder.CreateBox('gbody_'+k,{height:0.18,width:0.9,depth:0.26}, scene);
        body.parent = root; body.position = new BABYLON.Vector3(0,0,0);
        const mat = new BABYLON.StandardMaterial('gmat_'+k, scene); mat.diffuseColor = new BABYLON.Color3(0.09,0.09,0.09); body.material = mat;
        if(k==='smg'){ const mag = BABYLON.MeshBuilder.CreateBox('mag_'+k,{height:0.5,width:0.18,depth:0.28}, scene); mag.parent = root; mag.position = new BABYLON.Vector3(-0.25,-0.2,0.05); mag.material = mat; }
        if(k==='rifle'){ const barrel = BABYLON.MeshBuilder.CreateBox('bar_'+k,{height:0.12,width:1.6,depth:0.12}, scene); barrel.parent = root; barrel.position = new BABYLON.Vector3(0.7,0,0); barrel.material = mat; }
        return root;
      }

      for(const k in WEAPONS){
        WEAPONS[k].model = createGunVisual(k);
        WEAPONS[k].model.setEnabled(false);
      }

      function equipWeapon(k){
        for(const kk in WEAPONS) if(WEAPONS[kk].model) WEAPONS[kk].model.setEnabled(false);
        if(WEAPONS[k] && WEAPONS[k].model){
          WEAPONS[k].model.parent = player;
          WEAPONS[k].model.position = new BABYLON.Vector3(0.2,0.0,0.5);
          WEAPONS[k].model.rotation = new BABYLON.Vector3(0,Math.PI,0);
          WEAPONS[k].model.setEnabled(true);
          playerState.weapon = k;
        }
      }
      equipWeapon('pistol');

      // ---------- bullets ----------
      const BULLETS = []; // {pos, vel, life, owner, dmg}
      function spawnPlayerBullet(){
        if(!playerState.onFoot) return;
        const w = WEAPONS[playerState.weapon] || WEAPONS.pistol;
        const fwd = getPlayerForward();
        const start = player.position.add(new BABYLON.Vector3(fwd.x*0.6,0.6,fwd.z*0.6));
        const vel = fwd.scale((w.name==='„É©„Ç§„Éï„É´')?2.0:1.6);
        BULLETS.push({pos:start.clone(), vel, life:240, owner:'player', dmg:w.dmg});
      }
      function spawnPoliceBullet(fromPos, targetPos){
        const dir = targetPos.subtract(fromPos).normalize();
        const err = new BABYLON.Vector3(randRange(-0.08,0.08), randRange(-0.04,0.04), randRange(-0.08,0.08));
        BULLETS.push({pos:fromPos.clone(), vel:dir.add(err).normalize().scale(1.3), life:240, owner:'police', dmg:1});
      }

      function updateBullets(dt){
        // cleanup previous visuals
        scene.meshes.filter(m=>m._isBulletMesh).forEach(m=>{ try{ m.dispose(); }catch(e){} });
        for(let i=BULLETS.length-1;i>=0;i--){
          const b = BULLETS[i];
          b.pos.addInPlace(b.vel.scale(dt*60));
          b.life -= dt*60;
          // collision with police
          for(let j=policeNPCs.length-1;j>=0;j--){
            const npc = policeNPCs[j];
            if(npc.mesh && BABYLON.Vector3.Distance(b.pos, npc.mesh.position) < 1.0 && b.owner === 'player'){
              npc.hp -= b.dmg || 1;
              BULLETS.splice(i,1);
              break;
            }
          }
          // collision with player
          if(b.owner === 'police' && BABYLON.Vector3.Distance(b.pos, player.position) < 1.0){
            life -= 1; updateHUD(); showNotice('Ë¢´ÂºæÔºÅ ÊÆã„Çä„É©„Ç§„Éï: ' + life, 1200);
            BULLETS.splice(i,1);
            if(life <= 0){ showNotice('„ÅÇ„Å™„Åü„ÅØÊ≠ª‰∫°„Åó„Åæ„Åó„Åü„ÄÇ„É™„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 4000); setTimeout(()=>location.reload(),1500); }
            continue;
          }
          // environment ray
          const ray = new BABYLON.Ray(b.pos, b.vel.normalize(), 0.4);
          const pick = scene.pickWithRay(ray, (m)=> m && m !== player && !m._excludeFromBulletCheck);
          if(pick && pick.hit){ BULLETS.splice(i,1); continue; }
          if(b.life <= 0) BULLETS.splice(i,1);
        }
        for(const b of BULLETS){
          const s = BABYLON.MeshBuilder.CreateSphere('b', {diameter:0.16}, scene);
          s.position.copyFrom(b.pos); s._isBulletMesh = true;
          const bm = new BABYLON.StandardMaterial('bm', scene); bm.emissiveColor = (b.owner==='player')?new BABYLON.Color3(1,0.85,0.2):new BABYLON.Color3(1,0.2,0.2);
          s.material = bm;
          setTimeout(()=>{ try{ s.dispose(); }catch(e){} }, 140);
        }
      }

      // ---------- police AI ----------
      const policeNPCs = [];
      function spawnPoliceGroup(count=1){
        for(let i=0;i<count;i++){
          const p = { pos: player.position.add(new BABYLON.Vector3(randRange(-12,12),0,randRange(-12,12))), hp:4 + Math.floor(Math.random()*4), mesh:null, cooldown:0 };
          p.mesh = BABYLON.MeshBuilder.CreateBox('pol_npc',{height:1.6,width:1.2,depth:1.6}, scene);
          p.mesh.position = p.pos.clone();
          p.mesh.material = new BABYLON.StandardMaterial('pmat', scene);
          p.mesh.material.diffuseColor = new BABYLON.Color3(0.06,0.18,0.9);
          shadowGen.addShadowCaster(p.mesh);
          policeNPCs.push(p);
        }
        showNotice('Ë≠¶ÂØü„ÅåÂá∫Âãï„Åó„Åæ„Åó„ÅüÔºÅ', 2000);
      }

      function updatePoliceAI(dt){
        for(let i=policeNPCs.length-1;i>=0;i--){
          const npc = policeNPCs[i];
          if(!npc.mesh) continue;
          const dir = player.position.subtract(npc.mesh.position);
          const dist = dir.length();
          const nd = dir.normalize();
          npc.mesh.position.addInPlace(nd.scale((dist>10)?1.2*dt*60*0.01:0.9*dt*60*0.01));
          npc.cooldown -= dt;
          if(npc.cooldown <= 0 && dist < 24){
            npc.cooldown = 0.8 + Math.random()*0.9;
            spawnPoliceBullet(npc.mesh.position.add(new BABYLON.Vector3(0,0.9,0)), player.position.add(new BABYLON.Vector3(0,0.7,0)));
          }
          if(dist < 1.4){
            showNotice('ÈÄÆÊçï„Åï„Çå„Åæ„Åó„Åü„ÄÇ„É™„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', 3000);
            setTimeout(()=>location.reload(),1500);
          }
          if(npc.hp <= 0){
            try{ npc.mesh.dispose(); }catch(e){} policeNPCs.splice(i,1);
            const reward = Math.floor(randRange(3000,18000)); money += reward; updateHUD(); saveAll();
          }
        }
      }

      // ---------- safe minigame integration ----------
      // For Part1 -> overlay handlers will be triggered when player clicks safe (we will set event listener below)

      // ---------- shop UI wiring ----------
      const shopBtn = document.getElementById('shopBtn');
      const shopModal = document.getElementById('shopModal');
      const shopContent = document.getElementById('shopContent');
      document.getElementById('shopClose').addEventListener('click', ()=> shopModal.style.display='none');
      shopBtn.addEventListener('click', ()=>{
        shopContent.innerHTML = '';
        const items = [
          {id:'slot', name:'„Çπ„É≠„ÉÉ„Éà - 5,000ÂÜÜ', cost:5000, type:'slot'},
          {id:'smg', name:'SMG - 28,000ÂÜÜ', cost:28000, type:'weapon', key:'smg'},
          {id:'rifle', name:'„É©„Ç§„Éï„É´ - 45,000ÂÜÜ', cost:45000, type:'weapon', key:'rifle'},
          {id:'shotgun', name:'„Ç∑„Éß„ÉÉ„Éà„Ç¨„É≥ - 38,000ÂÜÜ', cost:38000, type:'weapon', key:'shotgun'},
          {id:'car_sport', name:'„Çπ„Éù„Éº„ÉÑ„Ç´„Éº - 120,000ÂÜÜ', cost:120000, type:'vehicle'},
        ];
        for(const it of items){
          const div = document.createElement('div'); div.className='shop-item';
          div.innerHTML = `<div>${it.name}</div><div style="margin-top:8px;"><button class="act buyItem" data-id="${it.id}" data-cost="${it.cost}">Ë≥ºÂÖ•</button></div>`;
          shopContent.appendChild(div);
        }
        shopModal.style.display = 'block';
      });
      document.addEventListener('click', (e)=>{
        if(!e.target) return;
        if(e.target.classList && e.target.classList.contains('buyItem')){
          const id = e.target.dataset.id; const cost = Number(e.target.dataset.cost);
          if(money < cost){ alert('„ÅäÈáë„ÅåË∂≥„Çä„Åæ„Åõ„Çì'); return; }
          money -= cost; saveAll(); updateHUD();
          if(id==='slot'){ playSlotUI(5000); }
          else if(id==='smg' || id==='rifle' || id==='shotgun'){ WEAPONS[id].owned = true; showNotice('Ê≠¶Âô®„ÇíË≥ºÂÖ•„Åó„Åæ„Åó„Åü', 1200); }
          else if(id==='car_sport'){ const v = createVehicle(); v.position = player.position.add(new BABYLON.Vector3(2,0.5,0)); shadowGen.addShadowCaster(v); showNotice('ËªäË≥ºÂÖ• - „Ç¨„É¨„Éº„Ç∏„Å´ËøΩÂä†', 1600); }
        }
      });

      function playSlotUI(cost){
        const overlay = document.createElement('div'); overlay.style.cssText='position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:500; background:rgba(0,0,0,0.95); padding:10px; color:#fff; border-radius:12px;';
        overlay.innerHTML = `<h3>„Çπ„É≠„ÉÉ„Éà</h3><div id="slotReels" style="display:flex; gap:8px; justify-content:center; align-items:center; font-size:28px; margin:8px 0;"><div style="width:70px;height:70px;background:#06101a;border-radius:8px;display:flex;align-items:center;justify-content:center;">-</div><div style="width:70px;height:70px;background:#06101a;border-radius:8px;display:flex;align-items:center;justify-content:center;">-</div><div style="width:70px;height:70px;background:#06101a;border-radius:8px;display:flex;align-items:center;justify-content:center;">-</div></div><div style="margin-top:8px;"><button id="spinBtn" class="act">„Çπ„Éî„É≥</button> <button id="closeSlot" class="act">Èñâ„Åò„Çã</button></div>`;
        document.body.appendChild(overlay);
        const reels = overlay.querySelectorAll('#slotReels > div');
        overlay.querySelector('#spinBtn').addEventListener('click', ()=>{
          const symbols = ['üçí','7','üçã','‚≠ê','BAR'];
          let loops = 24;
          const iv = setInterval(()=>{ reels.forEach(r => r.innerText = symbols[Math.floor(Math.random()*symbols.length)]); loops--; if(loops<=0){ clearInterval(iv); const win = Math.random() < 0.28; if(win){ const prize = Math.floor(cost*3.6); money += prize; updateHUD(); saveAll(); showNotice('Â§ßÂΩì„Åü„Çä! +'+prize.toLocaleString()+'ÂÜÜ',2000); } else showNotice('„Éè„Ç∫„É¨',1200); } }, 80);
        });
        overlay.querySelector('#closeSlot').addEventListener('click', ()=> overlay.remove());
      }

      // ---------- pointer interactions: clicking safes and vehicles ----------
      opts.canvas.addEventListener('pointerdown', function(evt){
        const pick = scene.pick(scene.pointerX, scene.pointerY);
        if(pick && pick.pickedMesh){
          // check safes
          for(const b of BUILDINGS){
            if(pick.pickedMesh === b.safe && !b.opened){
              // start minigame flow
              launchSafeMinigame(b);
              return;
            }
          }
          // check enter vehicle
          if(pick.pickedMesh && (pick.pickedMesh.parent === vehicle || pick.pickedMesh === vehicle)){
            const d = BABYLON.Vector3.Distance(vehicle.position, player.position);
            if(!vehicleState.onCar && d < 3.0){
              vehicleState.onCar = true; playerState.onFoot = false;
              player.position = vehicle.position.add(new BABYLON.Vector3(0,0.8,0));
              scene.activeCamera = camFollow; camFollow.setTarget(vehicle.position);
              showNotice('Ëªä„Å´‰πó„Çä„Åæ„Åó„Åü', 1200);
            }
          }
        }
      });

      // ---------- safe minigame implementation (3 stages) ----------
      function launchSafeMinigame(building){
        // create overlay UI and run stages
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:500; background:rgba(0,0,0,0.95); padding:12px; border-radius:12px; color:#fff; width:min(640px,94%); text-align:center;';
        document.body.appendChild(overlay);

        // stage 1: dial
        let dial = 0;
        const target1 = Math.floor(Math.random()*100);
        overlay.innerHTML = `<h3>Step1: „ÉÄ„Ç§„É§„É´Âêà„Çè„Åõ</h3><p>ÂÜÜ„ÅÆÂë®„Çä„Çí„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶Áï™Âè∑„ÇíÂêà„Çè„Åõ„Çç</p><canvas id="dialC" width=520 height=120 style="background:#06101a;border-radius:8px;"></canvas><div style="margin-top:8px;"><button id="dialOk" class="act">Ê±∫ÂÆö</button></div>`;
        const dcan = document.getElementById('dialC'); const dctx = dcan.getContext('2d');
        let dragging=false;
        function drawDial(){ dctx.clearRect(0,0,520,120); dctx.fillStyle='#06101a'; dctx.fillRect(0,0,520,120); const cx=260, cy=66; dctx.beginPath(); dctx.arc(cx,cy,36,0,Math.PI*2); dctx.fillStyle='#1a2b34'; dctx.fill(); dctx.save(); dctx.translate(cx,cy); dctx.rotate((dial/100)*Math.PI*2); dctx.fillStyle='#cde'; dctx.fillRect(0,-6,46,12); dctx.restore(); dctx.fillStyle='#fff'; dctx.font='14px Arial'; dctx.fillText('ÁèæÂú®: ' + Math.floor(dial), 18, 22); }
        drawDial();
        dcan.addEventListener('pointerdown', ()=> dragging=true);
        window.addEventListener('pointerup', ()=> dragging=false);
        window.addEventListener('pointermove', (e)=>{ if(!dragging) return; const r = dcan.getBoundingClientRect(); const x = e.clientX - r.left - 260; const y = e.clientY - r.top - 66; dial = (Math.atan2(y,x)/(Math.PI*2) + 0.5)*100; if(dial<0) dial+=100; if(dial>=100) dial-=100; drawDial(); });

        overlay.querySelector('#dialOk').addEventListener('click', ()=>{
          const diff = Math.abs(normDial(dial - target1));
          if(diff < 6){
            showNotice('„Çπ„ÉÜ„ÉÉ„Éó1 ÊàêÂäü', 1000); stage2();
          } else {
            showNotice('Â§±Êïó: Ë≠¶Â†±Â¢óÂä†', 1400); alarmLevel += 12; updateHUD(); saveAll(); overlay.remove(); if(alarmLevel > 18) spawnPoliceGroup(1 + Math.floor(Math.random()*2));
          }
        });

        function stage2(){
          overlay.innerHTML = `<h3>Step2: „Çø„Ç§„Éü„É≥„Ç∞</h3><p>‰∏≠Â§Æ„ÅÆ„Éê„Éº„ÅåÁØÑÂõ≤„Å´ÂÖ•„Å£„Åü„Çâ„ÄåÊäº„Åô„Äç</p><canvas id="timC" width=520 height=120 style="background:#06101a;border-radius:8px;"></canvas><div style="margin-top:8px;"><button id="timBtn" class="act">Êäº„Åô</button></div>`;
          const tcan = document.getElementById('timC'); const tctx = tcan.getContext('2d');
          let t=0; const dur = 2.4; const winStart = 0.9 + Math.random()*0.6; const winEnd = winStart + 0.36;
          let anim = true;
          function drawT(){ if(!anim) return; t += 0.016; if(t > dur) t = 0; tctx.clearRect(0,0,520,120); tctx.fillStyle='#06101a'; tctx.fillRect(0,0,520,120); const sx=(winStart/dur)*520, ex=(winEnd/dur)*520; tctx.fillStyle='rgba(255,200,60,0.08)'; tctx.fillRect(sx,0,ex-sx,120); const cx=(t/dur)*520; tctx.fillStyle='#ffd166'; tctx.fillRect(cx-3,0,6,120); requestAnimationFrame(drawT); }
          drawT();
          document.getElementById('timBtn').addEventListener('click', ()=>{
            anim = false; const tt = (t % dur);
            if(tt >= winStart && tt <= winEnd){ showNotice('„Çπ„ÉÜ„ÉÉ„Éó2 ÊàêÂäü',900); stage3(); } else { showNotice('Â§±Êïó: Ë≠¶Â†±Â¢óÂä†',1400); alarmLevel += 16; updateHUD(); saveAll(); overlay.remove(); if(alarmLevel > 20) spawnPoliceGroup(1 + Math.floor(Math.random()*2)); }
          });
        }

        function stage3(){
          overlay.innerHTML = `<h3>Step3: „Ç∑„Éº„Ç±„É≥„Çπ</h3><p>Ë°®Á§∫„Åï„Çå„ÅüÁü¢Âç∞„ÇíÁ¥†Êó©„ÅèÊäº„Åõ</p><div id="seqBox" style="font-size:22px;margin:8px;"></div><div id="seqBtns" style="margin-top:8px;"></div>`;
          const arrows = ['‚Üê','‚Üí','‚Üë','‚Üì'];
          const len = 4 + Math.floor(Math.random()*3);
          const seq = []; for(let i=0;i<len;i++) seq.push(arrows[Math.floor(Math.random()*arrows.length)]);
          document.getElementById('seqBox').innerText = seq.join('  ');
          let idx=0;
          function onKey(k){ if(k === seq[idx]){ idx++; if(idx >= seq.length){ success(); } } else { fail(); } }
          function success(){ overlay.remove(); building.opened = true; const base = building.reward || Math.floor(randRange(8000,120000)); const bonus = Math.floor((30 - alarmLevel)*0.03*base); const reward = Math.max(1000, base + bonus); money += reward; saveAll(); updateHUD(); showNotice('Ëß£Èå†ÊàêÂäüÔºÅ +' + reward.toLocaleString() + 'ÂÜÜ', 2400); }
          function fail(){ overlay.remove(); showNotice('Â§±Êïó: Ë≠¶Â†±Â¢óÂä†',1400); alarmLevel += 22; updateHUD(); saveAll(); if(alarmLevel > 18) spawnPoliceGroup(1 + Math.floor(Math.random()*2)); }
          const keyMap = {'ArrowLeft':'‚Üê','ArrowRight':'‚Üí','ArrowUp':'‚Üë','ArrowDown':'‚Üì'};
          function keyHandler(e){ const m = keyMap[e.key] || e.key; onKey(m); }
          document.addEventListener('keydown', keyHandler);
          arrows.forEach(ch=>{ const b=document.createElement('button'); b.className='act'; b.style.margin='6px'; b.innerText=ch; b.addEventListener('click', ()=> onKey(ch)); document.getElementById('seqBtns').appendChild(b); });
          setTimeout(()=>{ if(idx < seq.length){ document.removeEventListener('keydown', keyHandler); fail(); } }, 1000*(len+5));
        }
      }

      function normDial(a){ a = Math.abs(a); if(a>50) a = 100 - a; return a; }

      // ---------- main loop ----------
      let last = performance.now();
      engine.runRenderLoop(function(){
        const now = performance.now(); const dt = Math.min(0.06, (now - last)/1000); last = now;

        // sample input object read from global DOM joystick/keyboard - Part1 handles setting input values on window if needed
        // For simplicity, use a small input read from DOM variables created in Part1's joystick handlers.
        // We'll fallback to minimal WASD/arrow handling:
        // movement on foot
        const throttle = (window.__VH_INPUT && window.__VH_INPUT.throttle) ? window.__VH_INPUT.throttle : 0;
        const steer = (window.__VH_INPUT && window.__VH_INPUT.steer) ? window.__VH_INPUT.steer : 0;
        const brake = (window.__VH_INPUT && window.__VH_INPUT.brake) ? window.__VH_INPUT.brake : false;
        const fire = (window.__VH_INPUT && window.__VH_INPUT.fire) ? window.__VH_INPUT.fire : false;
        const action = (window.__VH_INPUT && window.__VH_INPUT.action) ? window.__VH_INPUT.action : false;

        if(!vehicleState.onCar){
          const forward = getCameraForward(scene.activeCamera);
          const right = new BABYLON.Vector3(-forward.z,0,forward.x);
          const move = forward.scale(throttle * 2.8 * dt).add(right.scale(steer * 2.2 * dt));
          player.position.addInPlace(move);
          camFP.position = player.position.add(new BABYLON.Vector3(0,1.2,-2.2));
          camFP.setTarget(player.position.add(new BABYLON.Vector3(0,1.2,0)));
          scene.activeCamera = camFP;
        } else {
          updateVehicle(dt, {throttle, steer, brake});
          player.position.copyFrom(vehicle.position.add(new BABYLON.Vector3(0,0.6,0)));
          camFollow.alpha = -vehicle.rotation.y + Math.PI; camFollow.radius = 6; camFollow.target = vehicle.position;
          scene.activeCamera = camFollow;
        }

        // fire (consumes a single toggle read)
        if(fire){
          // window.__VH_INPUT.fire should be cleared by Part1 handlers (they used event listeners)
          spawnPlayerBullet();
          if(window.__VH_INPUT) window.__VH_INPUT.fire = false;
        }

        // bullets & police updates
        updateBullets(dt);
        updatePoliceAI(dt);

        // periodic save/hud
        if(Date.now()%1500 < 50) { saveAll(); updateHUD(); }

        scene.render();
      });

      // ---------- small helpers ----------
      function getCameraForward(cam){
        if(!cam) return new BABYLON.Vector3(0,0,1);
        const f = cam.getForwardRay().direction;
        const v = new BABYLON.Vector3(f.x, 0, f.z);
        if(isNaN(v.x) || isNaN(v.z)) return new BABYLON.Vector3(0,0,1);
        return v.normalize();
      }

      // expose some globals for debugging
      window.VH = { scene, engine, createVehicle, spawnPoliceGroup, BUILDINGS };

      // mark assets loaded (we registered 1 earlier)
      markAssetLoaded(true);

      // finish init
      resolveInit();
    }catch(e){
      console.error('initGame internal error:', e);
      rejectInit(e);
    }
  });
} // initGame end
</script>
<!-- Part2 END -->
