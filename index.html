<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Vault Heist — Single File 3D Heist Game</title>

<!-- External libraries via CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

<style>
  /* --- Reset & base --- */
  html,body { height:100%; margin:0; padding:0; font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; background:#0f0f12; color:#eaeaea; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
  #gameWrap { position:fixed; inset:0; display:flex; flex-direction:column; }
  header { height:56px; background:linear-gradient(90deg,#111,#222); display:flex; align-items:center; padding:6px 12px; box-shadow:0 2px 8px rgba(0,0,0,0.6); z-index:50; }
  header h1 { margin:0; font-size:18px; letter-spacing:0.6px; font-weight:700; }
  header .hud { margin-left:auto; display:flex; gap:8px; align-items:center; }
  .btn { background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.04); padding:6px 10px; border-radius:8px; color:inherit; cursor:pointer; }
  .btn:hover { background:rgba(255,255,255,0.09); }

  /* --- Canvas area (3D) --- */
  #sceneContainer { flex:1; position:relative; overflow:hidden; display:flex; }
  canvas#main3d { width:100%; height:100%; display:block; background:linear-gradient(#7aa,#0b1530); }

  /* --- UI overlay --- */
  .overlay {
    position:absolute; right:12px; top:72px; width:260px; max-width:40vw; z-index:60;
    background:linear-gradient(180deg, rgba(12,14,20,0.8), rgba(10,10,12,0.6));
    border-radius:12px; padding:12px; box-shadow:0 8px 30px rgba(0,0,0,0.6);
    backdrop-filter: blur(4px); border:1px solid rgba(255,255,255,0.03);
  }
  .overlay h2 { margin:0 0 8px 0; font-size:14px; }
  .statRow { display:flex; justify-content:space-between; margin:6px 0; font-size:13px; }

  /* --- Minimap --- */
  #minimap {
    position:absolute; left:12px; top:72px; width:180px; height:180px; z-index:60;
    background:rgba(0,0,0,0.5); border-radius:8px; padding:6px; box-sizing:border-box;
    border:1px solid rgba(255,255,255,0.03);
  }
  #minimap canvas { width:100%; height:100%; display:block; border-radius:6px; }

  /* --- Bottom Controls (joystick / actions) --- */
  #controls {
    position:absolute; left:12px; bottom:12px; z-index:70; display:flex; gap:12px; align-items:flex-end;
  }
  .joystick {
    width:140px; height:140px; background:rgba(0,0,0,0.35); border-radius:50%; display:flex; align-items:center; justify-content:center;
    touch-action:none; position:relative; border:1px solid rgba(255,255,255,0.03);
  }
  .joystick .stick { width:64px; height:64px; background:rgba(255,255,255,0.08); border-radius:50%; transform:translate(0,0); transition:background 0.12s; display:flex; align-items:center; justify-content:center; }
  .actionButtons { display:flex; flex-direction:column; gap:8px; }
  .actionButtons button { width:72px; height:44px; border-radius:8px; font-weight:700; }

  /* --- Modal (vault) --- */
  .modal {
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%) scale(0.98); z-index:200;
    background: linear-gradient(180deg,#0b0b0d,#121218); color:#eaeaea; padding:18px; border-radius:14px;
    border:1px solid rgba(255,255,255,0.04); box-shadow:0 14px 60px rgba(0,0,0,0.6); width:92%; max-width:520px; display:none;
  }
  .modal.open { display:block; animation:pop 220ms ease; transform:translate(-50%,-50%) scale(1); }
  @keyframes pop { from { transform:translate(-50%,-50%) scale(0.96); opacity:0; } to { transform:translate(-50%,-50%) scale(1); opacity:1; } }
  .modal h3 { margin:0 0 10px 0; }
  .dialRow { display:flex; gap:8px; justify-content:center; margin-top:12px; }
  .dial { width:56px; height:56px; border-radius:8px; background:rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; font-size:18px; font-weight:700; border:1px solid rgba(255,255,255,0.02); }
  .dial.correct { box-shadow:0 6px 18px rgba(0,255,150,0.06); background:linear-gradient(90deg,#072,#092); color:#fff; transform:scale(1.08); }

  /* --- Complexity / theme presets --- */
  #presetBar { display:flex; gap:8px; }
  .preset { padding:6px 10px; border-radius:8px; cursor:pointer; border:1px solid rgba(255,255,255,0.03); background:rgba(255,255,255,0.02); }
  .preset.active { background:linear-gradient(90deg,#ffcc00,#ff8a00); color:#111; font-weight:800; }

  /* --- Notifications --- */
  #notifs { position:absolute; right:12px; bottom:12px; z-index:150; display:flex; flex-direction:column; gap:8px; width:320px; max-width:60vw; }
  .toast { background:rgba(14,14,20,0.85); padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); color:#eaeaea; font-size:13px; }

  /* --- Responsive tweaks --- */
  @media (max-width:640px) {
    header h1 { font-size:16px; }
    .overlay { width:200px; top:64px; left:auto; right:10px; }
    #minimap { left:10px; top:64px; width:140px; height:140px; }
    .joystick { width:120px; height:120px; }
    .joystick .stick { width:56px; height:56px; }
  }

  /* --- Flavor: labels on building markers for minimap --- */
  .legend { display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; font-size:12px; }
  .legend .item { padding:6px; border-radius:6px; background:rgba(255,255,255,0.03); display:flex; gap:6px; align-items:center; }
  .legend .sw { width:12px; height:12px; border-radius:3px; display:inline-block; }

</style>
</head>
<body>
<div id="gameWrap">
  <header>
    <h1>Vault Heist — 金庫破り</h1>
    <div class="hud">
      <div id="presetBar">
        <div class="preset" data-preset="trash">普通にゴミ</div>
        <div class="preset active" data-preset="normal">普通</div>
        <div class="preset" data-preset="god">普通に神</div>
      </div>
      <button class="btn" id="spawnBtn">新しいマップ</button>
      <button class="btn" id="saveBtn">保存</button>
    </div>
  </header>

  <div id="sceneContainer">
    <canvas id="main3d"></canvas>

    <div id="minimap">
      <canvas id="miniCanvas" width="300" height="300"></canvas>
      <div style="margin-top:6px; font-size:12px;">ミニマップ</div>
      <div class="legend">
        <div class="item"><span class="sw" style="background:#2ecc71"></span> 金庫（銀行）</div>
        <div class="item"><span class="sw" style="background:#3498db"></span> コンビニ（小金庫）</div>
        <div class="item"><span class="sw" style="background:#e67e22"></span> パチンコ</div>
        <div class="item"><span class="sw" style="background:#9b59b6"></span> 店（車/スロ/闇）</div>
        <div class="item"><span class="sw" style="background:#95a5a6"></span> ダミービル</div>
      </div>
    </div>

    <div class="overlay" id="overlayInfo">
      <h2>Player</h2>
      <div class="statRow"><span>お金</span><span id="money">¥0</span></div>
      <div class="statRow"><span>所持銃</span><span id="guns">拳銃:0</span></div>
      <div class="statRow"><span>車</span><span id="cars">0</span></div>
      <div class="statRow"><span>警戒度</span><span id="heat">0</span></div>
      <hr style="border:none;height:1px;background:rgba(255,255,255,0.03);margin:8px 0;">
      <h2>Map Info</h2>
      <div class="statRow"><span>サイズ</span><span>600×600</span></div>
      <div class="statRow"><span>金庫数</span><span id="vaultCount">0</span></div>
      <div style="margin-top:8px;">
        <small>金庫はコンビニ(低)・パチンコ(中)・銀行(高)。金庫で手間取ると警察が来ます。</small>
      </div>
    </div>

    <div id="controls">
      <div class="joystick" id="joy">
        <div class="stick" id="stick"></div>
      </div>
      <div class="actionButtons">
        <button id="interactBtn" class="btn">行動</button>
        <button id="fireBtn" class="btn">発砲</button>
        <button id="vaultBtn" class="btn">金庫</button>
      </div>
    </div>

    <div id="notifs"></div>

    <div class="modal" id="vaultModal" aria-hidden="true">
      <h3>金庫ダイヤルを回せ</h3>
      <div>4桁ダイヤルを合わせろ。正しい数字が1桁でも合うたびに小さな演出が起きる。</div>
      <div class="dialRow" id="dialRow">
        <!-- dials go here -->
      </div>
      <div style="text-align:center; margin-top:12px;">
        <button class="btn" id="attemptOpen">解除を試す</button>
        <button class="btn" id="closeVault">閉じる</button>
      </div>
    </div>

  </div>

  <footer style="height:48px; background:linear-gradient(90deg,#0b0b0d,#0b0b10); display:flex; align-items:center; justify-content:center; color:#9ea2a6;">
    <small>スマホ向けコントロール装備。GitHub Pages に置いてそのまま公開可。</small>
  </footer>
</div>

<script>
/*
  Vault Heist — Single File Game
  - 3D map with three.js (simple, blocky)
  - Minimap canvas for overview
  - Joystick for mobile, WASD for desktop
  - Vault dial mini-game
  - Police spawning and combat
  - Theme presets ("普通にゴミ", "普通", "普通に神")
  - Uses localStorage for save
*/

/* -------------------------
   Helper utilities
   ------------------------- */
const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
const rand = (min,max) => Math.floor(Math.random()*(max-min+1))+min;
const pick = arr => arr[Math.floor(Math.random()*arr.length)];
const fmtMoney = n => '¥' + Math.floor(n).toLocaleString('ja-JP');

/* -------------------------
   Audio (Howler)
   ------------------------- */
const sfx = {
  beep: new Howl({ src: ['https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg'], volume:0.3 }),
  dialTick: new Howl({ src: ['https://actions.google.com/sounds/v1/alarms/beep_short.ogg'], volume:0.18 }),
  gunshot: new Howl({ src: ['https://actions.google.com/sounds/v1/weapons/medium_gunshot.ogg'], volume:0.5 }),
  policeSiren: new Howl({ src: ['https://actions.google.com/sounds/v1/alarms/police_siren.ogg'], loop:true, volume:0.2 }),
  success: new Howl({ src: ['https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg'], volume:0.35 })
};

/* -------------------------
   Game state
   ------------------------- */
let state = {
  preset: 'normal', // trash | normal | god
  mapSize: 600,
  player: {
    x: 300, z: 300, y: 0, angle:0,
    money: 15000,
    guns: { pistol:1 },
    cars: 0,
    speed: 1.6,
    hp: 100
  },
  buildings: [],
  vaults: [], // references to building indices that are vault-bearing
  police: [],
  timeSinceLastVault: 0,
  heat: 0,
  running: true,
  lastSave: null
};

/* -------------------------
   Theme presets
   ------------------------- */
const PRESETS = {
  trash: { enemyAggro:1.2, vaultEase:0.6, moneyMultiplier:0.7, visuals: 'low' },
  normal: { enemyAggro:1.0, vaultEase:1.0, moneyMultiplier:1.0, visuals: 'mid' },
  god:   { enemyAggro:0.8, vaultEase:1.3, moneyMultiplier:1.4, visuals: 'hi' }
};

/* -------------------------
   Map generation
   ------------------------- */
function generateMap(seedOverride) {
  state.buildings = [];
  state.vaults = [];
  const size = state.mapSize;
  // grid partition to place buildings reasonably
  const cell = 60; // grid cell
  const cols = Math.floor(size / cell);
  const rows = Math.floor(size / cell);
  // places for special shops
  const specialTypes = ['carshop','slots','blackmarket'];
  // ensure at least one bank, several conv, pachinko
  let bankPlaced = false;
  for (let r=0;r<rows;r++){
    for (let c=0;c<cols;c++){
      const cx = c*cell + rand(8, cell-8);
      const cz = r*cell + rand(8, cell-8);
      let kind = 'dummy'; // default visual filler
      let sizeX = rand(18,36), sizeZ = rand(18,36);
      // random decide special
      const roll = Math.random();
      if (!bankPlaced && roll < 0.02) { kind='bank'; bankPlaced=true; sizeX=48; sizeZ=48; }
      else if (roll < 0.06) kind = 'conbini';
      else if (roll < 0.10) kind = 'pachinko';
      else if (roll < 0.115 && specialTypes.length) kind = specialTypes.shift();
      else if (roll < 0.3) kind = 'dummy';
      else kind = 'dummy';
      // push building
      state.buildings.push({ kind, x:cx, z:cz, sx:sizeX, sz:sizeZ, rot: 0 });
      // vault-bearing places
      if (kind === 'bank' || kind === 'conbini' || kind === 'pachinko') {
        state.vaults.push({ buildingIndex: state.buildings.length-1, locked:true, attempts:0,
          dialSolution: [rand(0,9),rand(0,9),rand(0,9),rand(0,9)], // 4-digit
          progress: [false,false,false,false]
        });
      }
    }
  }
  // ensure at least one bank exists
  if (!bankPlaced) {
    const cx = rand(80,size-80), cz = rand(80,size-80);
    state.buildings.push({ kind:'bank', x:cx, z:cz, sx:56, sz:56, rot:0 });
    state.vaults.push({ buildingIndex: state.buildings.length-1, locked:true, attempts:0,
      dialSolution: [rand(0,9),rand(0,9),rand(0,9),rand(0,9)],
      progress: [false,false,false,false]
    });
  }
  // adjust money values and maintain vault count
  state.vaults.forEach(v=>{
    const b = state.buildings[v.buildingIndex];
    if (b.kind === 'bank') v.reward = 50000 * PRESETS[state.preset].moneyMultiplier;
    else if (b.kind === 'pachinko') v.reward = 14000 * PRESETS[state.preset].moneyMultiplier;
    else if (b.kind === 'conbini') v.reward = 4200 * PRESETS[state.preset].moneyMultiplier;
  });
  // scatter more decorative dummy buildings to make map feel full
  for (let i=0;i<40;i++){
    state.buildings.push({ kind:'dummy', x: rand(10,size-10), z: rand(10,size-10), sx: rand(8,24), sz: rand(8,24), rot:0 });
  }
  // shuffle a bit
  state.vaultCount = state.vaults.length;
  state.timeSinceLastVault = 0;
  notify(`${state.vaults.length} 個の金庫がマップに生成されました。`);
  saveStateToLocal(false);
}

/* -------------------------
   Save/load
   ------------------------- */
function saveStateToLocal(show=true) {
  try {
    const toSave = {
      preset: state.preset,
      player: state.player,
      mapSize: state.mapSize,
      buildings: state.buildings,
      vaults: state.vaults,
      lastSave: Date.now()
    };
    localStorage.setItem('vault_heist_save', JSON.stringify(toSave));
    if (show) notify('ゲームを保存しました。');
  } catch(e){ console.warn('save failed', e); }
}
function loadStateFromLocal() {
  try {
    const raw = localStorage.getItem('vault_heist_save');
    if (!raw) return false;
    const parsed = JSON.parse(raw);
    state.preset = parsed.preset || state.preset;
    state.player = parsed.player || state.player;
    state.mapSize = parsed.mapSize || state.mapSize;
    state.buildings = parsed.buildings || state.buildings;
    state.vaults = parsed.vaults || state.vaults;
    state.lastSave = parsed.lastSave || null;
    notify('保存データを読み込みました。');
    return true;
  } catch(e){ return false; }
}

/* -------------------------
   Notifications
   ------------------------- */
const notifWrap = document.getElementById('notifs');
function notify(msg, ttl=3500) {
  const el = document.createElement('div'); el.className='toast'; el.textContent = msg;
  notifWrap.prepend(el);
  setTimeout(()=> {
    el.style.opacity = '0';
    el.style.transition = 'opacity 300ms';
    setTimeout(()=> el.remove(), 320);
  }, ttl);
}

/* -------------------------
   Three.js scene setup
   ------------------------- */
let renderer, scene, camera, playerMesh, clock, controls;
function initThree() {
  const canvas = document.getElementById('main3d');
  renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 2, 2));
  renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x061220, 0.0012);

  camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 2000);
  camera.position.set(state.player.x - 50, 120, state.player.z + 100);
  camera.lookAt(state.player.x, 0, state.player.z);

  // ground
  const gmat = new THREE.MeshStandardMaterial({ color:0x23364f, roughness:1, metalness:0.0 });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(state.mapSize, state.mapSize, 8,8), gmat);
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true;
  scene.add(ground);

  // ambient & directional
  const amb = new THREE.AmbientLight(0x999999, 0.75);
  scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(100,300,200);
  scene.add(dir);

  // simple skybox-ish
  scene.background = new THREE.Color(0x0b1530);

  // player mesh
  const pgeo = new THREE.CylinderGeometry(6,6,18,8);
  const pmat = new THREE.MeshStandardMaterial({ color:0xffc857 });
  playerMesh = new THREE.Mesh(pgeo, pmat);
  playerMesh.position.set(state.player.x, 9, state.player.z);
  scene.add(playerMesh);

  // build world visuals
  buildWorldVisuals();

  // orbit controls for debug (disabled by default on mobile)
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enabled = false;

  clock = new THREE.Clock();
  window.addEventListener('resize', onResize);
}
function onResize() {
  const canvas = document.getElementById('main3d');
  const w = canvas.clientWidth, h = canvas.clientHeight;
  renderer.setSize(w,h,false);
  camera.aspect = w/h; camera.updateProjectionMatrix();
}

/* -------------------------
   Build building visuals
   ------------------------- */
let buildingGroup;
function buildWorldVisuals() {
  if (buildingGroup) { scene.remove(buildingGroup); buildingGroup.traverse(o=>{ if (o.geometry) o.geometry.dispose(); if (o.material) o.material.dispose(); }); }
  buildingGroup = new THREE.Group();
  state.buildings.forEach((b,i)=>{
    const color = kindToColor(b.kind);
    const geo = new THREE.BoxGeometry(b.sx, rand(24,80), b.sz);
    const mat = new THREE.MeshStandardMaterial({ color, roughness:1, metalness:0.05 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(b.x - state.mapSize/2, geo.parameters.height/2, b.z - state.mapSize/2);
    mesh.userData = { idx:i, kind:b.kind };
    buildingGroup.add(mesh);
    // small label as plane
    const lbl = makeLabelMesh(b.kind);
    lbl.position.set(b.x - state.mapSize/2, geo.parameters.height + 6, b.z - state.mapSize/2);
    buildingGroup.add(lbl);
  });
  scene.add(buildingGroup);
}

function kindToColor(kind) {
  switch(kind) {
    case 'bank': return 0x2ecc71;
    case 'conbini': return 0x3498db;
    case 'pachinko': return 0xe67e22;
    case 'carshop': return 0x9b59b6;
    case 'slots': return 0xf1c40f;
    case 'blackmarket': return 0xe84393;
    default: return 0x95a5a6;
  }
}
function makeLabelMesh(text) {
  const canvas = document.createElement('canvas');
  canvas.width = 256; canvas.height = 64;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(0,0,256,64);
  ctx.fillStyle = '#fff'; ctx.font = '18px sans-serif'; ctx.textAlign='center';
  ctx.fillText(text, 128, 38);
  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({ map:tex, transparent:true });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(40,10,1);
  return sprite;
}

/* -------------------------
   Minimap render
   ------------------------- */
const miniCanvas = document.getElementById('miniCanvas');
const mctx = miniCanvas.getContext('2d');
function drawMinimap() {
  const W = miniCanvas.width, H = miniCanvas.height;
  mctx.clearRect(0,0,W,H);
  // background
  mctx.fillStyle = '#031021'; mctx.fillRect(0,0,W,H);
  // scale
  const s = W / state.mapSize;
  // draw buildings
  state.buildings.forEach((b,i)=>{
    const x = b.x * s, y = b.z * s;
    const w = clamp(b.sx * s, 3, 18), h = clamp(b.sz * s, 3, 18);
    let col = '#95a5a6';
    if (b.kind === 'bank') col = '#2ecc71';
    if (b.kind === 'conbini') col = '#3498db';
    if (b.kind === 'pachinko') col = '#e67e22';
    if (b.kind === 'carshop' || b.kind==='slots' || b.kind==='blackmarket') col = '#9b59b6';
    mctx.fillStyle = col;
    mctx.fillRect(x - w/2, y - h/2, w, h);
  });
  // draw player
  const px = state.player.x * s, pz = state.player.z * s;
  mctx.fillStyle = '#ffde59';
  mctx.beginPath(); mctx.arc(px, pz, 6, 0, Math.PI*2); mctx.fill();
}

/* -------------------------
   Input: joystick & keyboard
   ------------------------- */
let input = { x:0, y:0, fire:false, interact:false, openVault:false };
const joy = document.getElementById('joy');
const stick = document.getElementById('stick');
let dragging = false;
let center = null;

function setupJoystick() {
  const rect = joy.getBoundingClientRect();
  center = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
  const start = (e) => {
    e.preventDefault();
    dragging = true;
    joy.classList.add('active');
    document.addEventListener('touchmove', move);
    document.addEventListener('touchend', end);
    document.addEventListener('mousemove', move);
    document.addEventListener('mouseup', end);
  };
  const move = (e) => {
    if (!dragging) return;
    let clientX = e.touches ? e.touches[0].clientX : e.clientX;
    let clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const dx = clientX - center.x, dy = clientY - center.y;
    const max = 46;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const nx = clamp(dx / max, -1, 1);
    const ny = clamp(dy / max, -1, 1);
    input.x = nx;
    input.y = ny;
    const sx = clamp(dx, -max, max), sy = clamp(dy, -max, max);
    stick.style.transform = `translate(${sx}px, ${sy}px)`;
  };
  const end = (e) => {
    dragging = false;
    input.x = 0; input.y = 0;
    stick.style.transform = 'translate(0,0)';
    document.removeEventListener('touchmove', move);
    document.removeEventListener('touchend', end);
    document.removeEventListener('mousemove', move);
    document.removeEventListener('mouseup', end);
  };
  joy.addEventListener('touchstart', start);
  joy.addEventListener('mousedown', start);

  // keyboard
  window.addEventListener('keydown', (e)=>{
    if (e.key === 'w' || e.key === 'ArrowUp') input.y = -1;
    if (e.key === 's' || e.key === 'ArrowDown') input.y = 1;
    if (e.key === 'a' || e.key === 'ArrowLeft') input.x = -1;
    if (e.key === 'd' || e.key === 'ArrowRight') input.x = 1;
    if (e.code === 'Space') input.fire = true;
    if (e.key === 'e') input.interact = true;
    if (e.key === 'v') input.openVault = true;
  });
  window.addEventListener('keyup', (e)=>{
    if (['w','s','ArrowUp','ArrowDown'].includes(e.key)) input.y = 0;
    if (['a','d','ArrowLeft','ArrowRight'].includes(e.key)) input.x = 0;
    if (e.code === 'Space') input.fire = false;
    if (e.key === 'e') input.interact = false;
    if (e.key === 'v') input.openVault = false;
  });
}

/* -------------------------
   Interactions: actions, firing, vault
   ------------------------- */
document.getElementById('fireBtn').addEventListener('click', ()=> { input.fire = true; setTimeout(()=> input.fire=false,100); });
document.getElementById('interactBtn').addEventListener('click', ()=> { input.interact = true; setTimeout(()=> input.interact=false,120); });
document.getElementById('vaultBtn').addEventListener('click', ()=> { openVaultIfNearby(); });

function openVaultIfNearby() {
  // find closest vault within range
  const range = 40;
  let found = null;
  for (const v of state.vaults) {
    const b = state.buildings[v.buildingIndex];
    const dx = state.player.x - b.x;
    const dz = state.player.z - b.z;
    const d = Math.sqrt(dx*dx + dz*dz);
    if (d < range && v.locked) { found = v; break; }
  }
  if (!found) { notify('近くに閉ざされた金庫はない。'); return; }
  openVaultModal(found);
}

/* -------------------------
   Vault modal and dial game
   ------------------------- */
const vaultModal = document.getElementById('vaultModal');
let currentVault = null;
function openVaultModal(vaultObj) {
  currentVault = vaultObj;
  const row = document.getElementById('dialRow');
  row.innerHTML = '';
  // render 4 dials
  for (let i=0;i<4;i++){
    const d = document.createElement('div');
    d.className = 'dial';
    d.dataset.idx = i;
    d.textContent = '0';
    d.addEventListener('click', ()=>{
      const val = (parseInt(d.textContent)+1) % 10;
      d.textContent = val;
      // mark progress highlight if matches solution for that index
      const sol = vaultObj.dialSolution[i];
      if (val === sol) {
        d.classList.add('correct');
        sfx.dialTick.play();
      } else {
        d.classList.remove('correct');
      }
    });
    row.appendChild(d);
  }
  vaultModal.classList.add('open');
  vaultModal.setAttribute('aria-hidden','false');
}
document.getElementById('closeVault').addEventListener('click', ()=> {
  vaultModal.classList.remove('open'); vaultModal.setAttribute('aria-hidden','true'); currentVault=null;
});
document.getElementById('attemptOpen').addEventListener('click', ()=> {
  if (!currentVault) return;
  const inputs = Array.from(document.querySelectorAll('.dial')).map(d=>parseInt(d.textContent));
  // evaluate matches
  let correctCount = 0;
  for (let i=0;i<4;i++){
    if (inputs[i] === currentVault.dialSolution[i]) {
      correctCount++;
      currentVault.progress[i] = true;
    } else {
      currentVault.progress[i] = false;
    }
  }
  currentVault.attempts++;
  if (correctCount === 4) {
    // success
    currentVault.locked = false;
    state.player.money += currentVault.reward;
    sfx.success.play();
    notify(`金庫解除成功！ ${fmtMoney(currentVault.reward)} を手に入れた。`);
    vaultModal.classList.remove('open'); vaultModal.setAttribute('aria-hidden','true'); currentVault=null;
    // small explosion animation at building
    smallBurstAtBuilding(currentVault && state.buildings[currentVault.buildingIndex]);
  } else {
    // partial success small effect
    sfx.beep.play();
    notify(`${correctCount} 桁一致。金庫ダイヤルが反応した。`);
    // escalate police heat based on difficulty
    state.heat += (4 - correctCount) * (1 + PRESETS[state.preset].enemyAggro * 0.25);
    // if too many attempts, police summoned faster
    if (currentVault.attempts >= 5) {
      spawnPoliceNearPlayer();
    }
  }
});

/* little burst effect placeholder (visual only) */
function smallBurstAtBuilding(building) {
  if (!building) return;
  // create a temporary sprite or GSAP flash
  notify('小さな演出: ダイヤルが正しくはまった！');
}

/* -------------------------
   Police logic & combat
   ------------------------- */
function spawnPoliceNearPlayer() {
  // spawn police at map edge near player
  const angle = Math.random()*Math.PI*2;
  const dist = 220;
  const px = state.player.x + Math.cos(angle)*dist;
  const pz = state.player.z + Math.sin(angle)*dist;
  const p = { x:px, z:pz, hp:100, speed: 1.2 * PRESETS[state.preset].enemyAggro, target:'player', id:Date.now()+Math.random() };
  state.police.push(p);
  notify('警察が到着しました！発見されると射撃戦になります。');
  sfx.policeSiren.play();
}

/* minimal combat simulation */
function policeAI(dt) {
  const toRemove = [];
  state.police.forEach((pol, idx) => {
    // movement towards player
    const dx = state.player.x - pol.x;
    const dz = state.player.z - pol.z;
    const d = Math.sqrt(dx*dx + dz*dz);
    if (d > 2) {
      const nx = dx/d, nz = dz/d;
      pol.x += nx * pol.speed;
      pol.z += nz * pol.speed;
    }
    // fire at player when close
    if (d < 160 && Math.random() < 0.006 * dt * PRESETS[state.preset].enemyAggro) {
      // police shoots
      sfx.gunshot.play();
      // cause player damage if not far
      if (d < 90) {
        state.player.hp -= Math.floor(5 + Math.random()*18);
        notify('被弾した！HP -' + (5 + Math.floor(Math.random()*18)));
      }
    }
    // if police dies, mark removal
    if (pol.hp <= 0) toRemove.push(idx);
  });
  // remove dead police
  for (let i=toRemove.length-1;i>=0;i--) state.police.splice(toRemove[i],1);
  if (state.police.length===0) { sfx.policeSiren.stop(); }
}

/* -------------------------
   Player shooting
   ------------------------- */
function playerFire() {
  if (!state.player.guns || state.player.guns.pistol <= 0) { notify('銃がない！'); return; }
  sfx.gunshot.play();
  // simple hit chance: shoot nearest police within 140 units
  let nearest = null, nd = 99999;
  for (const p of state.police) {
    const d = Math.hypot(p.x - state.player.x, p.z - state.player.z);
    if (d < nd) { nd = d; nearest = p; }
  }
  if (nearest && nd < 160) {
    // chance to hit based on distance
    const hitProb = clamp(1 - nd/220, 0.12, 0.95);
    if (Math.random() < hitProb) {
      const dmg = rand(18,36);
      nearest.hp -= dmg;
      notify(`命中！警官に ${dmg} のダメージ。`);
      if (nearest.hp <= 0) {
        notify('警官を倒した。');
        // small reward maybe drops cash
        const loot = rand(300,1200);
        state.player.money += loot;
        notify(`警官の所持金 ${fmtMoney(loot)} を獲得。`);
      }
    } else {
      notify('外した...');
    }
  } else {
    notify('ターゲットがいない。');
  }
}

/* -------------------------
   Game tick & update
   ------------------------- */
let lastTime = performance.now();
function gameLoop(now) {
  const dt = (now - lastTime) / 16.66667; // approx frames
  lastTime = now;

  // movement
  const moveSpeed = state.player.speed * (1 + (state.player.cars ? 0.3 : 0)) * (dt*0.9);
  // normalize input vector
  let mag = Math.hypot(input.x, input.y);
  if (mag > 1) { input.x /= mag; input.y /= mag; mag = 1; }
  state.player.x += input.x * moveSpeed * 1.8;
  state.player.z += input.y * moveSpeed * 1.8;
  state.player.x = clamp(state.player.x, 0, state.mapSize);
  state.player.z = clamp(state.player.z, 0, state.mapSize);

  // update mesh positions
  playerMesh.position.set(state.player.x - state.mapSize/2, playerMesh.position.y, state.player.z - state.mapSize/2);

  // camera follow (3rd person)
  camera.position.lerp(new THREE.Vector3(state.player.x - 50, 120, state.player.z + 100 - Math.min(40, state.heat)), 0.08);
  camera.lookAt(new THREE.Vector3(state.player.x - state.mapSize/2, 0, state.player.z - state.mapSize/2));

  // police update
  policeAI(dt);

  // handle firing input
  if (input.fire) {
    input.fire = false;
    playerFire();
    state.heat += 2;
  }

  // update UI
  document.getElementById('money').textContent = fmtMoney(state.player.money);
  document.getElementById('guns').textContent = `拳銃:${state.player.guns.pistol || 0}`;
  document.getElementById('cars').textContent = `${state.player.cars}`;
  document.getElementById('heat').textContent = `${Math.round(state.heat)}`;

  // police spawn if heat high and interval reached
  if (state.heat > 20 && state.police.length < 6 && Math.random() < 0.01) spawnPoliceNearPlayer();
  // heat decays gradually
  state.heat = Math.max(0, state.heat - 0.02*dt);

  // draw minimap
  drawMinimap();

  // render three.js
  renderer.render(scene, camera);

  requestAnimationFrame(gameLoop);
}

/* -------------------------
   UI & event wiring
   ------------------------- */
document.getElementById('spawnBtn').addEventListener('click', ()=> {
  generateMap();
  buildWorldVisuals();
  notify('新しいマップを生成しました。');
});
document.getElementById('saveBtn').addEventListener('click', ()=> saveStateToLocal(true));
document.querySelectorAll('.preset').forEach(el=>{
  el.addEventListener('click', ()=> {
    document.querySelectorAll('.preset').forEach(p=>p.classList.remove('active'));
    el.classList.add('active');
    state.preset = el.dataset.preset;
    notify(`プリセット ${el.textContent} に設定しました。`);
    // regenerate map with new preset
    generateMap();
    buildWorldVisuals();
  });
});

// load saved game if exists
loadStateFromLocal();

// initial map gen if none
if (!state.buildings || state.buildings.length === 0) generateMap();
initThree();
setupJoystick();
requestAnimationFrame(gameLoop);

/* -------------------------
   Additional shop interactions (simplified)
   ------------------------- */
function tryInteractNearby() {
  // find nearest building within interaction range
  const range = 28;
  let nearest = null, nd = 99999;
  let bIndex = -1;
  state.buildings.forEach((b,i)=>{
    const d = Math.hypot(b.x - state.player.x, b.z - state.player.z);
    if (d < nd) { nd = d; nearest = b; bIndex = i; }
  });
  if (nearest && nd <= range) {
    // describe interactions based on kind
    switch(nearest.kind) {
      case 'conbini':
        notify('コンビニを探索。金庫を見つけたら行動ボタンでダイヤルを操作。');
        break;
      case 'pachinko':
        // mini-slot purchase: quick slot gamble
        if (state.player.money >= 200) {
          state.player.money -= 200;
          const result = Math.random();
          if (result < 0.08) {
            const win = 5000 * PRESETS[state.preset].moneyMultiplier;
            state.player.money += win;
            notify(`パチンコ大当たり！ ${fmtMoney(win)} を獲得。`);
          } else if (result < 0.32) {
            const win = 800;
            state.player.money += win;
            notify(`小当たり ${fmtMoney(win)} 。`);
          } else {
            notify('外れた...');
          }
        } else {
          notify('所持金不足: パチンコは200円が必要。');
        }
        break;
      case 'bank':
        notify('銀行の前。大きな金庫がある… 金庫ボタンでダイヤルを試そう。');
        break;
      case 'carshop':
        if (state.player.money >= 12000) {
          state.player.money -= 12000;
          state.player.cars++;
          notify('車を購入した。移動速度が少し上昇する。');
          state.player.speed += 0.15;
        } else notify('車屋: 購入金不足 (¥12,000)');
        break;
      case 'slots':
        // stress-free slot shop
        if (state.player.money >= 300) {
          state.player.money -= 300;
          const r = Math.random();
          if (r < 0.05) { const w=15000; state.player.money+=w; notify(`スロット大勝ち！ ${fmtMoney(w)} を獲得`); }
          else if (r < 0.4) { const w=1200; state.player.money+=w; notify(`スロット当たった: ${fmtMoney(w)}`); }
          else notify('スロット外れ');
        } else notify('スロットに入れるお金が足りません(¥300)');
        break;
      case 'blackmarket':
        // buy gun
        if (state.player.money >= 4500) {
          state.player.money -= 4500;
          state.player.guns.pistol = (state.player.guns.pistol||0) + 1;
          notify('闇銃屋で拳銃を購入した。');
        } else notify('闇銃屋: 金が足りん… (¥4,500)');
        break;
      default:
        notify('この建物は外観のみのダミーです。');
    }
  } else {
    notify('近くに相手がいない。');
  }
}

document.getElementById('interactBtn').addEventListener('click', tryInteractNearby);

/* -------------------------
   Initial UI values & finishing touches
   ------------------------- */
document.getElementById('vaultCount').textContent = state.vaults.length;
document.getElementById('money').textContent = fmtMoney(state.player.money);

/* -------------------------
   Small improvements: autosave interval
   ------------------------- */
setInterval(()=> saveStateToLocal(false), 30000);

/* -------------------------
   Final notes in JS console
   ------------------------- */
console.log('Vault Heist initialized. Controls: WASD / arrows or joystick. [E] interact, [Space] fire, [V] vault.');

</script>

</body>
</html>
