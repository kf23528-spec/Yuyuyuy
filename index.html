<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Vault Heist — Part1 (Revised, Robust Integration)</title>
<style>
:root{
  --bg-1:#031018; --bg-2:#041726;
  --panel: rgba(255,255,255,0.04);
  --accent: #00e6a8; --danger:#ff5a6e; --muted:#9fb0ba;
  --glass: rgba(255,255,255,0.03);
  --ui: "Noto Sans JP","Hiragino Kaku Gothic ProN","Helvetica Neue",Arial,sans-serif;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-1),var(--bg-2));font-family:var(--ui);-webkit-font-smoothing:antialiased;color:#e6f2f0}
#app{position:relative;width:100%;height:100vh;overflow:hidden;display:flex;flex-direction:column}

/* GL view area */
#glview{
  width:100%;
  height:28vh;
  min-height:120px;
  max-height:36vh;
  display:block;
  background: linear-gradient(180deg,#021018,#071827);
  box-shadow:0 10px 40px rgba(0,0,0,0.6);
  transition:height 240ms ease, opacity 200ms ease;
}

/* HUD area below */
#playArea{position:relative;flex:1;display:block;width:100%;height:72vh;min-height:320px}
#hud{position:absolute;left:0;top:0;right:0;bottom:0;width:100%;height:100%;touch-action:none;-webkit-user-select:none;user-select:none}

/* top bar controls */
.top-controls{position:absolute;left:12px;top:12px;z-index:80;display:flex;gap:8px}
.panel{background:var(--panel);padding:8px 12px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.5);font-weight:700;color:var(--muted);display:flex;align-items:center;gap:8px;font-size:13px}
.panel .num{color:var(--accent);font-weight:900}

/* controls column */
.controls{position:absolute;right:12px;bottom:12px;z-index:80;display:flex;flex-direction:column;gap:8px;align-items:flex-end}
.btn{background:linear-gradient(180deg,#071b1a,#041414);border-radius:10px;padding:10px 14px;font-weight:800;border:1px solid rgba(255,255,255,0.03);box-shadow:0 10px 30px rgba(0,0,0,0.6);color:#cff9ee;cursor:pointer}
.btn.small{padding:6px 10px;font-size:13px}
.btn.warn{background:linear-gradient(180deg,#3b1014,#2b0710);color:#ffd6da;border:1px solid rgba(255,100,110,0.12)}
.btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04)}

/* stage selector modal */
#stageSelect{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:102;width:92%;max-width:720px;background:linear-gradient(180deg,rgba(2,6,8,0.95),rgba(3,10,14,0.95));border-radius:14px;padding:18px;box-shadow:0 30px 80px rgba(0,0,0,0.7);display:flex;gap:12px;flex-direction:column}
.stageList{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
.stageCard{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:10px;cursor:pointer;display:flex;flex-direction:column;gap:6px;border:1px solid rgba(255,255,255,0.02)}
.stageCard h3{margin:0;font-size:15px;color:#e8fff5}
.stageCard p{margin:0;color:var(--muted);font-size:12px}

/* minimap */
#minimap{position:absolute;left:12px;bottom:12px;z-index:80;width:110px;height:110px;border-radius:10px;background:var(--glass);padding:8px;box-shadow:0 10px 30px rgba(0,0,0,0.6)}

/* visible big stick for mobile - improved contrast */
#stick{position:absolute;left:18px;bottom:124px;z-index:90;width:120px;height:120px;display:flex;align-items:center;justify-content:center;touch-action:none}
.stickOuter{width:100%;height:100%;border-radius:50%;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));display:flex;align-items:center;justify-content:center;border:2px solid rgba(255,255,255,0.04);box-shadow:0 14px 30px rgba(0,0,0,0.6)}
.stickKnob{width:52px;height:52px;border-radius:50%;background:linear-gradient(180deg,#073431,#042a24);box-shadow:0 12px 26px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);border:3px solid rgba(255,255,255,0.06);transform:translate(0px,0px)}

/* shop modal */
#shopModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:120;width:94%;max-width:980px;background:linear-gradient(180deg,#041016,#061720);border-radius:12px;padding:14px;box-shadow:0 30px 80px rgba(0,0,0,0.7);display:none;color:#dff}
.shopGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;max-height:58vh;overflow:auto;padding-right:8px}
.weaponCard{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px}
.weaponName{font-weight:900;color:#e8fff5}
.weaponStat{font-size:12px;color:var(--muted)}

/* inventory / equipped area */
#inventoryPanel{position:absolute;left:12px;top:68px;z-index:85;padding:8px;background:var(--panel);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.5);display:flex;flex-direction:column;gap:8px}
.invItem{display:flex;gap:8px;align-items:center}

/* PvC modal (weapon selection extended) */
#pvcModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:120;width:86%;max-width:680px;background:linear-gradient(180deg,#041016,#061720);border-radius:12px;padding:16px;box-shadow:0 30px 80px rgba(0,0,0,0.7);display:none;color:#dff}
#pvcWeaponList{display:flex;gap:8px;flex-wrap:wrap;max-height:220px;overflow:auto;padding:6px;background:rgba(255,255,255,0.02);border-radius:8px}

/* responsive */
@media (max-width:520px){
  #glview{height:22vh}
  #stick{left:14px;bottom:100px;width:108px;height:108px}
  #minimap{width:86px;height:86px}
  .stageList{grid-template-columns:repeat(1,1fr)}
  .shopGrid{grid-template-columns:repeat(2,1fr)}
  .weaponCard{padding:8px}
  #inventoryPanel{display:none}
}
</style>
</head>
<body>
<div id="app">
  <!-- WebGL top visual -->
  <canvas id="glview" aria-hidden="true"></canvas>

  <!-- Play area -->
  <div id="playArea">
    <canvas id="hud"></canvas>

    <!-- top controls -->
    <div class="top-controls">
      <div class="panel">MONEY: <span id="money" class="num">¥0</span></div>
      <div class="panel">ALARM: <span id="alarm" class="num">0</span></div>
      <div class="panel">STEALTH: <span id="stealth" class="num">100</span></div>
    </div>

    <!-- inventory -->
    <div id="inventoryPanel">
      <div style="font-weight:900;color:#dff">INVENTORY</div>
      <div class="invItem"><div style="width:48px;height:32px;border-radius:6px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center" id="equippedPreview">—</div>
        <div style="display:flex;flex-direction:column">
          <div style="font-weight:800" id="equippedName">No Weapon</div>
          <div style="font-size:12px;color:var(--muted)" id="equippedSkin">Skin: —</div>
        </div>
      </div>
      <div style="display:flex;gap:8px">
        <button id="openShopBtn" class="btn small">SHOP</button>
        <button id="openPvcBtn" class="btn small ghost">PvC MODE</button>
      </div>
    </div>

    <!-- controls -->
    <div class="controls">
      <button id="toggleGL" class="btn small">TOGGLE GL</button>
      <button id="openStageBtn" class="btn small">STAGE SELECT</button>
      <div style="display:flex;gap:8px">
        <button id="hintBtn" class="btn small">HINT</button>
        <button id="restartBtn" class="btn small warn">RESTART</button>
      </div>
    </div>

    <!-- stage select modal -->
    <div id="stageSelect" aria-hidden="false" style="z-index:101;display:none">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div>
          <div style="font-weight:900;font-size:18px;color:#dff">SELECT STAGE</div>
          <div style="font-size:12px;color:var(--muted)">難易度はステージ毎に上がっていきます</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div style="font-size:12px;color:var(--muted)">総資金：</div>
          <div class="panel" style="padding:6px 10px"><span id="moneyShort" class="num">¥0</span></div>
        </div>
      </div>
      <div class="stageList" style="margin-top:12px;"></div>
      <div style="display:flex;justify-content:flex-end;margin-top:10px;">
        <button id="closeStage" class="btn small">CLOSE</button>
      </div>
    </div>

    <!-- minimap -->
    <canvas id="minimap" width="110" height="110" aria-hidden="true"></canvas>

    <!-- virtual stick -->
    <div id="stick" aria-hidden="true">
      <div class="stickOuter"><div id="knob" class="stickKnob"></div></div>
    </div>

    <!-- shop modal -->
    <div id="shopModal">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:900;font-size:18px">SHOP</div>
        <div style="display:flex;gap:8px;align-items:center">
          <div style="font-size:12px;color:var(--muted)">所持金</div>
          <div class="panel" style="padding:6px 10px"><span id="moneyShop" class="num">¥0</span></div>
          <button id="closeShop" class="btn small">CLOSE</button>
        </div>
      </div>
      <div style="margin-top:12px;display:flex;gap:12px">
        <div style="flex:1">
          <div style="font-size:13px;color:var(--muted);margin-bottom:8px">武器一覧（購入してPvCやテストマップで使用可能）</div>
          <div class="shopGrid" id="weaponGrid"></div>
        </div>
        <div style="width:300px">
          <div style="font-weight:900">PREVIEW</div>
          <div id="shopPreview" style="margin-top:8px;background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;min-height:160px">
            <div id="previewName" style="font-weight:900">—</div>
            <div id="previewInfo" style="color:var(--muted);font-size:13px;margin-top:6px">武器詳細がここに表示されます。</div>
            <div id="previewSkins" style="margin-top:8px"></div>
            <div style="margin-top:12px;display:flex;gap:8px">
              <button id="buyBtn" class="btn small">BUY</button>
              <button id="equipBtn" class="btn small ghost">EQUIP</button>
            </div>
          </div>
          <div style="margin-top:12px">
            <div style="font-weight:900">ショップ機能</div>
            <div style="font-size:13px;color:var(--muted);margin-top:6px">武器を購入するとインベントリに追加されます。スキンは個別購入。</div>
          </div>
        </div>
      </div>
    </div>

    <!-- PvC modal -->
    <div id="pvcModal">
      <div style="font-weight:900;font-size:16px">PvC — Player vs CPU (選択)</div>
      <div style="color:var(--muted);font-size:13px;margin-top:6px">装備した武器でAIと対戦できます（AIレベルを選択）。ここで使用武器を選択してください。</div>

      <div style="margin-top:12px">
        <div style="font-weight:800">所持武器</div>
        <div id="pvcWeaponList" style="margin-top:8px"></div>
      </div>

      <div style="display:flex;gap:8px;margin-top:12px;align-items:center">
        <div style="min-width:88px">選択武器：</div>
        <div id="pvcWeaponPreview" style="flex:1;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px">—</div>
      </div>

      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <div style="min-width:88px">AIレベル：</div>
        <select id="aiLevel" style="padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);color:#dff">
          <option value="1">Level 1 (Easy)</option>
          <option value="2">Level 2</option>
          <option value="3">Level 3</option>
          <option value="4">Level 4</option>
          <option value="5">Level 5</option>
          <option value="6">Level 6</option>
          <option value="7">Level 7</option>
          <option value="8">Level 8</option>
          <option value="9">Level 9</option>
          <option value="10">Level 10 (Hard)</option>
        </select>
      </div>

      <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px">
        <button id="startPvc" class="btn small">START PvC</button>
        <button id="closePvc" class="btn small">CLOSE</button>
      </div>
    </div>

  </div>
</div>

<script>
/*
  Part1 — Revised, defensive, integration-friendly.
  Responsibilities:
    - Provide robust data (WEAPONS x20, STAGES expanded).
    - Provide safe global stubs for functions used by later Parts (showModal, startDialHack, startPvC etc.)
    - Shop / inventory / equip logic with persistence.
    - Map generation baseline, Player and MapGrid minimal implementations.
    - Hooks & events that later Parts will override (startPvC, startDialHack, renderPvCWeaponList).
    - Defensive coding to avoid ReferenceError when loaded in isolation.
*/

/* =========================
   Utilities
   ========================= */
const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
const rand = (a,b)=> a + Math.random()*(b-a);
const nowMs = ()=> performance.now();
const isNumber = v => typeof v === 'number' && !isNaN(v);

/* =========================
   DOM nodes & canvases
   ========================= */
const glCanvas = document.getElementById('glview');
const hudCanvas = document.getElementById('hud');
const miniCanvas = document.getElementById('minimap');
const ctx = hudCanvas.getContext('2d');
const mini = miniCanvas.getContext('2d');

const moneyEl = document.getElementById('money');
const moneyShortEl = document.getElementById('moneyShort');
const moneyShopEl = document.getElementById('moneyShop');
const alarmEl = document.getElementById('alarm');
const stealthEl = document.getElementById('stealth');
const openStageBtn = document.getElementById('openStageBtn');
const stageSelectEl = document.getElementById('stageSelect');
const stageListEl = stageSelectEl.querySelector('.stageList');
const closeStageBtn = document.getElementById('closeStage');
const toggleGLBtn = document.getElementById('toggleGL');
const openShopBtn = document.getElementById('openShopBtn');
const shopModal = document.getElementById('shopModal');
const closeShopBtn = document.getElementById('closeShop');
const weaponGrid = document.getElementById('weaponGrid');
const previewName = document.getElementById('previewName');
const previewInfo = document.getElementById('previewInfo');
const previewSkins = document.getElementById('previewSkins');
const buyBtn = document.getElementById('buyBtn');
const equipBtn = document.getElementById('equipBtn');
const moneyShop = document.getElementById('moneyShop');
const inventoryPreview = document.getElementById('equippedPreview');
const equippedName = document.getElementById('equippedName');
const equippedSkin = document.getElementById('equippedSkin');
const openPvcBtn = document.getElementById('openPvcBtn');
const pvcModal = document.getElementById('pvcModal');
const pvcWeaponList = document.getElementById('pvcWeaponList');
const pvcWeaponPreview = document.getElementById('pvcWeaponPreview');
const aiLevelSel = document.getElementById('aiLevel');
const startPvcBtn = document.getElementById('startPvc');
const closePvcBtn = document.getElementById('closePvc');
const knob = document.getElementById('knob');
const stick = document.getElementById('stick');
const hintBtn = document.getElementById('hintBtn');
const restartBtn = document.getElementById('restartBtn');

/* =========================
   Responsive sizing
   ========================= */
let W = innerWidth, H = innerHeight;
function resize(){
  W = innerWidth; H = innerHeight;
  // GL canvas
  glCanvas.width = Math.floor(W * devicePixelRatio);
  glCanvas.height = Math.floor(Math.max(120, H * 0.28) * devicePixelRatio);
  glCanvas.style.width = '100%';
  glCanvas.style.height = Math.max(120, H * 0.28) + 'px';
  // HUD canvas (below)
  const playTop = Math.max(120, H * 0.28);
  const hudH = H - playTop;
  hudCanvas.width = Math.floor(W * devicePixelRatio);
  hudCanvas.height = Math.floor(hudH * devicePixelRatio);
  hudCanvas.style.width = '100%';
  hudCanvas.style.height = hudH + 'px';
  hudCanvas.style.top = playTop + 'px';
  // minimap
  miniCanvas.width = 110 * devicePixelRatio;
  miniCanvas.height = 110 * devicePixelRatio;
  miniCanvas.style.width = '110px';
  miniCanvas.style.height = '110px';
}
resize();
window.addEventListener('resize', resize);

/* =========================
   Persistence keys & GAME state
   ========================= */
const STORE_KEYS = {
  money: 'vh_money_v4',
  inventory: 'vh_inv_v4',
  equipped: 'vh_equipped_v4',
  skins: 'vh_skins_v4',
  unlocked: 'vh_unlocked_v4',
  other: 'vh_other_v4'
};

const GAME = window.GAME = {
  running:false,
  elapsed:0,
  // allow localStorage default fallback to 5000 for testing
  money: parseInt(localStorage.getItem(STORE_KEYS.money) || '5000',10),
  alarm:0,
  stealth:100,
  currentStage: null,
  vaultOpen:false,
  hasKey: false,
  // inventory persistence
  inventory: JSON.parse(localStorage.getItem(STORE_KEYS.inventory) || '[]'),
  equipped: JSON.parse(localStorage.getItem(STORE_KEYS.equipped) || 'null'),
  skinsOwned: JSON.parse(localStorage.getItem(STORE_KEYS.skins) || '{}'),
  unlocked: JSON.parse(localStorage.getItem(STORE_KEYS.unlocked) || '["conbini"]'),
  other: JSON.parse(localStorage.getItem(STORE_KEYS.other) || '{}'),
  // callback hooks
  onVaultOpened: null
};

function saveState(){
  try{
    localStorage.setItem(STORE_KEYS.money, String(GAME.money));
    localStorage.setItem(STORE_KEYS.inventory, JSON.stringify(GAME.inventory));
    localStorage.setItem(STORE_KEYS.equipped, JSON.stringify(GAME.equipped));
    localStorage.setItem(STORE_KEYS.skins, JSON.stringify(GAME.skinsOwned));
    localStorage.setItem(STORE_KEYS.unlocked, JSON.stringify(GAME.unlocked));
    localStorage.setItem(STORE_KEYS.other, JSON.stringify(GAME.other));
  }catch(e){}
}

function setMoney(v){
  GAME.money = Math.max(0, Math.floor(v));
  moneyEl.textContent = '¥' + GAME.money.toLocaleString();
  moneyShortEl.textContent = '¥' + GAME.money.toLocaleString();
  moneyShopEl.textContent = '¥' + GAME.money.toLocaleString();
  saveState();
}
setMoney(GAME.money);

/* =========================
   STAGES (extended, with high-tier banks)
   ========================= */
const STAGES = [
  {id:'conbini', name:'コンビニ (Convenience Store)', difficulty:1, desc:'小さなバックヤード。レーザー少・警備ゆるめ。', mapParams:{cols:12,rows:8, density:0.06, lasers:1,guards:1}, reward:[10000,30000]},
  {id:'bank', name:'銀行支店 (Bank Branch)', difficulty:2, desc:'市中銀行の支店。金庫室があります。', mapParams:{cols:16,rows:10,density:0.12,lasers:2,guards:2}, reward:[200000,700000]},
  {id:'casino', name:'国営カジノ (National Casino)', difficulty:3, desc:'監視カメラ多数・広域パトロール。', mapParams:{cols:20,rows:12,density:0.18,lasers:4,guards:3,cameras:3}, reward:[1000000,3000000]},
  {id:'nichigin', name:'日本銀行 (Bank of Japan)', difficulty:4, desc:'最高警備。複雑なパズル要素と強AI。', mapParams:{cols:24,rows:14,density:0.22,lasers:6,guards:5,cameras:5,puzzles:true}, reward:[5000000,12000000]},
  // New high-tier banks (very large rewards)
  {id:'world_bank', name:'World Bank', difficulty:5, desc:'国際金融の中枢。高セキュリティ。', mapParams:{cols:26,rows:16,density:0.24,lasers:7,guards:6,cameras:6,puzzles:true}, reward:[15000000,30000000]},
  {id:'earth_bank', name:'Earth Bank', difficulty:6, desc:'地球規模の資金管理。侵入は極めて困難。', mapParams:{cols:28,rows:18,density:0.26,lasers:8,guards:8,cameras:8,puzzles:true}, reward:[30000000,70000000]},
  {id:'galactic_bank', name:'Galactic Bank', difficulty:7, desc:'銀河規模の資金保管。レーザーとAIネットワークが連動。', mapParams:{cols:32,rows:20,density:0.30,lasers:10,guards:10,cameras:12,puzzles:true}, reward:[100000000,250000000]},
  {id:'galaxy_bank', name:'Galaxy Bank', difficulty:8, desc:'星系をまたぐ金融センター。高難度。', mapParams:{cols:36,rows:22,density:0.34,lasers:12,guards:14,cameras:14,puzzles:true}, reward:[300000000,800000000]},
  {id:'space_bank', name:'Space Bank', difficulty:9, desc:'宇宙規模の保管庫。ほぼオールラウンダー。', mapParams:{cols:40,rows:26,density:0.38,lasers:14,guards:18,cameras:18,puzzles:true}, reward:[800000000,2000000000]}
];

/* =========================
   WEAPONS x20 (ids, stats, skins)
   - kept intentionally stable so Parts 2/3 can reference
   ========================= */
const WEAPONS = [
  {id:'w_pistol_01', name:'Classic 9mm', type:'Handgun', price:12000, stats:{dmg:18,fireRate:3,recoil:2,mag:15,range:180}, skins:[{id:'w_pistol_01_s1',name:'Matte Black',price:1500}]},
  {id:'w_pistol_02', name:'Tactical Pistol', type:'Handgun', price:15000, stats:{dmg:20,fireRate:3.2,recoil:2.2,mag:18,range:200}, skins:[{id:'w_pistol_02_s1',name:'Carbon',price:1600}]},
  {id:'w_compact', name:'Compact Pistol', type:'Handgun', price:9000, stats:{dmg:14,fireRate:3.8,recoil:1.8,mag:12,range:160}, skins:[{id:'w_compact_s1',name:'Urban Camo',price:1200}]},
  {id:'w_smg_01', name:'SMG Swift', type:'SMG', price:38000, stats:{dmg:10,fireRate:12,recoil:3.2,mag:30,range:280}, skins:[{id:'w_smg_01_s1',name:'Tactical Green',price:3200}]},
  {id:'w_smg_02', name:'Compact SMG', type:'SMG', price:30000, stats:{dmg:12,fireRate:11,recoil:3,mag:25,range:260}, skins:[{id:'w_smg_02_s1',name:'Slate',price:2500}]},
  {id:'w_ar_01', name:'Vector AR', type:'AR', price:52000, stats:{dmg:28,fireRate:6,recoil:4.2,mag:30,range:580}, skins:[{id:'w_ar_01_s1',name:'Gold Plated',price:8000}]},
  {id:'w_ar_02', name:'Precision AR', type:'AR', price:64000, stats:{dmg:36,fireRate:5.5,recoil:4.6,mag:28,range:820}, skins:[{id:'w_ar_02_s1',name:'Obsidian',price:7000}]},
  {id:'w_carbine', name:'Burst Carbine', type:'Carbine', price:48000, stats:{dmg:32,fireRate:4,recoil:3.8,mag:24,range:680}, skins:[{id:'w_carbine_s1',name:'Neon Slash',price:4200}]},
  {id:'w_lmg', name:'Heavy MG', type:'LMG', price:90000, stats:{dmg:25,fireRate:8,recoil:7.2,mag:100,range:900}, skins:[{id:'w_lmg_s1',name:'Industrial',price:12000}]},
  {id:'w_shotgun', name:'Pump Shot', type:'Shotgun', price:42000, stats:{dmg:85,fireRate:0.8,recoil:6,mag:6,range:280}, skins:[{id:'w_shotgun_s1',name:'Rustic',price:3200}]},
  {id:'w_sr_01', name:'Predator SR', type:'Sniper', price:85000, stats:{dmg:110,fireRate:0.5,recoil:8,mag:5,range:2200}, skins:[{id:'w_sr_01_s1',name:'Desert Camo',price:9500}]},
  {id:'w_sr_02', name:'Mini Sniper', type:'Sniper', price:76000, stats:{dmg:85,fireRate:0.6,recoil:7.8,mag:6,range:1800}, skins:[{id:'w_sr_02_s1',name:'Midnight',price:8400}]},
  {id:'w_special_rail', name:'Experimental Rail', type:'Special', price:140000, stats:{dmg:220,fireRate:0.2,recoil:12,mag:2,range:3200}, skins:[{id:'w_special_rail_s1',name:'Prototype',price:25000}]},
  {id:'w_plasma', name:'Plasma Carbine', type:'Energy', price:98000, stats:{dmg:48,fireRate:3.5,recoil:5.2,mag:40,range:900}, skins:[{id:'w_plasma_s1',name:'Aurora',price:12000}]},
  {id:'w_pulse', name:'Pulse Cannon', type:'Heavy', price:120000, stats:{dmg:160,fireRate:0.35,recoil:10,mag:4,range:2000}, skins:[{id:'w_pulse_s1',name:'Void',price:30000}]},
  {id:'w_laserburst', name:'Burst Laser', type:'Energy', price:74000, stats:{dmg:30,fireRate:5.8,recoil:4.6,mag:32,range:1000}, skins:[{id:'w_laserburst_s1',name:'Stellar',price:9000}]},
  {id:'w_micro_mg', name:'Micro MG', type:'MG', price:54000, stats:{dmg:22,fireRate:10.8,recoil:5.8,mag:60,range:600}, skins:[{id:'w_micro_mg_s1',name:'Cinder',price:5200}]},
  {id:'w_ion', name:'Ion Carbine', type:'Energy', price:86000, stats:{dmg:58,fireRate:2.6,recoil:6.2,mag:18,range:1200}, skins:[{id:'w_ion_s1',name:'Ionized',price:14000}]},
  {id:'w_gravity_sr', name:'Gravity SR', type:'Sniper', price:160000, stats:{dmg:260,fireRate:0.18,recoil:14,mag:2,range:3600}, skins:[{id:'w_gravity_sr_s1',name:'Quasar',price:42000}]},
  {id:'w_nano_smg', name:'Nano SMG', type:'SMG', price:42000, stats:{dmg:16,fireRate:14,recoil:3.6,mag:40,range:320}, skins:[{id:'w_nano_smg_s1',name:'Nano Camo',price:3600}]},
  {id:'w_ionburst', name:'Ion Burst', type:'Special', price:112000, stats:{dmg:90,fireRate:1.2,recoil:9,mag:8,range:1400}, skins:[{id:'w_ionburst_s1',name:'Nebula',price:16000}]}
];

const WEAPON_BY_ID = Object.fromEntries(WEAPONS.map(w=>[w.id,w]));

/* =========================
   Inventory helpers & shop
   ========================= */
function ownsWeapon(id){ return Array.isArray(GAME.inventory) && GAME.inventory.includes(id); }

// Primary shop/buy function. Later Parts may wrap/override it.
// Returns object {ok: boolean, msg?: string}
function buyWeapon(id){
  const w = WEAPON_BY_ID[id];
  if(!w) return {ok:false,msg:'Invalid weapon'};
  if(ownsWeapon(id)) return {ok:false,msg:'Already owned'};
  if(GAME.money < w.price) return {ok:false,msg:'Insufficient funds'};
  setMoney(GAME.money - w.price);
  if(!Array.isArray(GAME.inventory)) GAME.inventory = [];
  GAME.inventory.push(id);
  // auto-equip if none
  if(!GAME.equipped || !GAME.equipped.weaponId){
    GAME.equipped = {weaponId:id, skinId: (GAME.skinsOwned && GAME.skinsOwned[id] && GAME.skinsOwned[id][0]) || null};
  }
  saveState();
  showFloatingText(`${w.name} を購入しました`);
  renderShopGrid();
  renderInventory();
  // notify PvC bar (Parts 2/3 will implement)
  if(typeof window.renderPvCWeaponBar === 'function') try{ window.renderPvCWeaponBar(); }catch(e){}
  return {ok:true};
}

// Equip helper
function equipWeapon(id){
  if(!ownsWeapon(id)) return {ok:false,msg:'Not owned'};
  GAME.equipped = {weaponId:id, skinId: (GAME.skinsOwned && GAME.skinsOwned[id] && GAME.skinsOwned[id][0]) || null};
  saveState();
  renderInventory();
  showFloatingText('武器を装備しました');
  // inform PVC UI if available
  if(typeof window.renderPvCWeaponBar === 'function') try{ window.renderPvCWeaponBar(); }catch(e){}
  return {ok:true};
}

// Buy skin
function buySkin(weaponId, skinId, price){
  if(GAME.money < price) return {ok:false,msg:'Insufficient funds'};
  GAME.skinsOwned[weaponId] = GAME.skinsOwned[weaponId] || [];
  if(GAME.skinsOwned[weaponId].includes(skinId)) return {ok:false,msg:'Skin already owned'};
  setMoney(GAME.money - price);
  GAME.skinsOwned[weaponId].push(skinId);
  saveState();
  showFloatingText('スキンを購入しました');
  renderShopGrid();
  renderInventory();
  return {ok:true};
}

/* =========================
   Floating UI utilities
   ========================= */
function showFloatingText(text, ttl=1600){
  const el = document.createElement('div');
  el.style.position='fixed'; el.style.left='50%'; el.style.top='18%'; el.style.transform='translateX(-50%)';
  el.style.padding='8px 12px'; el.style.borderRadius='10px'; el.style.background='rgba(6,10,12,0.8)'; el.style.color='#dff'; el.style.fontWeight='900'; el.style.zIndex='200';
  el.textContent = text;
  document.body.appendChild(el);
  setTimeout(()=>{ el.style.transition='all 0.8s'; el.style.opacity='0'; el.style.transform='translate(-50%,-10px)'; },Math.max(700, ttl/2));
  setTimeout(()=>el.remove(),ttl+600);
}

/* =========================
   Shop rendering
   ========================= */
let currentPreviewWeaponId = WEAPONS[0].id;
function renderShopGrid(){
  weaponGrid.innerHTML = '';
  for(const w of WEAPONS){
    const card = document.createElement('div'); card.className='weaponCard';
    const title = document.createElement('div'); title.className='weaponName'; title.textContent = `${w.name} (${w.type})`;
    const stat = document.createElement('div'); stat.className='weaponStat'; stat.innerHTML =
      `Price: ¥${w.price.toLocaleString()}<br/>DMG:${w.stats.dmg} FR:${w.stats.fireRate} RCL:${w.stats.recoil} MAG:${w.stats.mag}`;
    const actions = document.createElement('div'); actions.style.display='flex'; actions.style.justifyContent='space-between'; actions.style.marginTop='8px';
    const btnBuy = document.createElement('button'); btnBuy.className='btn small'; btnBuy.textContent = ownsWeapon(w.id) ? 'OWNED' : `BUY ¥${w.price.toLocaleString()}`;
    if(ownsWeapon(w.id)) btnBuy.disabled = true;
    btnBuy.addEventListener('click', ()=>{
      const res = buyWeapon(w.id);
      if(!res.ok) showFloatingText(res.msg);
    });
    const btnPreview = document.createElement('button'); btnPreview.className='btn small ghost'; btnPreview.textContent='PREVIEW';
    btnPreview.addEventListener('click', ()=> { setPreviewWeapon(w.id); openShopModal(); });
    actions.appendChild(btnBuy); actions.appendChild(btnPreview);
    card.appendChild(title); card.appendChild(stat); card.appendChild(actions);
    weaponGrid.appendChild(card);
  }
}

function setPreviewWeapon(id){
  const w = WEAPON_BY_ID[id];
  currentPreviewWeaponId = id;
  previewName.textContent = w.name + ` (${w.type})`;
  previewInfo.innerHTML = `Price: ¥${w.price.toLocaleString()}<br/>DMG:${w.stats.dmg}  FR:${w.stats.fireRate}  RCL:${w.stats.recoil}  MAG:${w.stats.mag}  RNG:${w.stats.range}`;
  previewSkins.innerHTML = '';
  for(const s of w.skins || []){
    const sk = document.createElement('div'); sk.style.display='flex'; sk.style.justifyContent='space-between'; sk.style.alignItems='center'; sk.style.marginTop='6px';
    sk.innerHTML = `<div style="font-size:13px">${s.name}</div><div style="display:flex;gap:6px"><div style="font-size:13px;color:var(--muted)">¥${s.price.toLocaleString()}</div><button class="btn small ghost">BUY</button></div>`;
    const buyBtn = sk.querySelector('button');
    buyBtn.addEventListener('click', ()=>{
      const res = buySkin(id, s.id, s.price);
      if(!res.ok) showFloatingText(res.msg);
    });
    previewSkins.appendChild(sk);
  }
  buyBtn.disabled = ownsWeapon(id);
  buyBtn.textContent = ownsWeapon(id) ? 'OWNED' : `BUY ¥${WEAPON_BY_ID[id].price.toLocaleString()}`;
  equipBtn.disabled = !ownsWeapon(id);
  equipBtn.textContent = ownsWeapon(id) ? 'EQUIP' : 'EQUIP (BUY)';
}

buyBtn.addEventListener('click', ()=>{
  if(!currentPreviewWeaponId) return;
  const res = buyWeapon(currentPreviewWeaponId);
  if(!res.ok) showFloatingText(res.msg);
});
equipBtn.addEventListener('click', ()=>{
  if(!currentPreviewWeaponId) return;
  const res = equipWeapon(currentPreviewWeaponId);
  if(!res.ok) showFloatingText(res.msg);
});

function openShopModal(){
  renderShopGrid();
  shopModal.style.display = 'block';
  setPreviewWeapon(currentPreviewWeaponId || WEAPONS[0].id);
}
function closeShopModal(){
  shopModal.style.display = 'none';
}
closeShopBtn.addEventListener('click', closeShopModal);
openShopBtn.addEventListener('click', ()=>{ openShopModal(); });

/* =========================
   Inventory render
   ========================= */
function renderInventory(){
  if(GAME.equipped && GAME.equipped.weaponId){
    const wid = GAME.equipped.weaponId;
    const w = WEAPON_BY_ID[wid];
    inventoryPreview.textContent = w.name[0];
    inventoryPreview.title = w.name;
    equippedName.textContent = w.name;
    const skinId = GAME.equipped.skinId || '—';
    equippedSkin.textContent = 'Skin: ' + (skinId === '—' ? 'None' : skinId);
    pvcWeaponPreview.textContent = w.name + (skinId!=='—' ? ` (${skinId})` : '');
  } else {
    inventoryPreview.textContent = '—';
    equippedName.textContent = 'No Weapon';
    equippedSkin.textContent = 'Skin: —';
    pvcWeaponPreview.textContent = 'No Weapon';
  }
}
renderInventory();

/* =========================
   PvC weapon list rendering (populates #pvcWeaponList and sets global pvcSelectedWeaponId)
   This function is intentionally simple here; Part2/Part3 will enhance UI.
   ========================= */
window.pvcSelectedWeaponId = window.pvcSelectedWeaponId || null;
function renderPvCWeaponList(){
  pvcWeaponList.innerHTML = '';
  if(!Array.isArray(GAME.inventory) || GAME.inventory.length === 0){
    pvcWeaponList.textContent = '所持武器がありません。ショップで購入してください。';
    window.pvcSelectedWeaponId = null;
    pvcWeaponPreview.textContent = 'No Weapon';
    return;
  }
  for(const wid of GAME.inventory){
    const w = WEAPON_BY_ID[wid];
    const card = document.createElement('div');
    card.style.padding='8px'; card.style.borderRadius='8px'; card.style.background='rgba(255,255,255,0.02)'; card.style.display='flex'; card.style.alignItems='center'; card.style.gap='8px';
    card.style.cursor='pointer';
    card.innerHTML = `<div style="width:44px;height:30px;border-radius:6px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center">${w.name[0]}</div>
                      <div style="flex:1"><div style="font-weight:800">${w.name}</div><div style="font-size:12px;color:var(--muted)">${w.type}</div></div>
                      <div><button class="btn small">SELECT</button></div>`;
    const btn = card.querySelector('button');
    btn.addEventListener('click', ()=> {
      window.pvcSelectedWeaponId = wid;
      pvcWeaponPreview.textContent = w.name;
      // highlight selection
      Array.from(pvcWeaponList.children).forEach(ch=> ch.style.outline='none');
      card.style.outline = '2px solid rgba(0,230,168,0.12)';
    });
    pvcWeaponList.appendChild(card);
  }
}
window.renderPvCWeaponList = renderPvCWeaponList;

/* =========================
   Map & Player baseline
   ========================= */
class MapGrid {
  constructor(cols, rows, cellSize=48){
    this.cols = cols; this.rows = rows; this.cell = cellSize;
    this.cells = new Array(rows);
    for(let r=0;r<rows;r++) this.cells[r] = new Array(cols).fill(0);
    this.entities = {guards:[], lasers:[], items:[], cameras:[], plates:[]};
    this.vault = null;
    this.vaultOpened = false;
    this.stageId = null;
  }
  inBounds(x,y){ return x>=0 && x < this.cols && y>=0 && y < this.rows; }
  setWall(x,y){ if(this.inBounds(x,y)) this.cells[y][x]=1; }
  setVault(x,y){ if(this.inBounds(x,y)){ this.cells[y][x]=2; this.vault={x,y}; } }
  placeRandomVault(){ const x=Math.max(2,this.cols-3); const y=Math.floor(this.rows/2); this.setVault(x,y); }
  addGuard(g){ this.entities.guards.push(g); }
  addLaser(l){ this.entities.lasers.push(l); }
  addItem(it){ this.entities.items.push(it); }
}

function generateStageMap(stage){
  const p = stage.mapParams || {};
  const cols = p.cols || 16, rows = p.rows || 10;
  const map = new MapGrid(cols, rows, Math.floor(Math.max(36, Math.min(64, 48 - (p.difficulty||1)*2))));
  // perimeter walls
  for(let x=0;x<map.cols;x++){ map.setWall(x,0); map.setWall(x,map.rows-1); }
  for(let y=0;y<map.rows;y++){ map.setWall(0,y); map.setWall(map.cols-1,y); }
  // interior random walls based on density
  const attempts = Math.floor(map.cols * map.rows * (p.density || 0.08));
  for(let i=0;i<attempts;i++){
    const rx = Math.floor(rand(1,map.cols-2));
    const ry = Math.floor(rand(1,map.rows-2));
    if(map.cells[ry][rx] === 0){ if(Math.random() < 0.65) map.setWall(rx,ry); }
  }
  map.placeRandomVault();
  // lasers
  const lasersToPlace = p.lasers||1;
  for(let i=0;i<lasersToPlace;i++){
    const lx = Math.floor(rand(2,map.cols-3)); const ly = Math.floor(rand(2,map.rows-3));
    map.addLaser({x:lx+0.5,y:ly+0.5,dir:Math.random()*Math.PI*2,speed:0.5+Math.random()*1.4,len:Math.floor(rand(4,Math.min(map.cols,map.rows)-2)),thickness:0.08,pattern:'rot',phase:Math.random()*Math.PI*2});
  }
  // guards
  const guardsToPlace = p.guards||1;
  for(let g=0;g<guardsToPlace;g++){
    const gx = Math.floor(rand(2,map.cols-3))+0.5; const gy = Math.floor(rand(2,map.rows-3))+0.5;
    map.addGuard({x:gx,y:gy,pts:[{x:gx,y:gy},{x:clamp(Math.floor(gx+2),1,map.cols-2),y:gy}],speed:0.7 + Math.random()*0.9,t:0,dir:1,alert:false,routeIndex:g});
  }
  // occasionally place keycard
  if(Math.random() < 0.8){
    const itx = Math.floor(rand(1,map.cols-2))+0.2; const ity = Math.floor(rand(1,map.rows-2))+0.2;
    map.addItem({x:itx,y:ity,type:'keycard',collected:false});
  }
  map.stageId = stage.id;
  return map;
}

/* =========================
   Player object (baseline) - keep speed slightly reduced so Part2 can tune further
   ========================= */
const Player = window.Player = { x:2.5, y:2.5, r:0.35, speed:2.4, _vx:0, _vy:0,
  move(dx,dy,dt,map){
    const nx = this.x + dx * this.speed * dt;
    const ny = this.y + dy * this.speed * dt;
    if(!isBlocked(nx,this.y,map)) this.x = clamp(nx,0.3,map.cols-0.3);
    if(!isBlocked(this.x,ny,map)) this.y = clamp(ny,0.3,map.rows-0.3);
  }
};
function isBlocked(x,y,map){ const cx=Math.floor(x), cy=Math.floor(y); if(!map) return false; if(!map.inBounds(cx,cy)) return true; return map.cells[cy][cx]===1; }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }

/* =========================
   Input handling (stick + keyboard)
   ========================= */
let stickActive=false, stickId=null, stickPos={x:0,y:0};
function resetStick(){ stickPos.x=0; stickPos.y=0; knob.style.transform='translate(0px,0px)'; }
knob.addEventListener('pointerdown', e=>{ e.preventDefault(); knob.setPointerCapture && knob.setPointerCapture(e.pointerId); stickActive=true; stickId=e.pointerId; });
window.addEventListener('pointerup', e=>{ if(stickId===e.pointerId){ stickActive=false; stickId=null; resetStick(); }});
window.addEventListener('pointermove', e=>{ if(!stickActive||stickId!==e.pointerId) return; const rect=stick.getBoundingClientRect(); const cx=rect.left+rect.width/2, cy=rect.top+rect.height/2; const dx=e.clientX-cx, dy=e.clientY-cy; const max=rect.width/2-10; let nx=clamp(dx/max,-1,1), ny=clamp(dy/max,-1,1); stickPos.x=nx; stickPos.y=ny; knob.style.transform=`translate(${nx*(rect.width/2-34)}px, ${ny*(rect.height/2-34)}px)`; });

const keys={};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key.toLowerCase()==='h') openDialHack(); });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

function getInputVector(){
  let ix=0, iy=0;
  if(keys['w']||keys['arrowup']) iy-=1;
  if(keys['s']||keys['arrowdown']) iy+=1;
  if(keys['a']||keys['arrowleft']) ix-=1;
  if(keys['d']||keys['arrowright']) ix+=1;
  if(Math.abs(stickPos.x)>0.05||Math.abs(stickPos.y)>0.05){ ix=stickPos.x; iy=stickPos.y; }
  const len = Math.hypot(ix,iy) || 1;
  return {x:ix/len, y:iy/len};
}

/* =========================
   GL shader (defensive)
   - created but safe if WebGL not available
   ========================= */
let gl = null, glProg = null;
try {
  gl = glCanvas.getContext('webgl',{antialias:true});
  if(gl){
    const vert = `attribute vec2 a_pos; varying vec2 v_uv; void main(){ v_uv = a_pos*0.5+0.5; gl_Position = vec4(a_pos,0,1); }`;
    const frag = `precision mediump float; varying vec2 v_uv; uniform float u_time; uniform vec2 u_res; uniform float u_open; void main(){ vec2 uv=(v_uv-0.5)*vec2(u_res.x/u_res.y,1.0); vec3 col=vec3(0.02,0.06,0.08); float d=length(uv); col+=0.12*(1.0-smoothstep(0.0,1.2,d)); float rim=smoothstep(0.28,0.27,d); vec3 metal=mix(vec3(0.06,0.1,0.14),vec3(0.18,0.22,0.24),rim); col=mix(col,metal,rim); float spokes=0.0; float rot=u_time*0.6*(1.0-u_open*0.7); for(int i=0;i<8;i++){ float a=rot+float(i)*3.14159*2.0/8.0; vec2 dir=vec2(cos(a),sin(a)); float line=smoothstep(0.01,0.0,abs(dot(normalize(uv),dir))-0.05)*smoothstep(0.5,0.35,length(uv)); spokes+=line; } col+=spokes*0.22; float hub=smoothstep(0.12,0.11,d)-smoothstep(0.06,0.061,d); col=mix(col,vec3(0.9,0.88,0.82),hub); float glow=smoothstep(0.25,0.22,d)*(1.0-u_open); col+=vec3(0.0,0.35,0.25)*glow*0.6*(0.5+0.5*sin(u_time*6.0)); col*=1.0-0.15*(1.0-smoothstep(0.34,0.33,d)); col*=1.0-0.35*d; gl_FragColor=vec4(col,1.0);} `;
    function mkShader(src,type){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) console.warn(gl.getShaderInfoLog(s)); return s; }
    const vs = mkShader(vert, gl.VERTEX_SHADER);
    const fs = mkShader(frag, gl.FRAGMENT_SHADER);
    const prog = gl.createProgram(); gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog); gl.useProgram(prog);
    glProg = { prog, posLoc: gl.getAttribLocation(prog,'a_pos'), timeLoc: gl.getUniformLocation(prog,'u_time'), resLoc: gl.getUniformLocation(prog,'u_res'), openLoc: gl.getUniformLocation(prog,'u_open') };
    const quad = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quad); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW); gl.enableVertexAttribArray(glProg.posLoc); gl.vertexAttribPointer(glProg.posLoc,2,gl.FLOAT,false,0,0);
  }
} catch(e){ console.warn('WebGL init failed', e); gl=null; glProg=null; }

/* =========================
   HUD draw function (map visualization)
   ========================= */
function drawHUD(stageMap){
  ctx.clearRect(0,0,hudCanvas.width,hudCanvas.height);
  ctx.save();
  ctx.scale(devicePixelRatio, devicePixelRatio);

  const pad = 12;
  const areaW = W - pad*2;
  const areaH = (H - Math.max(120, H*0.28)) - pad*2;
  const cell = stageMap ? stageMap.cell * Math.min(areaW / (stageMap.cols*stageMap.cell), areaH / (stageMap.rows*stageMap.cell)) : 40;
  const offsetX = pad + 8;
  const offsetY = 8;

  // field background
  ctx.fillStyle = 'rgba(8,12,16,0.55)';
  roundRect(ctx, offsetX-6, offsetY-6, Math.max(400, cell*(stageMap ? stageMap.cols : 12))+12, Math.max(200, cell*(stageMap ? stageMap.rows : 8))+12, 10);
  ctx.fill();

  if(stageMap){
    const fw = cell * stageMap.cols;
    const fh = cell * stageMap.rows;
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    for(let c=0;c<=stageMap.cols;c++){ const x=offsetX + c*cell; ctx.beginPath(); ctx.moveTo(x,offsetY); ctx.lineTo(x, offsetY + fh); ctx.stroke(); }
    for(let r=0;r<=stageMap.rows;r++){ const y=offsetY + r*cell; ctx.beginPath(); ctx.moveTo(offsetX,y); ctx.lineTo(offsetX + fw,y); ctx.stroke(); }

    // walls & vault
    for(let y=0;y<stageMap.rows;y++){
      for(let x=0;x<stageMap.cols;x++){
        if(stageMap.cells[y][x] === 1){ ctx.fillStyle='rgba(30,40,45,0.9)'; ctx.fillRect(offsetX + x*cell, offsetY + y*cell, cell, cell); }
        else if(stageMap.cells[y][x] === 2){ ctx.fillStyle='rgba(140,220,190,0.18)'; ctx.fillRect(offsetX + x*cell, offsetY + y*cell, cell, cell); ctx.fillStyle='#8de7c6'; ctx.font='12px '+getComputedStyle(document.body).fontFamily; ctx.fillText('VAULT', offsetX + x*cell + 6, offsetY + y*cell + 16); }
      }
    }

    // lasers
    for(const L of stageMap.entities.lasers){
      const cx = offsetX + L.x * cell;
      const cy = offsetY + L.y * cell;
      const angle = (L._angle || L.dir) + (L.phase||0);
      const dx = Math.cos(angle), dy = Math.sin(angle);
      const lenPx = L.len * cell;
      ctx.lineWidth = Math.max(3, (L.thickness||0.08)*cell);
      const grad = ctx.createLinearGradient(cx - dx*lenPx/2, cy - dy*lenPx/2, cx + dx*lenPx/2, cy + dy*lenPx/2);
      grad.addColorStop(0,'rgba(255,80,90,0.0)'); grad.addColorStop(0.4,'rgba(255,60,80,0.45)'); grad.addColorStop(0.5,'rgba(255,80,100,0.95)'); grad.addColorStop(0.6,'rgba(255,60,80,0.45)'); grad.addColorStop(1,'rgba(255,80,90,0.0)');
      ctx.strokeStyle = grad; ctx.beginPath(); ctx.moveTo(cx - dx*lenPx/2, cy - dy*lenPx/2); ctx.lineTo(cx + dx*lenPx/2, cy + dy*lenPx/2); ctx.stroke();
    }

    // items
    for(const it of stageMap.entities.items){
      if(it.collected) continue;
      const px = offsetX + it.x*cell, py = offsetY + it.y*cell;
      ctx.fillStyle = '#ffd86b'; ctx.beginPath(); ctx.arc(px,py,Math.max(6,cell*0.12),0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#3a2708'; ctx.font='10px '+getComputedStyle(document.body).fontFamily; ctx.fillText(it.type.toUpperCase(), px-12, py+4);
    }

    // guards
    for(const g of stageMap.entities.guards){
      const px = offsetX + g.x*cell, py = offsetY + g.y*cell;
      ctx.fillStyle = g.alert ? 'rgba(255,90,100,0.95)' : '#d1d8e0';
      ctx.beginPath(); ctx.arc(px,py,Math.max(8,cell*0.15),0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#06202a'; ctx.font='10px '+getComputedStyle(document.body).fontFamily; ctx.fillText('G', px-5, py+4);
    }

    // player
    const ppx = offsetX + Player.x*cell, ppy = offsetY + Player.y*cell;
    const aura = Math.max(12, (GAME.stealth/100)*Math.min(48, cell));
    const gRad = ctx.createRadialGradient(ppx,ppy,6,ppx,ppy,aura); gRad.addColorStop(0,'rgba(0,230,168,0.16)'); gRad.addColorStop(1,'rgba(0,230,168,0.0)');
    ctx.fillStyle = gRad; ctx.beginPath(); ctx.arc(ppx,ppy,aura,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#cfeee4'; ctx.beginPath(); ctx.arc(ppx,ppy,Math.max(6,cell*0.12),0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#003834'; ctx.font='10px '+getComputedStyle(document.body).fontFamily; ctx.fillText('YOU', ppx-10, ppy+4);
  }

  ctx.restore();
  drawMiniMap(stageMap);
}

function drawMiniMap(map){
  mini.clearRect(0,0,miniCanvas.width,miniCanvas.height);
  mini.save(); mini.scale(devicePixelRatio,devicePixelRatio);
  mini.fillStyle='rgba(5,8,10,0.6)'; roundRect(mini,2,2,106,106,8); mini.fill();
  if(!map){ mini.restore(); return; }
  const sx=90/map.cols, sy=90/map.rows;
  for(const it of map.entities.items){ if(it.collected) continue; mini.fillStyle='#ffd86b'; mini.fillRect(8 + it.x*sx, 8 + it.y*sy, 4,4); }
  for(const g of map.entities.guards){ mini.fillStyle='#ff6b6b'; mini.fillRect(8 + g.x*sx, 8 + g.y*sy, 5,5); }
  mini.fillStyle='#00e6a8'; mini.fillRect(8 + Player.x*sx, 8 + Player.y*sy, 6,6);
  if(map.vault) { mini.fillStyle='#8de7c6'; mini.fillRect(8 + map.vault.x*sx - 3, 8 + map.vault.y*sy - 3, 8,8); }
  mini.restore();
}

function roundRect(c,x,y,w,h,r){ c.beginPath(); c.moveTo(x+r,y); c.arcTo(x+w,y,x+w,y+h,r); c.arcTo(x+w,y+h,x,y+h,r); c.arcTo(x,y+h,x,y,r); c.arcTo(x,y,x+w,y,r); c.closePath(); }

/* =========================
   Game loop baseline & helpers (Parts 2 will override the tick)
   - provide startStage and stopGame so other parts can call them safely
   ========================= */
let currentMap = null, lastTime = performance.now();
function startStage(stage){
  currentMap = generateStageMap(stage);
  Player.x = 1.5; Player.y = Math.floor(currentMap.rows/2) + 0.5;
  GAME.currentStage = stage;
  GAME.running = true;
  GAME.alarm = 0;
  GAME.stealth = 100;
  GAME.vaultOpen = false;
  lastTime = performance.now();
  showFloatingText(stage.name + ' に侵入しました');
  // Render HUD once
  drawHUD(currentMap);
}
function stopGame(reason){
  GAME.running = false;
  showModal && showModal('STOP', reason || 'ゲームを停止しました', ()=>{});
}

/* =========================
   Basic guards update (simple patrol) - Part2/Part4 may replace with enhanced AI.
   We expose updateGuards so other scripts can call it.
   ========================= */
function updateGuards(map, dt=0.016, aggressive=false){
  if(!map || !map.entities || !Array.isArray(map.entities.guards)) return;
  for(const g of map.entities.guards){
    // ensure base speed
    g._baseSpeed = g._baseSpeed || g.speed || 0.8;
    // create a simple route: pts may exist from generation; otherwise circle
    if(!g.pts || g.pts.length < 2){
      const gx = Math.floor(g.x) || 2;
      const gy = Math.floor(g.y) || 2;
      g.pts = [{x:gx,y:gy},{x:clamp(gx+2,1,map.cols-2),y:gy}];
    }
    if(!isNumber(g._t)) g._t = 0;
    g._t += dt;
    // move along path
    const a = g.pts[0], b = g.pts[1];
    if(!g._dirF) g._dirF = true;
    const tgt = g._dirF ? b : a;
    const vx = tgt.x - g.x, vy = tgt.y - g.y; const d = Math.hypot(vx,vy);
    if(d < 0.25){ g._dirF = !g._dirF; }
    const ux = d? vx/d : 0, uy = d? vy/d : 0;
    const sp = g._baseSpeed * (aggressive ? 1.6 : 1.0);
    g.x += ux * sp * dt * (g._dirF ? 1 : -1);
    g.y += uy * sp * dt * (g._dirF ? 1 : -1);
    // alert if near player
    if(dist(g.x,g.y,Player.x,Player.y) < (aggressive ? 2.0 : 1.2)){ g.alert=true; GAME.alarm = Math.min(100, GAME.alarm + 18 * dt); GAME.stealth = Math.max(0, GAME.stealth - 18*dt); } else { g.alert=false; }
  }
}

/* =========================
   Minimal tick that lets the page render sensibly when Part1 is run alone.
   Parts 2 will replace this loop with advanced logic. We keep a lightweight loop.
   ========================= */
function minimalTick(){
  const tnow = performance.now();
  const dt = Math.min(0.05, (tnow - lastTime)/1000);
  lastTime = tnow;
  if(GAME.running && currentMap){
    GAME.elapsed += dt;
    // apply small idle guard updates to show movement
    updateGuards(currentMap, dt, false);
    // items proximity collection (very simple)
    for(const it of currentMap.entities.items){
      if(!it.collected && dist(Player.x,Player.y,it.x,it.y) < 0.8){
        it.collected=true;
        GAME.stealth = Math.min(100,GAME.stealth+8);
        showFloatingText('ITEM: ' + it.type.toUpperCase());
        if(it.type === 'keycard'){ GAME.hasKey = true; saveState(); showFloatingText('Keycard を入手しました'); }
      }
    }
    // vault proximity hint
    if(currentMap.vault && !GAME.vaultOpen && dist(Player.x,Player.y,currentMap.vault.x,currentMap.vault.y) < 1.6){
      // placeholder: later parts implement hacking
      // we leave a gentle floating hint when close
      // but do not auto-run anything here
    }
  }
  alarmEl.textContent = Math.floor(GAME.alarm);
  stealthEl.textContent = Math.floor(GAME.stealth);
  moneyEl.textContent = '¥' + GAME.money.toLocaleString();
  // draw basic GL if available
  renderGL();
  if(currentMap) drawHUD(currentMap);
  requestAnimationFrame(minimalTick);
}
requestAnimationFrame(minimalTick);

/* =========================
   GL render (defensive)
   ========================= */
function renderGL(){
  if(!gl || !glProg) return;
  try{
    gl.viewport(0,0,glCanvas.width,glCanvas.height);
    gl.clearColor(0.02,0.04,0.06,1); gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(glProg.prog);
    gl.uniform1f(glProg.timeLoc, nowMs()/1000);
    gl.uniform2f(glProg.resLoc, glCanvas.width/glCanvas.height, glCanvas.height/glCanvas.height);
    gl.uniform1f(glProg.openLoc, GAME.vaultOpen ? 1.0 : 0.0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }catch(e){}
}

/* =========================
   Modal helper (safe; Parts 2/3 may provide richer modal)
   - Expose showModal globally to avoid ReferenceErrors when other parts call it.
   ========================= */
const modalRoot = document.createElement('div'); modalRoot.style.position='fixed'; modalRoot.style.left='50%'; modalRoot.style.top='50%'; modalRoot.style.transform='translate(-50%,-50%)'; modalRoot.style.zIndex='300'; modalRoot.style.display='none'; document.body.appendChild(modalRoot);
function showModal(title, text, onClose){
  try{
    modalRoot.innerHTML = '';
    modalRoot.style.display = 'block';
    const wrap = document.createElement('div'); wrap.style.background='linear-gradient(180deg,#041014,#061720)'; wrap.style.padding='16px'; wrap.style.borderRadius='12px'; wrap.style.minWidth='260px'; wrap.style.boxShadow='0 20px 60px rgba(0,0,0,0.6)'; wrap.style.color='#dff';
    const t = document.createElement('div'); t.style.fontWeight='900'; t.style.fontSize='18px'; t.textContent = title;
    const d = document.createElement('div'); d.style.marginTop='6px'; d.style.color='#bfe'; d.textContent = text;
    const btn = document.createElement('button'); btn.className='btn small'; btn.style.marginTop='12px'; btn.textContent='OK';
    btn.addEventListener('click', ()=>{ modalRoot.style.display='none'; if(onClose) onClose(); });
    wrap.appendChild(t); wrap.appendChild(d); wrap.appendChild(btn);
    modalRoot.appendChild(wrap);
  }catch(e){}
}
window.showModal = window.showModal || showModal;

/* =========================
   Open Dial Hack stub
   - Part3 will override startDialHack; provide a safe fallback to avoid exceptions.
   ========================= */
function openDialHack(){
  if(!currentMap || !currentMap.vault) { showFloatingText('金庫が見つかりません'); return false; }
  if(dist(Player.x,Player.y,currentMap.vault.x,currentMap.vault.y) > 1.6){ showFloatingText('金庫の近くで実行してください'); return false; }
  if(typeof window.startDialHack === 'function' && window.startDialHack !== startDialHackStub){
    return window.startDialHack(currentMap);
  }
  showFloatingText('ダイヤルハックはまだ未実装 (Part3 を統合してください)');
  return false;
}
function startDialHackStub(){ showFloatingText('ダイヤルハック未実装'); return Promise.resolve({success:false}); }
window.startDialHack = window.startDialHack || startDialHackStub;

/* =========================
   Toggle GL button behavior (fix non-responsiveness)
   ========================= */
let glVisible = true;
toggleGLBtn.addEventListener('click', ()=>{
  glVisible = !glVisible;
  if(glVisible){ glCanvas.style.height = ''; glCanvas.style.opacity='1'; }
  else { glCanvas.style.height = '44px'; glCanvas.style.opacity='0.06'; }
});

/* =========================
   Stage selector population
   ========================= */
function toYenRange(r){ return '¥' + Math.round(r[0]/10000) + '万〜¥' + Math.round(r[1]/10000) + '万'; }
function populateStageList(){
  stageListEl.innerHTML = '';
  for(const s of STAGES){
    const card = document.createElement('div'); card.className='stageCard';
    card.innerHTML = `<h3>${s.name} <span style="font-weight:700;color:var(--muted);font-size:12px">Lv.${s.difficulty}</span></h3>
                      <p>${s.desc}</p>
                      <div style="display:flex;justify-content:space-between;margin-top:8px;align-items:center">
                        <div style="font-size:12px;color:var(--muted)">報酬目安: ${toYenRange(s.reward)}</div>
                        <button class="btn select small">PLAY</button>
                      </div>`;
    const btn = card.querySelector('.select');
    btn.addEventListener('click', ()=> {
      stageSelectEl.style.display = 'none';
      startStage(s);
    });
    stageListEl.appendChild(card);
  }
}
populateStageList();

openStageBtn.addEventListener('click', ()=> { stageSelectEl.style.display = 'block'; });
closeStageBtn.addEventListener('click', ()=> { stageSelectEl.style.display = 'none'; });

/* =========================
   UI init & small helpers
   ========================= */
function initUI(){
  moneyShop.textContent = '¥' + GAME.money.toLocaleString();
  renderShopGrid();
  renderInventory();
  currentPreviewWeaponId = WEAPONS[0].id;
  setPreviewWeapon(currentPreviewWeaponId);

  // show stage select at load to encourage testing
  stageSelectEl.style.display = 'block';

  hintBtn.addEventListener('click', ()=> {
    if(!currentMap) showFloatingText('ステージを選択してください');
    else if(currentMap.vault) {
      const d = dist(Player.x,Player.y,currentMap.vault.x,currentMap.vault.y);
      showFloatingText(d < 2 ? '金庫の近くです。Hキーでハック開始 (Part3)' : '金庫に近づいてください');
    }
  });

  restartBtn.addEventListener('click', ()=> { if(GAME.currentStage) startStage(GAME.currentStage); });

  // PvC modal hookup: open and render list
  openPvcBtn.addEventListener('click', ()=>{
    renderPvCWeaponList();
    pvcModal.style.display = 'block';
  });
  closePvcBtn.addEventListener('click', ()=> { pvcModal.style.display = 'none'; });

  startPvcBtn.addEventListener('click', ()=>{
    // attempt to start PvC via global startPvC if present
    if(typeof window.startPvC === 'function'){
      // choose weapon (selected in modal or equipped)
      let wid = window.pvcSelectedWeaponId || (GAME.equipped && GAME.equipped.weaponId);
      if(!wid && Array.isArray(GAME.inventory) && GAME.inventory.length>0){
        wid = GAME.inventory[0];
        GAME.equipped = {weaponId: wid, skinId: (GAME.skinsOwned && GAME.skinsOwned[wid] && GAME.skinsOwned[wid][0]) || null};
        saveState();
        renderInventory();
        showFloatingText('所持武器を自動で装備しました');
      }
      if(!wid){
        showModal && showModal('武器が必要', 'PvC を開始するには武器を装備してください。ショップで購入し、装備してください。', ()=>{});
        return;
      }
      const aiLevel = parseInt(aiLevelSel.value,10) || 3;
      pvcModal.style.display = 'none';
      showFloatingText(`PvC を開始します — AI Level ${aiLevel}`);
      try{
        window.startPvC({weapon: wid, skin: (GAME.equipped && GAME.equipped.skinId) || null, aiLevel});
      } catch(e){
        showFloatingText('PvC 実装がまだ読み込まれていません (Part2 を統合してください)');
      }
    } else {
      showFloatingText('PvC 実装がまだ読み込まれていません (Part2 を統合してください)');
    }
  });
}
initUI();

/* =========================
   Export debug & integration hooks
   - Parts 2/3/4 will rely on these being available.
   ========================= */
window._vh = {
  GAME, WEAPONS, startStage, openShopModal, buyWeapon, equipWeapon, buySkin, setMoney, saveState, renderPvCWeaponList, renderInventory, Player, generateStageMap
};

// small debug console log
console.log('Part1 (revised) loaded: robust shop, weapons x20, map gen, PvC modal wiring, GL controls, fallbacks.');

</script>
<!-- Part2 — 改訂版 (メインループ、強化ガードAI、アラーム/ステルス安定化、GL制御) -->
<script>
/*
  Part2 Revised — 長く・考え抜かれた実装
  目的:
    - 安定したメインループ（dt 安全処理）
    - ガードAIを強化（明確な state: patrol/investigate/chase、ルート通過）
    - アラーム/ステルスの増減を物理的に安定させる
    - GL のトグルが確実に動作するよう修正
    - PvC / ハック等のフックを壊さない防御的設計
    - 高額銀行（報酬が一定以上）の「マップ端で拡張」フックを提供
  前提:
    - Part1（GAME, Player, WEAPONS, startDialHack の stub 等）が既に読み込まれている前提で書く。
    - ただし未定義の関数は呼ぶ前に存在チェックを行う（ReferenceError を避ける）。
*/

(function(){
  // defensive global presence
  if(typeof window.GAME === 'undefined' || typeof window.Player === 'undefined'){
    console.warn('Part2: GAME / Player が見つかりません。Part1 が読み込まれていることを確認してください。Part2 はできる限り防御的に動作します。');
  }

  // shorthand
  const GAME = window.GAME || { running:false };
  const Player = window.Player || { x:2.5, y:2.5, speed:2.4, _vx:0, _vy:0 };
  const WEAPONS = window.WEAPONS || [];

  // 状態量とパラメータ（チューニングしやすいように上部にまとめる）
  const PARAM = {
    maxDt: 0.06,                // 1フレームの最大 dt
    stealthRecoverRate: 6.0,    // 秒当たり回復(非被探知時)
    stealthDrainPerGuard: 18.0, // 見つかった時の秒当たり減少
    alarmRecoverRate: 6.0,      // 秒当たりアラーム減少（安全時）
    alarmGainOnSpot: 40.0,      // レーザー接触など重大イベントでの増加/秒
    guardBaseSpeed: 0.9,        // ガード基礎速度 (map 単位)
    guardChaseMultiplier: 1.9,  // 追跡時の速度倍率
    guardInvestigateTime: 4.0,  // 調査状態が持続する秒数
    playerBaseSpeed: 1.8,       // 既存 Player.speed を上書き/基準にする（部位）
    stealthDistanceRadius: 3.2, // ガードがプレイヤーを検知する基準距離 (map 単位)
    highRewardThreshold: 10000000, // 1000万超と判定する閾値
    edgeMargin: 0.9,            // マップ端に近いと見なす閾値（セル単位）
  };

  // 内部 state
  let lastFrame = performance.now();
  let glVisible = true; // GL 表示状態の追跡（Part1 の toggle と連動）
  // guard detection helpers
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function nowSec(){ return performance.now()/1000; }
  function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }

  /* -------------------------
     ガード AI — updateGuardsEnhanced
     各ガードは g.state を持つ:
       - 'patrol' (pts を辿る)
       - 'investigate' (最後に見た位置へ移動して周囲を探索)
       - 'chase' (プレイヤーを追跡)
     その他: g._baseSpeed, g._stateTimer, g._target (for investigate)
     -------------------------*/
  function updateGuardsEnhanced(map, dt){
    if(!map || !map.entities || !Array.isArray(map.entities.guards)) return;
    // defensive init
    for(const g of map.entities.guards){
      if(!g._baseSpeed) g._baseSpeed = (g.speed || PARAM.guardBaseSpeed);
      if(!g.pts || g.pts.length < 2){
        // make a simple 2-point patrol if not provided
        const gx = Math.floor(g.x) || 2;
        const gy = Math.floor(g.y) || 2;
        g.pts = [{x:gx,y:gy},{x:clamp(gx+Math.max(2, Math.floor(map.cols/6)),1,map.cols-2), y:gy}];
      }
      if(!g.state) g.state = 'patrol';
      if(typeof g._stateTimer !== 'number') g._stateTimer = 0;
      if(typeof g._patrolIdx !== 'number') g._patrolIdx = 0;
    }

    // helper: line-of-sight simple (no obstacles considered for performance) - improved later
    function guardCanSeePlayer(g){
      // distance check
      const d = dist(g.x, g.y, Player.x, Player.y);
      if(d > PARAM.stealthDistanceRadius * (1 + (1 - GAME.stealth/100))) return false;
      // facing / cone: if guard has dir property, use it to narrow detection
      if(typeof g.dir === 'number'){
        const dirVecX = Math.cos(g.dir), dirVecY = Math.sin(g.dir);
        const toPx = Player.x - g.x, toPy = Player.y - g.y;
        const toLen = Math.hypot(toPx,toPy) || 1;
        const nx = toPx/toLen, ny = toPy/toLen;
        const dot = nx*dirVecX + ny*dirVecY;
        if(dot < 0.25) return false; // fairly wide cone
      }
      // if player is very stealthy (high stealth), harder to detect
      const stealthFactor = GAME.stealth / 100;
      // random jitter to avoid deterministic perfect detection
      if(Math.random() < 0.06 * (1 - stealthFactor)) return true;
      if(d < 1.2) return true;
      // otherwise borderline: return true if player low stealth
      return (GAME.stealth < 40) && (d < PARAM.stealthDistanceRadius * 1.4);
    }

    // update each guard
    for(const g of map.entities.guards){
      // update timers
      g._stateTimer = Math.max(0, (g._stateTimer || 0) - dt);

      // perception
      const sees = guardCanSeePlayer(g);

      // state transitions
      if(sees){
        // escalate to chase immediately
        if(g.state !== 'chase'){
          g.state = 'chase';
          g._stateTimer = 6.0; // chase minimum duration
        }
      } else {
        // if was chasing and loses sight, go investigate
        if(g.state === 'chase' && g._stateTimer <= 0){
          g.state = 'investigate';
          g._stateTimer = PARAM.guardInvestigateTime;
          g._target = { x: Player.x, y: Player.y }; // last seen pos
        }
        // if investigating times out, resume patrol
        if(g.state === 'investigate' && g._stateTimer <= 0){
          g.state = 'patrol';
          g._target = null;
        }
      }

      // act based on state
      if(g.state === 'patrol'){
        // move toward current patrol point
        const idx = g._patrolIdx % g.pts.length;
        const tgt = g.pts[idx];
        const vx = tgt.x - g.x, vy = tgt.y - g.y;
        const d = Math.hypot(vx,vy) || 1;
        const ux = vx/d, uy = vy/d;
        const sp = g._baseSpeed;
        g.x += ux * sp * dt;
        g.y += uy * sp * dt;
        // rotate dir for detection cone
        g.dir = Math.atan2(uy, ux);
        if(d < 0.35) { g._patrolIdx++; }
        // minor passive alarm decay handled elsewhere
      } else if(g.state === 'investigate'){
        // move to investigation target more quickly but not full chase
        if(g._target){
          const vx = g._target.x - g.x, vy = g._target.y - g.y;
          const d = Math.hypot(vx,vy) || 1;
          const ux = vx/d, uy = vy/d;
          const sp = g._baseSpeed * 1.1;
          g.x += ux * sp * dt;
          g.y += uy * sp * dt;
          g.dir = Math.atan2(uy, ux);
        } else {
          g.state = 'patrol';
        }
      } else if(g.state === 'chase'){
        // direct pursuit: higher speed, increases alarm quickly
        const vx = Player.x - g.x, vy = Player.y - g.y;
        const d = Math.hypot(vx,vy) || 1;
        const ux = vx/d, uy = vy/d;
        const sp = g._baseSpeed * PARAM.guardChaseMultiplier;
        g.x += ux * sp * dt;
        g.y += uy * sp * dt;
        g.dir = Math.atan2(uy, ux);
        // when very close, raise alarm and reduce player stealth rapidly
        if(d < 1.8){
          GAME.alarm = Math.min(100, GAME.alarm + PARAM.alarmGainOnSpot * dt);
          GAME.stealth = Math.max(0, GAME.stealth - PARAM.stealthDrainPerGuard * dt);
        } else {
          // still raise alarm but less
          GAME.alarm = Math.min(100, GAME.alarm + (PARAM.alarmGainOnSpot*0.4) * dt);
        }
      }

      // keep guard inside bounds
      if(map && map.inBounds){
        g.x = clamp(g.x, 0.5, map.cols-0.5);
        g.y = clamp(g.y, 0.5, map.rows-0.5);
      }
    } // end for guards
  } // end updateGuardsEnhanced

  // Expose to global so other parts can call enhanced updater
  window.updateGuardsEnhanced = updateGuardsEnhanced;
  // Also patch global updateGuards if present (defensive)
  if(typeof window.updateGuards === 'function'){
    // keep original
    window.updateGuardsOriginal = window.updateGuardsOriginal || window.updateGuards;
    window.updateGuards = function(map, dt, aggressive){
      // call enhanced if available
      try{
        updateGuardsEnhanced(map, dt);
      } catch(e){
        // fallback to original
        try{ window.updateGuardsOriginal(map, dt, aggressive); } catch(err){}
      }
    };
  } else {
    // define global updateGuards
    window.updateGuards = updateGuardsEnhanced;
  }

  /* -------------------------
     レーザー判定
     (Part1 と互換するよう安全に定義)
     -------------------------*/
  function checkLaserHit(L, player){
    // L: {x,y,dir,len,thickness}
    if(!L || !player) return false;
    const angle = L._angle || L.dir;
    const dx = Math.cos(angle), dy = Math.sin(angle);
    const cx = L.x, cy = L.y;
    const vx = player.x - cx, vy = player.y - cy;
    const proj = vx*dx + vy*dy;
    if(proj < -L.len/2 || proj > L.len/2) return false;
    const distToLine = Math.abs(vx*dy - vy*dx);
    return distToLine < ((L.thickness || 0.08) + (player.r || 0.35));
  }

  /* -------------------------
     メイン tick（高度版）
     - movement, collision, guard update, laser checks
     - アラーム / ステルスの安定化フィルタを適用
     -------------------------*/
  // keep a reference to Part1's currentMap if any
  let currentMap = window.currentMap || null;

  function gameTick(){
    const tnow = performance.now();
    let dt = Math.min(PARAM.maxDt, (tnow - lastFrame) / 1000);
    // clamp dt for browser tab pauses
    if(dt <= 0) dt = 0.001;
    lastFrame = tnow;

    // sync currentMap from global if changed
    currentMap = window.currentMap || currentMap;

    if(GAME.running && currentMap){
      GAME.elapsed += dt;

      // --- player input and movement ---
      // reuse Part1's getInputVector if exists, otherwise fallback to keyboard
      const iv = (typeof getInputVector === 'function') ? getInputVector() : {x:0,y:0};
      // dynamic speed modifier: slower when stealth low? But requirement is overall slower,
      // so use base parameter. Multiply small factor for stealth penalty when high alarm.
      const alarmFactor = 1 - clamp(GAME.alarm/200, 0, 0.5); // alarm high slightly slows player
      const sp = (Player.speed || PARAM.playerBaseSpeed) * alarmFactor;
      Player._vx = iv.x * sp; Player._vy = iv.y * sp;
      // move with collision detection provided by Part1's Player.move or fallback
      if(typeof Player.move === 'function'){
        Player.move(iv.x, iv.y, dt, currentMap);
      } else {
        const nx = Player.x + iv.x * sp * dt;
        const ny = Player.y + iv.y * sp * dt;
        if(!isBlockedLocal(nx, Player.y, currentMap)) Player.x = clamp(nx, 0.3, currentMap.cols - 0.3);
        if(!isBlockedLocal(Player.x, ny, currentMap)) Player.y = clamp(ny, 0.3, currentMap.rows - 0.3);
      }

      // --- update lasers and apply laser hits ---
      if(currentMap.entities && Array.isArray(currentMap.entities.lasers)){
        for(const L of currentMap.entities.lasers){
          // update angle for rotating lasers
          if(L.pattern === 'rot'){
            L._angle = (L.dir || 0) + ((L.speed || 0.4) * GAME.elapsed);
          } else if(L.pattern === 'pulse'){
            L._angle = (L.dir || 0) + (Math.sin(GAME.elapsed * (L.speed || 1.0)) * 0.4);
          } else {
            L._angle = L.dir || 0;
          }
          // check collision with player
          if(checkLaserHit(L, Player)){
            // if laser contact occurs, increase alarm strongly and reduce stealth
            GAME.alarm = Math.min(100, GAME.alarm + PARAM.alarmGainOnSpot * dt);
            GAME.stealth = Math.max(0, GAME.stealth - (PARAM.stealthDrainPerGuard*0.6) * dt);
          }
        }
      }

      // --- update guards using enhanced AI ---
      try{
        updateGuardsEnhanced(currentMap, dt);
      } catch(e){
        // fallback to older updateGuards if something goes wrong
        try{ if(typeof window.updateGuardsOriginal === 'function') window.updateGuardsOriginal(currentMap, dt, false); }catch(e){}
      }

      // --- items pickup (stable) ---
      if(currentMap.entities && Array.isArray(currentMap.entities.items)){
        for(const it of currentMap.entities.items){
          if(!it.collected && dist(Player.x, Player.y, it.x, it.y) < 0.8){
            it.collected = true;
            GAME.stealth = Math.min(100, GAME.stealth + 8);
            showFloatingText && showFloatingText('ITEM: ' + (it.type || 'item').toUpperCase());
            if(it.type === 'keycard'){ GAME.hasKey = true; saveState && saveState(); showFloatingText && showFloatingText('Keycard を入手しました'); }
          }
        }
      }

      // --- vault proximity: hook for hack UI ---
      if(currentMap.vault && !GAME.vaultOpen){
        const d = dist(Player.x, Player.y, currentMap.vault.x, currentMap.vault.y);
        if(d < 1.6){
          // subtle UI hint handled elsewhere; but we keep a gentle floating hint throttle
          if(!Player._vaultHintSince || (performance.now() - Player._vaultHintSince) > 1500){
            Player._vaultHintSince = performance.now();
            // showFloatingText might be defined in Part1
            (typeof showFloatingText === 'function') && showFloatingText('金庫に近づきました — Hキーでハック (Part3)');
          }
        }
      }

      // --- alarm & stealth passive dynamics ---
      // if no immediate threats (no guards alert and no laser hits), slowly recover stealth and reduce alarm
      // detect threats: any guard with state 'chase' or lasers hitting
      let threat = false;
      if(currentMap.entities && Array.isArray(currentMap.entities.guards)){
        for(const g of currentMap.entities.guards){ if(g.state === 'chase' || g.alert) { threat = true; break; } }
      }
      if(currentMap.entities && Array.isArray(currentMap.entities.lasers)){
        for(const L of currentMap.entities.lasers){ if(checkLaserHit(L, Player)){ threat = true; break; } }
      }
      if(!threat){
        // recover
        GAME.stealth = Math.min(100, GAME.stealth + PARAM.stealthRecoverRate * dt);
        GAME.alarm = Math.max(0, GAME.alarm - PARAM.alarmRecoverRate * dt);
      } else {
        // if threat exists, maybe reduce stealth slowly (already handled by guard logic)
        GAME.stealth = Math.max(0, GAME.stealth - (PARAM.stealthDrainPerGuard * 0.15) * dt);
      }

      // clamp extremes
      GAME.alarm = Math.min(100, Math.max(0, GAME.alarm));
      GAME.stealth = clamp(GAME.stealth, 0, 100);

      // --- special: high-reward bank auto-extend when reaching map edge ---
      // If current stage reward high and player reaches near edge, create/trigger extension map.
      try{
        const stage = GAME.currentStage || (currentMap && currentMap.stageId ? currentMap.stageId : null);
        const stageObj = (Array.isArray(window.STAGES) ? window.STAGES.find(s=>s.id===stage) : null) || window.STAGES && window.STAGES[0];
        if(stageObj && (stageObj.reward && stageObj.reward[1] > PARAM.highRewardThreshold)){
          // if player at edge
          if(Player.x < PARAM.edgeMargin || Player.x > (currentMap.cols - PARAM.edgeMargin) || Player.y < PARAM.edgeMargin || Player.y > (currentMap.rows - PARAM.edgeMargin)){
            // call hook if provided (Part1/Part4 may implement nicer transition)
            if(typeof window.handleHighTierMapExtension === 'function'){
              // call once only per entrance (throttle)
              if(!currentMap._extensionTriggered){
                currentMap._extensionTriggered = true;
                window.handleHighTierMapExtension && window.handleHighTierMapExtension(currentMap, stageObj);
              }
            } else {
              // default: show hint
              if(!currentMap._extensionWarned){
                currentMap._extensionWarned = true;
                showFloatingText && showFloatingText('警告: このステージはさらに深いコアエリアがあります（Part2 が自動遷移をサポート）');
              }
            }
          }
        }
      }catch(e){ /* ignore */ }

      // end of GAME.running branch
    } // end if running

    // update UI
    alarmEl.textContent = Math.floor(GAME.alarm);
    stealthEl.textContent = Math.floor(GAME.stealth);
    moneyEl.textContent = '¥' + (GAME.money || 0).toLocaleString();

    // render GL and HUD
    renderGL();
    if(window.currentMap) drawHUD && typeof drawHUD === 'function' && drawHUD(window.currentMap);

    // schedule next
    requestAnimationFrame(gameTick);
  } // end gameTick

  // start the improved tick only if Part2 not already started
  if(!window._vh_part2_started){
    lastFrame = performance.now();
    requestAnimationFrame(gameTick);
    window._vh_part2_started = true;
  }

  /* -------------------------
     Helper: isBlockedLocal (fallback simple cell check)
     -------------------------*/
  function isBlockedLocal(x, y, map){
    if(!map || !map.inBounds) return false;
    const cx = Math.floor(x), cy = Math.floor(y);
    if(!map.inBounds(cx, cy)) return true;
    return map.cells[cy][cx] === 1;
  }

  /* -------------------------
     renderGL override / improved safety (Part1 has gl/glProg)
     -------------------------*/
  function renderGL(){
    // If Part1 defined gl and glProg, use it. Otherwise skip.
    try{
      const g = window.gl || window.g || null;
      const gp = window.glProg || window.gp || null;
      const canvas = document.getElementById && document.getElementById('glview');
      if(!canvas) return;
      // If Part1 provided gl object in outer scope, prefer that, else use our local attempt
      const glObj = window.gl || (window._vh && window._vh.gl) || null;
      const glp = window.glProg || (window._vh && window._vh.glProg) || null;
      if(glObj && glp){
        // try update uniforms
        try{
          glObj.viewport(0,0,canvas.width,canvas.height);
          glObj.clearColor(0.02,0.04,0.06,1); glObj.clear(glObj.COLOR_BUFFER_BIT);
          glObj.useProgram(glp.prog);
          if(glp.timeLoc) glObj.uniform1f(glp.timeLoc, performance.now()/1000);
          if(glp.resLoc) glObj.uniform2f(glp.resLoc, canvas.width/canvas.height, canvas.height/canvas.height);
          if(glp.openLoc) glObj.uniform1f(glp.openLoc, (GAME.vaultOpen ? 1.0 : 0.0));
          glObj.drawArrays(glObj.TRIANGLE_STRIP, 0, 4);
        }catch(e){ /* swallow GL errors */ }
      } else {
        // fallback: draw subtle gradient background on canvas if no WebGL available
        if(canvas && canvas.getContext){
          const c2 = canvas.getContext('2d');
          if(c2){
            const w = canvas.width / (devicePixelRatio||1), h = canvas.height / (devicePixelRatio||1);
            c2.clearRect(0,0,canvas.width,canvas.height);
            const g2 = c2.createLinearGradient(0,0,0,h);
            g2.addColorStop(0,'#021018'); g2.addColorStop(1,'#071827');
            c2.fillStyle = g2; c2.fillRect(0,0,w,h);
          }
        }
      }
    } catch(e){}
  }

  // hook GL toggle button if present (fix previous non-responsiveness)
  try{
    const toggleBtn = document.getElementById && document.getElementById('toggleGL');
    if(toggleBtn){
      toggleBtn.removeEventListener && toggleBtn.removeEventListener('click', ()=>{}); // safe remove
      toggleBtn.addEventListener('click', ()=>{
        glVisible = !glVisible;
        const can = document.getElementById('glview');
        if(can){
          if(glVisible){ can.style.opacity = '1'; can.style.height = ''; }
          else { can.style.opacity = '0.06'; can.style.height = '44px'; }
        }
      });
    }
  } catch(e){ /* ignore */ }

  /* -------------------------
     PvC / other integration stubs
     - if Part3/Part4 provide startPvC/startDialHack, they will override these
     -------------------------*/
  if(typeof window.startPvC !== 'function'){
    window.startPvC = function(params){
      console.warn('startPvC 未実装：Part3 を読み込んでください。', params);
      showFloatingText && showFloatingText('PvC 実装が未ロードです (Part3 を統合してください)');
      return false;
    };
  }

  // expose enhanced functions for other parts
  window._vh = window._vh || {};
  window._vh.updateGuardsEnhanced = updateGuardsEnhanced;
  window._vh.checkLaserHit = checkLaserHit;

  // debug log
  console.log('Part2 (revised) loaded — main tick + enhanced guard AI + alarm/stealth stabilization ready.');

})();
</script>
<!-- Part3 — 改訂版（ダイヤルハック：見た目強化・音声制御・ガードエスカレーション・エスケープサブマップ） -->
<script>
/*
  Part3 Revised — 大幅拡張版
  目的:
    - ダイヤル式ハック UI をより堅牢かつスタイリッシュに実装
    - showModal が未定義でも動くようフォールバックを提供して ReferenceError を回避
    - 音は「最大3音」ルールで鳴らす（短いシーケンス or コード感）
    - 視覚的な「違和感（グリッチ）」を局所的に発生させる演出
    - ガードの段階的接近（updateGuards と協調）＋エスケープサブマップ処理
    - 高価銀行（報酬1000万以上）でのマップ拡張フックとレーザー増強
    - startDialHack をグローバルに公開、Promise を返す
  備考:
    - 他パート（Part1/2/4）と協調するため defensive に動作します。
*/

(function(){

  // ----------------------------
  // 必須グローバルの確認とフォールバック
  // ----------------------------
  const HAS = {
    GAME: typeof window.GAME !== 'undefined',
    Player: typeof window.Player !== 'undefined',
    STAGES: typeof window.STAGES !== 'undefined',
    updateGuards: typeof window.updateGuards === 'function',
    setMoney: typeof window.setMoney === 'function',
    saveState: typeof window.saveState === 'function'
  };

  // safe helpers local
  const noop = ()=>{};
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const rand = (a,b)=> a + Math.random()*(b-a);
  const nowSec = ()=> performance.now()/1000;
  const deviceDPR = window.devicePixelRatio || 1;
  function distLocal(ax,ay,bx,by){ return Math.hypot((ax||0)-(bx||0), (ay||0)-(by||0)); }

  // provide safe showFloatingText if missing (small transient toast)
  if(typeof window.showFloatingText !== 'function'){
    window.showFloatingText = function(txt){
      try{
        const el = document.createElement('div');
        el.style.position = 'fixed';
        el.style.left = '50%';
        el.style.top = '14%';
        el.style.transform = 'translateX(-50%)';
        el.style.zIndex = 14000;
        el.style.background = 'linear-gradient(180deg, rgba(6,10,12,0.92), rgba(4,6,8,0.92))';
        el.style.padding = '10px 14px';
        el.style.borderRadius = '10px';
        el.style.color = '#dff';
        el.style.fontWeight = '900';
        el.style.boxShadow = '0 10px 30px rgba(0,0,0,0.6)';
        el.textContent = txt || '';
        document.body.appendChild(el);
        setTimeout(()=>{ el.style.transition = 'all 0.8s ease'; el.style.opacity = '0'; el.style.transform = 'translate(-50%,-10px)'; }, 900);
        setTimeout(()=> el.remove(), 1800);
      }catch(e){}
    };
  }

  // provide safe showModal if missing (simple modal)
  if(typeof window.showModal !== 'function'){
    window.showModal = function(title, text, onClose){
      try{
        const root = document.createElement('div');
        root.style.position = 'fixed';
        root.style.left = '50%'; root.style.top = '50%';
        root.style.transform = 'translate(-50%,-50%)';
        root.style.zIndex = 16000;
        root.style.background = 'linear-gradient(180deg,#041016,#061720)';
        root.style.padding = '16px'; root.style.borderRadius = '12px'; root.style.color = '#dff';
        root.style.boxShadow = '0 30px 90px rgba(0,0,0,0.7)';
        const t = document.createElement('div'); t.style.fontWeight='900'; t.style.fontSize='18px'; t.textContent = title || 'Notice';
        const d = document.createElement('div'); d.style.marginTop='8px'; d.style.color = '#bfe'; d.textContent = text || '';
        const b = document.createElement('button'); b.className = 'btn small'; b.style.marginTop = '12px'; b.textContent = 'OK';
        b.addEventListener('click', ()=>{ root.remove(); try{ if(typeof onClose === 'function') onClose(); } catch(e){} });
        root.appendChild(t); root.appendChild(d); root.appendChild(b);
        document.body.appendChild(root);
      }catch(e){}
    };
  }

  // ----------------------------
  // 設定
  // ----------------------------
  const CONFIG = {
    DIGITS_BY_STAGE: { conbini:3, bank:4, casino:4, nichigin:5, world_bank:5, earth_bank:6, galactic_bank:6, galaxy_bank:7, space_bank:7 },
    BASE_TIME: 28, // base seconds (internal will multiply)
    TIME_MULTIPLIER: 3, // internal time = BASE_TIME * TIME_MULTIPLIER (旧time*3)
    GLITCH_INTENSITY: 0.12,
    SOUND_VOLUME: 0.08,
    MAX_TONES_PER_EVENT: 3, // 音は最大3つまで鳴らす（ユーザーの要望）
    ESCAPE_MAP_SETTINGS: { cols:10, rows:8, lasers:6, guards:3, cell:48 }
  };

  // ----------------------------
  // オーディオユーティリティ（Oscillator）: 最大3トーンを扱えるように直列/同時に鳴らす
  // ----------------------------
  const AudioCtxClass = window.AudioContext || window.webkitAudioContext || null;
  let _audioCtx = null;
  function ensureAudio(){
    try{
      if(!AudioCtxClass) return null;
      if(!_audioCtx) _audioCtx = new AudioCtxClass();
      return _audioCtx;
    }catch(e){ return null; }
  }
  // playToneSequence: tones は [{freq,dur,type,delay}] の配列。最大長は CONFIG.MAX_TONES_PER_EVENT に制限される。
  function playToneSequence(tones){
    const ctx = ensureAudio();
    if(!ctx) return;
    const limited = tones.slice(0, CONFIG.MAX_TONES_PER_EVENT);
    const start = ctx.currentTime + 0.01;
    limited.forEach((t, i) => {
      try{
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = t.type || 'sine';
        o.frequency.value = t.freq || 440;
        g.gain.value = (typeof t.vol !== 'undefined') ? t.vol : CONFIG.SOUND_VOLUME;
        o.connect(g); g.connect(ctx.destination);
        const s = start + (t.delay || 0);
        o.start(s);
        o.stop(s + (t.dur || 0.06));
      }catch(e){}
    });
  }

  // 簡易ワンショット beep（互換）
  function playBeep(freq=520, dur=0.06, type='sine', vol=CONFIG.SOUND_VOLUME, delay=0){
    playToneSequence([{ freq, dur, type, delay, vol }]);
  }

  // ----------------------------
  // キー確認ヘルパー
  // ----------------------------
  function hasKeyForMap(map){
    try{
      if(window.GAME && window.GAME.hasKey) return true;
      if(!map) return false;
      if(map.entities && Array.isArray(map.entities.items)){
        for(const it of map.entities.items){
          if((it.type === 'keycard' || it.type === 'key') && it.collected) {
            if(window.GAME) { window.GAME.hasKey = true; if(window.saveState) window.saveState(); }
            return true;
          }
        }
      }
    }catch(e){}
    return false;
  }

  // ----------------------------
  // 報酬付与（賞金） — Part1 と整合させる
  // ----------------------------
  function awardVault(stageObj, map){
    try{
      const s = stageObj || (Array.isArray(window.STAGES) ? window.STAGES[0] : null);
      if(!s) return 0;
      const [minR, maxR] = s.reward || [10000, 50000];
      let rnd = Math.floor(rand(minR, maxR+1));
      // key bonus
      if(hasKeyForMap(map)) rnd += Math.floor(rnd * 0.06);
      if(window.setMoney) {
        // setMoney expects absolute assignment; call with current + rnd if available
        if(window.GAME && typeof window.GAME.money === 'number') window.setMoney(window.GAME.money + rnd);
        else window.setMoney((window.GAME && window.GAME.money) ? window.GAME.money + rnd : rnd);
      } else {
        if(window.GAME) window.GAME.money = (window.GAME.money || 0) + rnd;
      }
      if(window.saveState) window.saveState();
      // visible modal
      if(window.showModal) window.showModal('VAULT OPENED', `金庫を解除！ 獲得 ${'¥' + rnd.toLocaleString()}`, ()=>{});
      return rnd;
    }catch(e){
      console.warn('awardVault error', e);
      return 0;
    }
  }

  // ----------------------------
  // エスケープサブマップ生成（レーザーとガードが増強された小マップ）
  // ----------------------------
  function createEscapeMap(origStageId){
    const cfg = CONFIG.ESCAPE_MAP_SETTINGS;
    // MapGrid 互換オブジェクト（簡易）
    const tmp = {
      cols: cfg.cols,
      rows: cfg.rows,
      cell: cfg.cell,
      cells: new Array(cfg.rows),
      entities: { guards: [], lasers: [], items: [] },
      vault: null,
      vaultOpened: false,
      stageId: origStageId ? (origStageId + '_escape') : 'escape_stage'
    };
    for(let r=0;r<cfg.rows;r++) tmp.cells[r] = new Array(cfg.cols).fill(0);
    // perimeter walls
    for(let x=0;x<cfg.cols;x++){ tmp.cells[0][x]=1; tmp.cells[cfg.rows-1][x]=1; }
    for(let y=0;y<cfg.rows;y++){ tmp.cells[y][0]=1; tmp.cells[y][cfg.cols-1]=1; }
    // lasers
    for(let i=0;i<cfg.lasers;i++){
      const lx = Math.floor(rand(2, cfg.cols-3))+0.5;
      const ly = Math.floor(rand(2, cfg.rows-3))+0.5;
      tmp.entities.lasers.push({ x: lx, y: ly, dir: Math.random()*Math.PI*2, len: Math.floor(rand(3, Math.min(cfg.cols,cfg.rows)-2)), thickness:0.12, pattern:'rot', speed: 0.6 + Math.random()*0.8, phase: Math.random()*Math.PI*2 });
    }
    // guards
    for(let g=0; g<cfg.guards; g++){
      const gx = Math.floor(rand(2, cfg.cols-3))+0.5;
      const gy = Math.floor(rand(2, cfg.rows-3))+0.5;
      tmp.entities.guards.push({ x: gx, y: gy, pts:[{x:gx,y:gy},{x:clamp(Math.floor(gx+2),1,cfg.cols-2),y:gy}], speed: 1.0 + Math.random()*0.8, t:0, dir:1, alert:true });
    }
    // maybe add a key
    if(Math.random() < 0.25) tmp.entities.items.push({ x: Math.floor(cfg.cols/2)+0.2, y: Math.floor(cfg.rows/2)+0.2, type: 'keycard', collected:false });
    return tmp;
  }

  // ----------------------------
  // 視覚的違和感（グリッチ）適用
  // ----------------------------
  let _glitchTimer = null;
  function applyVisualGlitch(ms){
    try{
      const prev = document.body.style.filter || '';
      document.body.style.transition = 'filter 120ms linear';
      document.body.style.filter = `hue-rotate(${rand(-8,8)}deg) blur(${CONFIG.GLITCH_INTENSITY*6}px) saturate(${1+CONFIG.GLITCH_INTENSITY})`;
      if(_glitchTimer) clearTimeout(_glitchTimer);
      _glitchTimer = setTimeout(()=>{ document.body.style.filter = prev; }, ms || 180);
    }catch(e){}
  }

  // ----------------------------
  // ダイヤル UI ビルダー（よりスタイリッシュに）
  // ----------------------------
  function buildDialUI(stageObj, digits){
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.left = '0'; overlay.style.top = '0'; overlay.style.right = '0'; overlay.style.bottom = '0';
    overlay.style.zIndex = 15000;
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.background = 'linear-gradient(180deg, rgba(2,6,8,0.94), rgba(1,10,12,0.96))';
    overlay.style.backdropFilter = 'blur(6px)';

    const panel = document.createElement('div');
    panel.style.width = '94%'; panel.style.maxWidth = '900px';
    panel.style.borderRadius = '14px'; panel.style.padding = '16px';
    panel.style.background = 'linear-gradient(180deg,#021018,#071827)';
    panel.style.boxShadow = '0 30px 100px rgba(0,0,0,0.8)';
    panel.style.color = '#dff';
    overlay.appendChild(panel);

    // header
    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.justifyContent = 'space-between';
    header.style.alignItems = 'center';
    const title = document.createElement('div'); title.style.fontWeight = '900'; title.style.fontSize='18px';
    title.textContent = `${stageObj.name || 'STAGE'} — CLOCK HACK`;
    const money = document.createElement('div'); money.style.fontSize='13px'; money.style.color='rgba(190,220,230,0.8)';
    money.textContent = '所持金 ' + (window.GAME ? ('¥' + (window.GAME.money||0).toLocaleString()) : '¥0');
    header.appendChild(title); header.appendChild(money);
    panel.appendChild(header);

    // main canvas area
    const canvasWrap = document.createElement('div'); canvasWrap.style.display='flex'; canvasWrap.style.justifyContent='center'; canvasWrap.style.alignItems='center'; canvasWrap.style.marginTop='12px';
    const canvas = document.createElement('canvas');
    const size = Math.min(760, Math.max(420, Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.6)));
    canvas.width = size * deviceDPR; canvas.height = size * deviceDPR;
    canvas.style.width = size + 'px'; canvas.style.height = size + 'px';
    canvas.style.borderRadius = '10px';
    canvas.style.touchAction = 'none';
    canvasWrap.appendChild(canvas);
    panel.appendChild(canvasWrap);

    // hint / status
    const hint = document.createElement('div'); hint.style.marginTop='10px'; hint.style.color='rgba(190,220,210,0.78)'; hint.style.fontSize='13px';
    hint.textContent = 'ドラッグで円盤を回して桁を合わせてください。時間表示はありません。';
    panel.appendChild(hint);

    // actions
    const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='flex-end'; row.style.gap='8px'; row.style.marginTop='12px';
    const cancelBtn = document.createElement('button'); cancelBtn.className = 'btn small ghost'; cancelBtn.textContent = 'CANCEL';
    const submitBtn = document.createElement('button'); submitBtn.className = 'btn small'; submitBtn.textContent = 'SUBMIT';
    row.appendChild(cancelBtn); row.appendChild(submitBtn);
    panel.appendChild(row);

    return { overlay, panel, canvas, ctx: canvas.getContext('2d'), hint, cancelBtn, submitBtn };
  }

  // ----------------------------
  // ダイヤルセッション本体
  // ----------------------------
  function startDiskHackSession(map){
    return new Promise((resolve) => {
      // defensive checks
      if(!map || !map.vault){ showFloatingText('金庫が見つかりません'); resolve({success:false}); return; }
      // stage info
      const stageObj = (Array.isArray(window.STAGES) ? window.STAGES.find(s => s.id === map.stageId) : null) || { id: map.stageId || 'stage', name: (map.stageId || 'Stage') };
      const digits = Math.max(3, (CONFIG.DIGITS_BY_STAGE[stageObj.id] || 3) - (hasKeyForMap(map) ? 1 : 0));
      const baseTime = Math.max(10, CONFIG.BASE_TIME - (stageObj.difficulty || 1) * 3);
      const timeLimit = baseTime * CONFIG.TIME_MULTIPLIER; // internal time = old * 3
      // secret code
      const secret = new Array(digits).fill(0).map(()=> Math.floor(Math.random()*10));

      // build UI
      const ui = buildDialUI(stageObj, digits);
      document.body.appendChild(ui.overlay);
      const canvas = ui.canvas;
      const ctx = ui.ctx;
      const W = canvas.width, H = canvas.height;
      const center = { x: W/2, y: H/2 };
      const visualRadius = Math.min(W,H) * 0.36;
      const dialRadius = Math.min(W,H) * 0.11;

      // state
      const state = {
        values: new Array(digits).fill(0).map(()=> Math.floor(Math.random()*10)),
        dragIndex: -1,
        dragStartAngle: 0,
        dragStartValue: 0,
        startTime: nowSec(),
        elapsed: 0,
        inEscape: false,
        exitEscapeFn: null,
        finished: false
      };

      // compute dial center for index i
      function dialCenter(i){
        const ang = -Math.PI/2 + (i * 2 * Math.PI / digits);
        const x = center.x + Math.cos(ang) * visualRadius;
        const y = center.y + Math.sin(ang) * visualRadius;
        return { x, y, ang };
      }

      // draw function (polished visuals)
      function drawAll(){
        // clear high-res canvas
        ctx.clearRect(0,0,W,H);
        // backdrop radial vignette
        const g = ctx.createRadialGradient(center.x, center.y, 1, center.x, center.y, visualRadius*1.5);
        g.addColorStop(0, 'rgba(6,12,16,0.6)');
        g.addColorStop(1, 'rgba(1,4,8,0.95)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(center.x, center.y, visualRadius*1.45, 0, Math.PI*2); ctx.fill();

        // subtle central spinner ring
        ctx.save();
        ctx.translate(center.x, center.y);
        ctx.rotate((nowSec()-state.startTime)*0.15);
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.beginPath(); ctx.arc(0,0,visualRadius*0.86,0,Math.PI*2); ctx.fill();
        ctx.restore();

        // draw each dial
        for(let i=0;i<digits;i++){
          const d = dialCenter(i);
          // shadow
          ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.arc(d.x+6, d.y+8, dialRadius+8, 0, Math.PI*2); ctx.fill();
          // disk
          ctx.beginPath(); ctx.fillStyle = (i===state.dragIndex ? '#0d3b38' : '#08302a'); ctx.arc(d.x, d.y, dialRadius, 0, Math.PI*2); ctx.fill();
          // accent ring
          const ring = ctx.createRadialGradient(d.x, d.y, dialRadius*0.2, d.x, d.y, dialRadius*1.02);
          ring.addColorStop(0, 'rgba(0,220,150,0.06)');
          ring.addColorStop(1, 'rgba(0,0,0,0.0)');
          ctx.fillStyle = ring;
          ctx.beginPath(); ctx.arc(d.x, d.y, dialRadius*1.02, 0, Math.PI*2); ctx.fill();

          // digit
          ctx.fillStyle = '#eafff6';
          ctx.font = `${Math.floor(dialRadius*0.85)}px ${getComputedStyle(document.body).fontFamily}`;
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(String(state.values[i]), d.x, d.y + (deviceDPR>1?2:0));

          // ticks
          for(let t=0;t<10;t++){
            const ta = d.ang + (t/10) * Math.PI*2 * 0.45 - 0.22;
            const rx = d.x + Math.cos(ta) * (dialRadius * 0.75);
            const ry = d.y + Math.sin(ta) * (dialRadius * 0.75);
            ctx.fillStyle = (t === state.values[i]) ? '#ffd86b' : 'rgba(255,255,255,0.04)';
            ctx.beginPath(); ctx.arc(rx, ry, (t===state.values[i]?4:1.4), 0, Math.PI*2); ctx.fill();
          }
        }

        // center hub ornament
        ctx.beginPath(); ctx.fillStyle = '#071f18'; ctx.arc(center.x, center.y, dialRadius*0.94, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.fillStyle = '#043b30'; ctx.arc(center.x, center.y, dialRadius*0.58, 0, Math.PI*2); ctx.fill();

        // subtle progress ring (not showing time numerically, but color hint)
        const progress = clamp(state.elapsed / (timeLimit || 1), 0, 1);
        ctx.beginPath();
        ctx.lineWidth = Math.max(3, dialRadius*0.18);
        ctx.strokeStyle = `rgba(170,255,210,${0.12 + progress*0.28})`;
        ctx.arc(center.x, center.y, visualRadius*1.02, -Math.PI/2, -Math.PI/2 + 2*Math.PI*progress);
        ctx.stroke();

        // small overlay text
        ctx.fillStyle = 'rgba(200,240,230,0.06)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.textAlign = 'center';
        ctx.fillText('Align the digits — no visible countdown', center.x, center.y + visualRadius*1.18);
      } // drawAll

      drawAll();

      // pointer helpers
      function getPointerPos(evt){
        const rect = canvas.getBoundingClientRect();
        const cx = (evt.clientX - rect.left) * deviceDPR;
        const cy = (evt.clientY - rect.top) * deviceDPR;
        return { x: cx, y: cy };
      }
      function getDialUnderPointer(x,y){
        for(let i=0;i<digits;i++){
          const d = dialCenter(i);
          const dd = Math.hypot(d.x - x, d.y - y);
          if(dd <= dialRadius * 1.05) return i;
        }
        return -1;
      }
      function angleForPointer(i, x, y){
        const d = dialCenter(i);
        return Math.atan2(y - d.y, x - d.x);
      }

      // pointer events
      let pointerId = null;
      canvas.addEventListener('pointerdown', (e)=>{
        e.preventDefault();
        const p = getPointerPos(e);
        const di = getDialUnderPointer(p.x, p.y);
        if(di >= 0){
          pointerId = e.pointerId;
          canvas.setPointerCapture && canvas.setPointerCapture(pointerId);
          state.dragIndex = di;
          state.dragStartAngle = angleForPointer(di, p.x, p.y);
          state.dragStartValue = state.values[di];
          // micro-sound feedback (single tone)
          playBeep(620, 0.06, 'sine', 0.06);
        } else {
          // click near center: rotate selection
          // find nearest dial and set selected (visual highlight)
          let nearest = 0, nd = Infinity;
          for(let i=0;i<digits;i++){
            const d = dialCenter(i);
            const dist = Math.hypot(d.x - p.x, d.y - p.y);
            if(dist < nd){ nd = dist; nearest = i; }
          }
          state.dragIndex = nearest;
          drawAll();
        }
      });

      canvas.addEventListener('pointermove', (e)=>{
        if(pointerId !== null && e.pointerId !== pointerId) return;
        if(state.dragIndex < 0) return;
        const p = getPointerPos(e);
        const di = state.dragIndex;
        const angNow = angleForPointer(di, p.x, p.y);
        let delta = angNow - state.dragStartAngle;
        while(delta > Math.PI) delta -= Math.PI*2;
        while(delta < -Math.PI) delta += Math.PI*2;
        const steps = Math.round(delta / (Math.PI*2) * 10);
        let val = (state.dragStartValue + steps) % 10; if(val < 0) val += 10;
        if(val !== state.values[di]){
          state.values[di] = val;
          // feedback based on closeness to secret
          const diff = Math.abs(val - secret[di]);
          // create tone sequence limited to MAX_TONES_PER_EVENT
          const tones = [];
          if(diff === 0){
            // success micro-chord — up to 3 tones (harmonic)
            tones.push({freq: 880, dur:0.06, type:'sine', delay:0, vol:0.12});
            tones.push({freq: 1100, dur:0.06, type:'sine', delay:0.03, vol:0.10});
            tones.push({freq: 1320, dur:0.06, type:'sine', delay:0.06, vol:0.08});
            playToneSequence(tones);
            try{ navigator.vibrate && navigator.vibrate(20); }catch(e){}
          } else if(diff === 1){
            tones.push({freq: 660, dur:0.05, type:'triangle', delay:0, vol:0.09});
            tones.push({freq: 720, dur:0.04, type:'sine', delay:0.04, vol:0.06});
            playToneSequence(tones);
            try{ navigator.vibrate && navigator.vibrate(12); }catch(e){}
          } else {
            tones.push({freq: 420, dur:0.04, type:'sine', delay:0, vol:0.06});
            playToneSequence(tones);
            // occasional glitch for wrong large errors
            if(diff >= 2 && Math.random() < 0.18) applyVisualGlitch(120 + Math.random()*160);
          }
          drawAll();
        }
      });

      canvas.addEventListener('pointerup', (e)=>{
        if(pointerId !== null && e.pointerId !== pointerId) return;
        pointerId = null;
        state.dragIndex = -1;
      });

      // keyboard support (矢印で操作)
      function onKey(e){
        if(state.finished) return;
        if(e.key === 'ArrowLeft'){ state.dragIndex = clamp((state.dragIndex === -1 ? 0 : state.dragIndex) - 1, 0, digits-1); drawAll(); }
        if(e.key === 'ArrowRight'){ state.dragIndex = clamp((state.dragIndex === -1 ? 0 : state.dragIndex) + 1, 0, digits-1); drawAll(); }
        if(e.key === 'ArrowUp'){ state.values[state.dragIndex === -1 ? 0 : state.dragIndex] = (state.values[state.dragIndex === -1 ? 0 : state.dragIndex] + 1) % 10; playBeep(540,0.04,'sine',0.06); drawAll(); }
        if(e.key === 'ArrowDown'){ state.values[state.dragIndex === -1 ? 0 : state.dragIndex] = (state.values[state.dragIndex === -1 ? 0 : state.dragIndex] + 9) % 10; playBeep(440,0.04,'sine',0.06); drawAll(); }
        if(e.key === 'Enter'){ submitAttempt(); }
        if(e.key === 'Escape'){ cancelAttempt(); }
      }
      window.addEventListener('keydown', onKey);

      // tick: guard escalation + edge escape monitoring + time limit
      let lastFrame = performance.now();
      function tick(){
        if(state.finished) return;
        const now = performance.now();
        const dt = Math.min(0.06, (now - lastFrame)/1000);
        lastFrame = now;
        state.elapsed = nowSec() - state.startTime;
        const progress = clamp(state.elapsed / (timeLimit || 1), 0, 1);

        // escalate guards by calling updateGuards with aggressive flag
        try{
          if(typeof window.updateGuards === 'function' && window.currentMap){
            // choose aggressive if progress crosses thresholds
            const aggressive = (progress >= 0.55) || (Math.random() < progress*0.2);
            try{ window.updateGuards(window.currentMap, dt, aggressive); } catch(e){}
          } else if(typeof window.updateGuardsEnhanced === 'function' && window.currentMap){
            // use enhanced if available
            try{ window.updateGuardsEnhanced(window.currentMap, dt); } catch(e){}
          }
        }catch(e){}

        // subtle audio cues based on progress (but not too spammy)
        if(Math.random() < 0.04 + progress*0.12){
          const f = 240 + progress * 900 + Math.random()*60;
          playBeep(f, 0.04, (progress>0.6)?'sawtooth':'sine', 0.04);
        }

        // monitor player position for escape (if they go to map edge)
        try{
          if(!state.inEscape && window.currentMap && window.Player){
            const P = window.Player;
            if(P.x < 0.9 || P.x > (window.currentMap.cols - 0.9) || P.y < 0.9 || P.y > (window.currentMap.rows - 0.9)){
              state.inEscape = true;
              // create submap and teleport player
              state.exitEscapeFn = (function(){
                // store original map & pos
                const origMap = window.currentMap;
                const origPlayerPos = { x: P.x, y: P.y };
                // create escape map and assign
                const sub = createEscapeMap(stageObj.id);
                window.currentMap = sub;
                P.x = Math.floor(sub.cols/2);
                P.y = Math.floor(sub.rows/2);
                window.showFloatingText && window.showFloatingText('特殊領域へワープ — レーザーと警備が増加');
                return function restore(){
                  window.currentMap = origMap;
                  P.x = clamp(origPlayerPos.x, 1, origMap.cols-1);
                  P.y = clamp(origPlayerPos.y, 1, origMap.rows-1);
                  window.showFloatingText && window.showFloatingText('元の地図に復帰しました');
                };
              })();
              applyVisualGlitch(320);
              playBeep(260, 0.12, 'sawtooth', 0.12);
            }
          }
        }catch(e){}

        // final timeout: if elapsed > timeLimit * 1.03 -> trigger failure and alarm
        if(state.elapsed > (timeLimit * 1.03)){
          // final alarm
          if(window.GAME) window.GAME.alarm = Math.min(100, (window.GAME.alarm || 0) + 40);
          applyVisualGlitch(640);
          playBeep(160, 0.24, 'sawtooth', 0.12);
          cleanup(false);
          return;
        }

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);

      // submit attempt
      function submitAttempt(){
        if(state.finished) return;
        const chosen = state.values.slice();
        const diffs = chosen.map((v,i)=> Math.abs(v - secret[i]));
        const allMatch = diffs.every(d=> d===0);

        // produce per-digit short sound pattern (up to 3 tones total)
        let tones = [];
        // Build compact pattern depending on correctness
        if(allMatch){
          // success flourish (limited to 3 tones)
          tones = [{freq:1200,dur:0.12,type:'sine',delay:0,vol:0.14},{freq:1600,dur:0.08,type:'sine',delay:0.06,vol:0.10},{freq:2000,dur:0.06,type:'sine',delay:0.12,vol:0.08}];
        } else {
          // count how many digits are correct
          const correctCount = diffs.filter(d=> d===0).length;
          // choose patterns: 0 correct -> low fail tone; 1..2 correct -> mixed
          if(correctCount === 0){
            tones = [{freq:360,dur:0.14,type:'sawtooth',delay:0,vol:0.12}];
          } else if(correctCount <= 2){
            tones = [{freq:620,dur:0.08,type:'triangle',delay:0,vol:0.10},{freq:720,dur:0.06,type:'sine',delay:0.06,vol:0.08}];
          } else {
            tones = [{freq:720,dur:0.10,type:'sine',delay:0,vol:0.10},{freq:880,dur:0.06,type:'sine',delay:0.06,vol:0.08}];
          }
        }
        playToneSequence(tones);

        // visual feedback & per-digit micro-feedback
        diffs.forEach((d,i)=>{
          if(d===0){ /* bright blink for matching digit */ }
          else if(d===1){ applyVisualGlitch(80); }
          else if(d>=2){ applyVisualGlitch(120); }
        });

        if(allMatch){
          state.finished = true;
          // award vault and animate
          const amount = awardVault(stageObj, map);
          if(map) { map.vaultOpened = true; if(window.GAME) window.GAME.vaultOpen = true; if(window.saveState) window.saveState(); }
          // simple GL open animation if glProg exists
          if(window.gl && window.glProg && window.glProg.openLoc){
            (function animateOpen(){
              let t0 = performance.now();
              const dur = 900;
              function step(){
                const t = Math.min(1, (performance.now() - t0) / dur);
                const e = 1 - Math.pow(1 - t, 3);
                try{ window.GAME.vaultOpen = e; window.gl.uniform1f(window.glProg.openLoc, e); } catch(e){}
                if(t < 1) requestAnimationFrame(step);
              }
              requestAnimationFrame(step);
            })();
          }
          cleanup(true, amount);
        } else {
          // failure consequences: increase alarm, possible lockout
          const avg = diffs.reduce((a,b)=>a+b,0) / diffs.length;
          const penalty = Math.floor(6 + avg * 8 + (stageObj.difficulty || 1) * 6);
          if(window.GAME) {
            window.GAME.alarm = Math.min(100, (window.GAME.alarm || 0) + penalty);
            window.GAME.stealth = Math.max(0, (window.GAME.stealth || 100) - 8);
          }
          // strong failure if avg large
          if(avg >= 3.2){
            playBeep(220,0.22,'sawtooth',0.12);
            applyVisualGlitch(520);
            ui.hint.textContent = 'LOCKED OUT — 警備が強化されました';
            // escalate guard speeds if possible
            try{
              if(window.currentMap && window.currentMap.entities && Array.isArray(window.currentMap.entities.guards)){
                for(const g of window.currentMap.entities.guards){ g._baseSpeed = g._baseSpeed || g.speed; g.speed = (g._baseSpeed || 0.8) * 2.0; }
              }
            }catch(e){}
          } else {
            ui.hint.textContent = '一部の桁が異なります。調整してください。';
            applyVisualGlitch(160);
          }
        }
      } // submitAttempt

      function cancelAttempt(){
        cleanup(false);
      }

      function cleanup(success=false, reward=null){
        if(state.finished) {
          // allow UI removal even if already finished
        }
        state.finished = true;
        try{ window.removeEventListener('keydown', onKey); } catch(e){}
        try{ ui.overlay.remove(); } catch(e){}
        // restore escape submap if set
        try{
          if(state.inEscape && typeof state.exitEscapeFn === 'function'){
            try{ state.exitEscapeFn(); } catch(e){} // restore
          }
        }catch(e){}
        if(success){
          window.showFloatingText && window.showFloatingText('HACK SUCCESS');
        } else {
          window.showFloatingText && window.showFloatingText('HACK FAILED');
        }
        resolve({ success: !!success, amount: reward || 0 });
      }

      // wire buttons
      ui.submitBtn.addEventListener('click', submitAttempt);
      ui.cancelBtn.addEventListener('click', cancelAttempt);

      // small initial glitch to make it feel "off"
      setTimeout(()=> applyVisualGlitch(180), 300);
    }); // Promise end
  } // startDiskHackSession

  // ----------------------------
  // 公開 API: startDialHack
  // ----------------------------
  function startDialHack(map){
    return new Promise((resolve)=>{
      try{
        // defensive: find map if not provided
        const targetMap = map || (window.currentMap || (window.GAME && window.GAME.currentMap) || null);
        if(!targetMap || !targetMap.vault){
          window.showFloatingText && window.showFloatingText('金庫が見つかりません');
          resolve({ success: false });
          return;
        }
        // proximity check
        if(window.Player){
          const d = distLocal(window.Player.x, window.Player.y, targetMap.vault.x, targetMap.vault.y);
          if(d > 1.6){
            window.showFloatingText && window.showFloatingText('金庫に近づいてから実行してください');
            resolve({ success: false });
            return;
          }
        }
        // alarm check (strict)
        if(window.GAME && (window.GAME.alarm || 0) >= 90){
          window.showFloatingText && window.showFloatingText('警報が高いためハックできません');
          resolve({ success: false });
          return;
        }
        // key check (require key globally)
        if(!hasKeyForMap(targetMap)){
          window.showModal && window.showModal('鍵が必要です', 'この金庫は Keycard を所持していないとハックできません。マップ上の Keycard を探してください。', ()=>{ resolve({ success:false }); });
          return;
        }

        // pause main game loop if present
        const prevRun = (window.GAME && typeof window.GAME.running !== 'undefined') ? window.GAME.running : null;
        if(window.GAME) window.GAME.running = false;

        // start
        startDiskHackSession(targetMap).then(res=>{
          // resume main run loop
          if(window.GAME && typeof prevRun === 'boolean') window.GAME.running = prevRun;
          resolve(res);
        }).catch(err=>{
          console.error('startDiskHackSession error', err);
          if(window.GAME && typeof prevRun === 'boolean') window.GAME.running = prevRun;
          resolve({ success: false });
        });

      }catch(e){
        console.error('startDialHack error', e);
        resolve({ success:false });
      }
    });
  }

  // export
  window.startDialHack = window.startDialHack || startDialHack;

  // Debug log
  console.log('Part3 (revised) loaded: circular hack UI, guard escalation hooks, escape submap, award handling ready.');

})();
</script>
<!-- Part4 — 最終統合改訂版（長く、堅牢に、しっかり考えた実装） -->
<script>
/*
 Part4 Revised — Integration & Robust Patches (長い・詳細)
 目的:
  - グローバルな HACK ボタンを確実に作成・管理（条件チェック・クールダウン・ロックアウト）
  - buyWeapon / equipWeapon のラッパーで一貫性と永続化を保証
  - PvC（Part2/Part3）との選択・装備同期を堅牢化
  - GL トグルの確実な動作修正
  - 高額バンク（報酬1000万超）でのマップ拡張フック実装（端に到達で追加マップを生成）
  - ガードのルート行動強化（updateGuardsEnhanced を優先、なければ提供）
  - アラーム・ステルス挙動の安定化（簡易補正）
  - デバッグ用オーバーレイとログ
 注意:
  - このスクリプトは Part1〜Part3 が同一ページに存在することを想定しますが、防御的に動作します。
  - 既に存在する関数・変数を無理に上書きせず、既存の機能をラップ/補完します。
*/

(function(){
  // --------- defensive references ----------
  const G = window.GAME || null;
  const Player = window.Player || null;
  const STAGES = window.STAGES || null;
  const WEAPONS = window.WEAPONS || null;
  const deviceDPR = window.devicePixelRatio || 1;

  // provide safe UI helpers if absent (short)
  if(typeof window.showFloatingText !== 'function'){
    window.showFloatingText = function(txt){
      try{
        const el = document.createElement('div');
        el.style.position = 'fixed'; el.style.left = '50%'; el.style.top = '14%';
        el.style.transform = 'translateX(-50%)'; el.style.zIndex = 40000;
        el.style.background = 'rgba(6,10,12,0.9)'; el.style.color = '#dff'; el.style.padding='8px 12px'; el.style.borderRadius='8px';
        el.style.fontWeight='900';
        el.textContent = txt;
        document.body.appendChild(el);
        setTimeout(()=>{ el.style.transition='all .7s'; el.style.opacity='0'; el.style.transform='translate(-50%,-10px)'; },900);
        setTimeout(()=>el.remove(),1700);
      }catch(e){}
    };
  }
  if(typeof window.showModal !== 'function'){
    window.showModal = function(title, text, onClose){
      try{
        const root = document.createElement('div');
        root.style.position='fixed'; root.style.left='50%'; root.style.top='50%';
        root.style.transform='translate(-50%,-50%)'; root.style.zIndex='45000';
        root.style.background='linear-gradient(180deg,#041016,#061720)'; root.style.color='#dff'; root.style.padding='16px'; root.style.borderRadius='12px';
        root.style.boxShadow='0 30px 80px rgba(0,0,0,0.7)';
        const t = document.createElement('div'); t.style.fontWeight='900'; t.style.fontSize='18px'; t.textContent=title||'';
        const d = document.createElement('div'); d.style.marginTop='8px'; d.style.color='#bfe'; d.textContent=text||'';
        const btn = document.createElement('button'); btn.className='btn small'; btn.style.marginTop='12px'; btn.textContent='OK';
        btn.addEventListener('click', ()=>{ root.remove(); if(typeof onClose === 'function') onClose(); });
        root.appendChild(t); root.appendChild(d); root.appendChild(btn);
        document.body.appendChild(root);
      }catch(e){}
    };
  }

  // --------- utilities ----------
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }
  function nowMs(){ return Date.now(); }
  function dist(ax,ay,bx,by){ return Math.hypot((ax||0)-(bx||0), (ay||0)-(by||0)); }
  function formatYen(n){ return '¥' + (n ? Math.floor(n).toLocaleString() : '0'); }

  // --------- config ----------
  const CFG = {
    HACK_COOLDOWN_MS: 900,
    HACK_FAIL_LOCK_MS: 6000,
    PROXIMITY: 1.6,
    ALARM_DISALLOW: 85, // disallow hack if alarm >=
    HIGH_REWARD_THRESHOLD: 10000000, // 1000万
    EXTENSION_GENERATED_FLAG: '_extensionGenerated',
    DBG_INTERVAL_MS: 1200,
  };

  // --------- ensure consistent GAME/Player objects ----------
  if(!window.GAME){
    window.GAME = window.GAME || { running:false, money:0, alarm:0, stealth:100, vaultOpen:false, inventory:[], equipped:null, skinsOwned:{}, unlocked:[] };
  }
  if(!window.Player){
    window.Player = window.Player || { x:2.5, y:2.5, r:0.35, speed:1.6, _vx:0, _vy:0, move: function(dx,dy,dt,map){ const nx=this.x+dx*this.speed*dt; const ny=this.y+dy*this.speed*dt; this.x=nx; this.y=ny; } };
  }

  // --------- HACK button creation & logic ----------
  const HACK_BUTTON_ID = 'vh_hack_button_final';
  const HACK_DOT_ID = 'vh_hack_dot_final';
  const HACK_TT_ID = 'vh_hack_tt_final';

  function createHackButton(){
    // remove old if exists
    const old = document.getElementById(HACK_BUTTON_ID);
    if(old) old.remove();

    // find controls container
    let controls = document.querySelector('.controls') || document.querySelector('.top-controls') || null;
    if(!controls){
      // create controls container bottom-right
      controls = document.createElement('div');
      controls.className = 'controls';
      controls.style.position='fixed'; controls.style.right='12px'; controls.style.bottom='12px'; controls.style.zIndex='9998';
      document.body.appendChild(controls);
    }

    const btn = document.createElement('button');
    btn.id = HACK_BUTTON_ID;
    btn.className = 'btn small warn';
    btn.style.display='flex'; btn.style.alignItems='center'; btn.style.gap='8px';
    btn.style.minWidth='96px';
    btn.innerHTML = `<span style="font-weight:900">HACK</span><span id="${HACK_DOT_ID}" style="width:12px;height:12px;border-radius:50%;display:inline-block;background:rgba(255,255,255,0.06)"></span>`;
    // tooltip
    const tt = document.createElement('div');
    tt.id = HACK_TT_ID;
    tt.style.position='absolute'; tt.style.bottom='110%'; tt.style.right='0'; tt.style.padding='8px 10px'; tt.style.borderRadius='8px';
    tt.style.background='rgba(6,10,12,0.92)'; tt.style.color='#dff'; tt.style.fontSize='12px'; tt.style.display='none';
    btn.appendChild(tt);

    controls.insertBefore(btn, controls.firstChild || null);
    return btn;
  }

  const hackBtn = createHackButton();
  const hackDot = document.getElementById(HACK_DOT_ID);
  const hackTT = document.getElementById(HACK_TT_ID);

  let cooldownUntil = 0;
  let lockoutUntil = 0;

  function setHackTooltip(text, persist=false){
    if(!hackTT) return;
    hackTT.textContent = text || '';
    hackTT.style.display = text ? 'block' : 'none';
    if(!persist){
      clearTimeout(hackTT._t);
      hackTT._t = setTimeout(()=> hackTT.style.display = 'none', 2200);
    }
  }

  function checkHackAllowed(){
    const map = window.currentMap || window.GAME.currentMap || null;
    if(!map || !map.vault) return { ok:false, reason:'noVault' };
    if(!window.Player) return { ok:false, reason:'noPlayer' };
    const d = dist(window.Player.x, window.Player.y, map.vault.x, map.vault.y);
    if(d > CFG.PROXIMITY) return { ok:false, reason:'tooFar', dist:d };
    if((window.GAME && (window.GAME.alarm || 0)) >= CFG.ALARM_DISALLOW) return { ok:false, reason:'alarmHigh' };
    // require key globally
    const hasKey = (window.GAME && window.GAME.hasKey) || (map.entities && Array.isArray(map.entities.items) && map.entities.items.some(it => (it.type === 'keycard' || it.type === 'key') && it.collected));
    if(!hasKey) return { ok:false, reason:'noKey' };
    if(map.vaultOpened || (window.GAME && window.GAME.vaultOpen)) return { ok:false, reason:'alreadyOpen' };
    return { ok:true };
  }

  // UI update loop for hack button state
  function updateHackButtonUI(){
    if(!hackBtn) return;
    const check = checkHackAllowed();
    if(!check.ok){
      hackBtn.style.opacity = '0.9';
      hackDot.style.background = 'rgba(255,255,255,0.06)';
      switch(check.reason){
        case 'noVault': setHackTooltip('ステージ選択後に使用可能'); break;
        case 'tooFar': setHackTooltip('もっと金庫に近づいてください'); break;
        case 'alarmHigh': setHackTooltip('警報が高いためハック不可', true); break;
        case 'noKey': setHackTooltip('鍵が必要です: Keycard を探してください', true); break;
        case 'alreadyOpen': setHackTooltip('既に開かれています', true); break;
        default: setHackTooltip('条件を満たしていません'); break;
      }
      hackBtn.disabled = false;
    } else {
      hackBtn.style.opacity = '1';
      hackDot.style.background = '#00e6a8';
      setHackTooltip('金庫に近接：押してハック (H)', true);
      hackBtn.disabled = false;
    }
  }
  setInterval(updateHackButtonUI, 180);

  // call startDialHack (Part3) with safety
  async function doHack(){
    // throttle
    const now = nowMs();
    if(now < cooldownUntil){ setHackTooltip('クールダウン中...'); return; }
    if(now < lockoutUntil){ setHackTooltip('ロック中...'); return; }
    const check = checkHackAllowed();
    if(!check.ok){
      if(check.reason === 'noKey'){
        window.showModal && window.showModal('鍵が必要', 'Keycard が必要です。マップ上の Keycard を探してください。', ()=>{});
      } else {
        setHackTooltip('条件を満たしていません');
      }
      return;
    }
    cooldownUntil = now + CFG.HACK_COOLDOWN_MS;
    // pause game loop if running
    const prevRun = (window.GAME && typeof window.GAME.running !== 'undefined') ? window.GAME.running : null;
    if(window.GAME) window.GAME.running = false;
    try{
      if(typeof window.startDialHack !== 'function'){
        window.showModal && window.showModal('未統合', 'ダイヤルハック (Part3) が読み込まれていません', ()=>{});
        return;
      }
      const map = window.currentMap || window.GAME.currentMap || null;
      const res = await window.startDialHack(map);
      if(!res || !res.success){
        lockoutUntil = now + CFG.HACK_FAIL_LOCK_MS;
        setHackTooltip('ハック失敗 — ロックアウト', true);
        window.showFloatingText && window.showFloatingText('ハックに失敗しました');
      } else {
        setHackTooltip('ハック成功', true);
        window.showFloatingText && window.showFloatingText('金庫を開けました ' + (res.amount ? formatYen(res.amount) : ''));
      }
    } catch(err){
      console.error('Hack execution error', err);
      window.showFloatingText && window.showFloatingText('ハック中にエラーが発生しました');
    } finally {
      if(window.GAME && typeof prevRun === 'boolean') window.GAME.running = prevRun;
      updateHackButtonUI();
    }
  }

  hackBtn.addEventListener('click', (e)=>{ e.preventDefault(); doHack(); });
  // H shortcut
  window.addEventListener('keydown', (e)=>{ if(e.key && e.key.toLowerCase() === 'h'){ const active = document.activeElement; if(active && (active.tagName==='INPUT' || active.tagName==='TEXTAREA' || active.isContentEditable)) return; hackBtn.click(); } });

  // --------- buy/equip wrappers & fallback implementations ----------
  function ensureArray(obj, key){
    if(!obj[key] || !Array.isArray(obj[key])) obj[key] = [];
  }

  // Wrap existing buyWeapon to ensure persistence & sync
  try{
    if(typeof window.buyWeapon === 'function' && !window.buyWeapon._vh_wrapped){
      const orig = window.buyWeapon;
      window.buyWeapon = function(wid){
        const res = orig(wid);
        try{
          if(res && res.ok){
            // ensure inventory
            ensureArray(window.GAME, 'inventory');
            if(!window.GAME.inventory.includes(wid)) window.GAME.inventory.push(wid);
            // auto-equip fallback
            if(!window.GAME.equipped || !window.GAME.equipped.weaponId){
              window.GAME.equipped = { weaponId: wid, skinId: (window.GAME.skinsOwned && window.GAME.skinsOwned[wid] && window.GAME.skinsOwned[wid][0]) || null };
            }
            window.saveState && window.saveState();
            // refresh PvC UI if present
            if(window._vh_pvc && typeof window._vh_pvc.renderPvCWeaponBar === 'function') window._vh_pvc.renderPvCWeaponBar();
            if(typeof renderShopGrid === 'function') renderShopGrid();
            if(typeof renderInventory === 'function') renderInventory();
          }
        }catch(e){ console.warn('buyWeapon wrapper post failed', e); }
        return res;
      };
      window.buyWeapon._vh_wrapped = true;
      console.log('[VH-Part4] Wrapped existing buyWeapon');
    }
  }catch(e){ console.warn('wrap buyWeapon failed', e); }

  // create fallback buyWeapon if none exists
  if(typeof window.buyWeapon !== 'function'){
    window.buyWeapon = function(wid){
      try{
        const map = WEAPONS ? (WEAPONS.find(w=>w.id===wid) || null) : null;
        if(!map) return { ok:false, msg:'invalid' };
        if(window.GAME.money < map.price) return { ok:false, msg:'insufficient' };
        if(!Array.isArray(window.GAME.inventory)) window.GAME.inventory = [];
        window.GAME.money = (window.GAME.money || 0) - map.price;
        window.GAME.inventory.push(wid);
        if(!window.GAME.equipped || !window.GAME.equipped.weaponId) window.GAME.equipped = { weaponId: wid, skinId: null };
        window.saveState && window.saveState();
        if(window._vh_pvc && typeof window._vh_pvc.renderPvCWeaponBar === 'function') window._vh_pvc.renderPvCWeaponBar();
        if(typeof renderInventory === 'function') renderInventory();
        window.showFloatingText && window.showFloatingText(map.name + ' を購入しました');
        return { ok:true };
      }catch(e){ return { ok:false, msg:'error' }; }
    };
    window.buyWeapon._vh_wrapped = true;
    console.log('[VH-Part4] Created fallback buyWeapon');
  }

  // Wrap equipWeapon
  try{
    if(typeof window.equipWeapon === 'function' && !window.equipWeapon._vh_wrapped){
      const orig = window.equipWeapon;
      window.equipWeapon = function(wid){
        const res = orig(wid);
        try{
          if(res && res.ok){
            window.GAME.equipped = { weaponId: wid, skinId: (window.GAME.skinsOwned && window.GAME.skinsOwned[wid] && window.GAME.skinsOwned[wid][0]) || null };
            window.saveState && window.saveState();
            if(typeof renderInventory === 'function') renderInventory();
            if(window._vh_pvc && typeof window._vh_pvc.renderPvCWeaponBar === 'function') window._vh_pvc.renderPvCWeaponBar();
          }
        }catch(e){ console.warn('equipWeapon wrapper post failed', e); }
        return res;
      };
      window.equipWeapon._vh_wrapped = true;
      console.log('[VH-Part4] Wrapped existing equipWeapon');
    }
  }catch(e){ console.warn('wrap equipWeapon fail', e); }

  // Fallback equipWeapon if missing
  if(typeof window.equipWeapon !== 'function'){
    window.equipWeapon = function(wid){
      try{
        if(!Array.isArray(window.GAME.inventory) || !window.GAME.inventory.includes(wid)) return { ok:false, msg:'not_owned' };
        window.GAME.equipped = { weaponId: wid, skinId: (window.GAME.skinsOwned && window.GAME.skinsOwned[wid] && window.GAME.skinsOwned[wid][0]) || null };
        window.saveState && window.saveState();
        if(typeof renderInventory === 'function') renderInventory();
        if(window._vh_pvc && typeof window._vh_pvc.renderPvCWeaponBar === 'function') window._vh_pvc.renderPvCWeaponBar();
        window.showFloatingText && window.showFloatingText('武器を装備しました');
        return { ok:true };
      }catch(e){ return { ok:false, msg:'error' }; }
    };
    window.equipWeapon._vh_wrapped = true;
    console.log('[VH-Part4] Created fallback equipWeapon');
  }

  // --------- PvC selection & sync helpers ----------
  // ensure global selected id exists and is used by Part1 modal or other callers
  window.pvcSelectedWeaponId = window.pvcSelectedWeaponId || (window.GAME && window.GAME.equipped && window.GAME.equipped.weaponId) || null;

  // Public helper to force set PvC weapon (in-session or pre-start)
  window._vh_setPvCWeapon = window._vh_setPvCWeapon || function(wid){
    try{
      if(!wid) return false;
      window.pvcSelectedWeaponId = wid;
      // set global equip too
      window.GAME.equipped = { weaponId: wid, skinId: (window.GAME.skinsOwned && window.GAME.skinsOwned[wid] && window.GAME.skinsOwned[wid][0]) || null };
      window.saveState && window.saveState();
      if(typeof renderInventory === 'function') renderInventory();
      // if PvC active, change in-session
      if(window._vh_pvc && window._vh_pvc.PVC && window._vh_pvc.PVC.running){
        const pvc = window._vh_pvc.PVC;
        pvc.player.weaponId = wid;
        pvc.player.weapon = JSON.parse(JSON.stringify((window.WEAPON_BY_ID && window.WEAPON_BY_ID[wid]) || (window.WEAPONS && window.WEAPONS.find(w=>w.id===wid) ) || {}));
        pvc.player.ammo = pvc.player.weapon.stats ? pvc.player.weapon.stats.mag : pvc.player.ammo;
        window.showFloatingText && window.showFloatingText('PvC内装備変更: ' + (pvc.player.weapon.name || wid));
      }
      if(window._vh_pvc && typeof window._vh_pvc.renderPvCWeaponBar === 'function') window._vh_pvc.renderPvCWeaponBar();
      return true;
    }catch(e){ console.warn('setPvCWeapon error', e); return false; }
  };

  // Patch Part1's modal selection list to set global pvcSelectedWeaponId if not already
  (function patchPvCModalSelection(){
    try{
      const list = document.getElementById('pvcWeaponList');
      if(!list) return;
      list.addEventListener('click', (e)=>{
        const btn = e.target.closest('button');
        const card = e.target.closest('div');
        if(!btn || !card) return;
        // heuristic: look for weapon name inside card
        const text = card.innerText || card.textContent || '';
        if(!text) return;
        // try to match by weapon name (prefix)
        if(window.WEAPONS && Array.isArray(window.WEAPONS)){
          for(const w of window.WEAPONS){
            if(text.indexOf(w.name) !== -1){
              window.pvcSelectedWeaponId = w.id;
              // visual highlight
              Array.from(list.children).forEach(ch=> ch.style.outline = 'none');
              card.style.outline = '2px solid rgba(0,230,168,0.12)';
              const prevPreview = document.getElementById('pvcWeaponPreview');
              if(prevPreview) prevPreview.textContent = w.name;
              break;
            }
          }
        }
      });
      console.log('[VH-Part4] Patched pvc modal selection handler');
    }catch(e){}
  })();

  // --------- GL toggle fix (ensure toggleGL button toggles actual canvas) ----------
  try{
    const toggleGLBtn = document.getElementById('toggleGL');
    if(toggleGLBtn){
      // remove existing listeners safely by cloning
      const newBtn = toggleGLBtn.cloneNode(true);
      toggleGLBtn.parentNode.replaceChild(newBtn, toggleGLBtn);
      newBtn.addEventListener('click', ()=>{
        const canvas = document.getElementById('glview');
        if(!canvas) { window.showFloatingText && window.showFloatingText('GL Canvas が見つかりません'); return; }
        if(canvas.style.opacity === '0.06' || canvas.style.height === '44px'){
          canvas.style.opacity = '1'; canvas.style.height = ''; canvas.style.display = '';
          window.showFloatingText && window.showFloatingText('GL 表示: ON');
        } else {
          canvas.style.opacity = '0.06'; canvas.style.height = '44px'; window.showFloatingText && window.showFloatingText('GL 表示: OFF');
        }
      });
      console.log('[VH-Part4] GL toggle repaired');
    }
  }catch(e){ console.warn('GL toggle fix failed', e); }

  // --------- High-tier map extension implementation ----------
  // Called by Part2 when player reaches map edge for high-reward stage (<=1000万+)
  window.handleHighTierMapExtension = window.handleHighTierMapExtension || function(currentMap, stageObj){
    try{
      if(!currentMap || currentMap[CFG.EXTENSION_GENERATED_FLAG]) return;
      // safety: avoid repeated generation
      currentMap[CFG.EXTENSION_GENERATED_FLAG] = true;
      // generate a new map page - MapGrid-like object (simple)
      const newCols = clamp(Math.floor(currentMap.cols * 1.1) + 4, 12, 80);
      const newRows = clamp(Math.floor(currentMap.rows * 1.05) + 3, 8, 60);
      const newMap = { cols: newCols, rows: newRows, cell: currentMap.cell || 48, cells: [], entities:{ guards:[], lasers:[], items:[] }, vault: null, vaultOpened:false, stageId: (stageObj && stageObj.id ? stageObj.id + '_pg2' : 'extended_stage') };
      for(let r=0;r<newMap.rows;r++) newMap.cells[r] = new Array(newMap.cols).fill(0);
      // perimeter walls
      for(let x=0;x<newMap.cols;x++){ newMap.cells[0][x]=1; newMap.cells[newMap.rows-1][x]=1; }
      for(let y=0;y<newMap.rows;y++){ newMap.cells[y][0]=1; newMap.cells[y][newMap.cols-1]=1; }
      // place vault at far side (opposite from player's entrance) - choose right-most center
      newMap.vault = { x: newMap.cols - 2, y: Math.floor(newMap.rows/2) };
      newMap.cells[newMap.vault.y][newMap.vault.x] = 2;
      // add lasers across corridors near vault (dangerous)
      const L = Math.max(6, Math.floor(newMap.cols/6));
      for(let i=0;i<L;i++){
        const lx = clamp(Math.floor(newMap.vault.x - rand(3, Math.min(newMap.cols-4,10))) + 0.5, 2, newMap.cols-3);
        const ly = Math.floor(rand(2, newMap.rows-3)) + 0.5;
        newMap.entities.lasers.push({ x: lx, y: ly, dir: Math.random()*Math.PI*2, len: Math.floor(rand(4, Math.min(newMap.cols,newMap.rows)-3)), thickness:0.10, pattern:'rot', speed:0.6+Math.random()*0.8, phase:Math.random()*Math.PI*2 });
      }
      // add guards patrolling specific routes to make predetermined corridors
      for(let g=0; g<Math.max(5, Math.floor((newMap.cols*newMap.rows)/80)); g++){
        const gx = Math.floor(rand(3,newMap.cols-6))+0.5;
        const gy = Math.floor(rand(2,newMap.rows-3))+0.5;
        // create patrol pts that form routes
        const pts = [{x:gx,y:gy},{x:clamp(gx+Math.floor(rand(2,6)),2,newMap.cols-3), y: clamp(gy + Math.floor(rand(-2,2)),2,newMap.rows-3)}];
        newMap.entities.guards.push({ x: gx, y: gy, pts, speed: 1.0 + Math.random()*0.6, t:0, dir:Math.random()*Math.PI*2, alert:false });
      }
      // maybe place a key somewhere in extension
      if(Math.random() < 0.5) newMap.entities.items.push({ x: Math.floor(newMap.cols/2)+0.2, y: Math.floor(newMap.rows/2)+0.2, type:'keycard', collected:false });

      // attach as linked map so UI/logic can detect and handle transitions
      currentMap.nextMap = newMap;
      // place a portal/door at the edge of currentMap that teleports player to the newMap's entrance when stepped on
      // we'll create a simple marker
      currentMap.extensionPortal = { x: (currentMap.cols - 2), y: Math.floor(currentMap.rows/2) };
      // show text
      window.showFloatingText && window.showFloatingText('深層エリアを発見しました — 端へ進むと自動転送されます (高報酬ステージ)');
      console.log('[VH-Part4] Generated extension map for high-tier stage', newMap);
    }catch(e){ console.warn('handleHighTierMapExtension error', e); }
  };

  // Intercept player movement to detect stepping on portal (simple)
  // We monkey-patch Player.move if necessary to check portal transitions (defensive)
  (function installPortalTeleport(){
    try{
      if(!window.Player) return;
      if(window.Player._vh_move_patched) return;
      const origMove = window.Player.move || function(dx,dy,dt,map){ const nx=this.x+dx*this.speed*dt; const ny=this.y+dy*this.speed*dt; this.x=nx; this.y=ny; };
      window.Player.move = function(dx,dy,dt,map){
        origMove.call(this, dx, dy, dt, map);
        try{
          const cm = window.currentMap || window.GAME.currentMap || null;
          if(!cm) return;
          if(cm.extensionPortal && cm.nextMap){
            const p = cm.extensionPortal;
            if(Math.hypot(this.x - p.x, this.y - p.y) < 0.8){
              // teleport player to nextMap entrance
              const nm = cm.nextMap;
              window.currentMap = nm;
              // find a safe spawn near left edge
              this.x = 1.5; this.y = Math.min(nm.rows - 2.5, Math.max(1.5, Math.floor(nm.rows/2) + (Math.random()*2-1)));
              window.showFloatingText && window.showFloatingText('深層エリアに転送されました — 注意: 高難度');
              // optionally mark previous map so we won't re-trigger
              cm._extensionUsed = true;
            }
          }
        }catch(e){}
      };
      window.Player._vh_move_patched = true;
      console.log('[VH-Part4] Patched Player.move to support extension portal');
    }catch(e){}
  })();

  // --------- guard route enhancer: ensure updateGuardsEnhanced exists ----------
  if(typeof window.updateGuardsEnhanced !== 'function'){
    // simple implementation (similar to Part2's earlier improved one) - keep compact
    window.updateGuardsEnhanced = function(map, dt){
      if(!map || !map.entities || !Array.isArray(map.entities.guards)) return;
      for(const g of map.entities.guards){
        if(!g._patrolIdx) g._patrolIdx = 0;
        if(!g.pts || g.pts.length < 2){
          const gx = Math.floor(g.x) || 2;
          const gy = Math.floor(g.y) || 2;
          g.pts = [{x:gx,y:gy},{x:clamp(gx+3,1,map.cols-2),y:gy}];
        }
        // simple patrol with occasional investigation
        const tgt = g.pts[g._patrolIdx % g.pts.length];
        const vx = tgt.x - g.x, vy = tgt.y - g.y;
        const d = Math.hypot(vx,vy) || 1;
        const sp = (g._baseSpeed || (g.speed || 0.9));
        g.x += (vx/d) * sp * dt;
        g.y += (vy/d) * sp * dt;
        if(d < 0.35) g._patrolIdx++;
        // detection -> alert flag if near player
        if(window.Player && Math.hypot(window.Player.x - g.x, window.Player.y - g.y) < 1.6){
          g.alert = true;
          if(window.GAME) { window.GAME.alarm = Math.min(100, (window.GAME.alarm || 0) + 18 * dt); window.GAME.stealth = Math.max(0, (window.GAME.stealth || 100) - 18 * dt); }
        } else {
          g.alert = false;
        }
      }
    };
    console.log('[VH-Part4] Provided fallback updateGuardsEnhanced');
  }

  // --------- alarm/stealth stabilization helper ----------
  (function stabilizeAlarmStealth(){
    setInterval(()=>{
      try{
        if(!window.GAME) return;
        // small passive decay when not in active threat
        const map = window.currentMap || window.GAME.currentMap || null;
        let threat = false;
        if(map && map.entities && Array.isArray(map.entities.guards)){
          for(const g of map.entities.guards) if(g.alert || g.state === 'chase') { threat = true; break; }
        }
        if(map && map.entities && Array.isArray(map.entities.lasers)){
          for(const L of map.entities.lasers) {
            if(L && window.Player && Math.hypot(window.Player.x - L.x, window.Player.y - L.y) < (L.len || 2)) { threat = true; break; }
          }
        }
        if(!threat){
          window.GAME.stealth = Math.min(100, (window.GAME.stealth || 100) + 4);
          window.GAME.alarm = Math.max(0, (window.GAME.alarm || 0) - 3);
        } else {
          // if threat, ensure alarm slowly increases (but cap)
          window.GAME.alarm = Math.min(100, (window.GAME.alarm || 0) + 0.6);
        }
        // update DOM if elements present
        try{ const a = document.getElementById('alarm'); if(a) a.textContent = Math.floor(window.GAME.alarm); }catch(e){}
        try{ const s = document.getElementById('stealth'); if(s) s.textContent = Math.floor(window.GAME.stealth); }catch(e){}
      }catch(e){}
    }, 600);
  })();

  // --------- make sure PVC mode present / fix visibility & stick responsiveness ----------
  (function ensurePVCIntegration(){
    try{
      // if PVC module exists, ensure its weapon bar renders when inventory changes
      if(window._vh_pvc && typeof window._vh_pvc.renderPvCWeaponBar === 'function'){
        // hook saveState to re-render bar after purchases
        const origSave = window.saveState;
        window.saveState = function(){
          try{ if(typeof origSave === 'function') origSave(); }catch(e){}
          try{ window._vh_pvc.renderPvCWeaponBar(); }catch(e){}
        };
        console.log('[VH-Part4] Hooked saveState -> renderPvCWeaponBar');
      }

      // Improve pvc stick visibility CSS if pvcStickWrap exists
      const style = document.createElement('style');
      style.textContent = `
        /* stronger stick visuals */
        .stickKnob, [style*="pvcKnob"], #pvcCanvas + div .stickKnob { box-shadow: 0 14px 36px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.03) !important; border:3px solid rgba(255,255,255,0.08) !important; }
      `;
      document.head.appendChild(style);
    }catch(e){}
  })();

  // --------- Debug overlay ----------
  (function addDebugOverlay(){
    const dbg = document.createElement('div');
    dbg.id = 'vh_dbg_overlay';
    dbg.style.position='fixed'; dbg.style.left='12px'; dbg.style.top='12px'; dbg.style.zIndex='50000';
    dbg.style.background='rgba(0,0,0,0.35)'; dbg.style.color='#cfe'; dbg.style.fontSize='12px'; dbg.style.padding='8px'; dbg.style.borderRadius='8px';
    dbg.style.display='none';
    dbg.innerHTML = '<div style="font-weight:900">DEV</div><div id="vh_dbg_text">init</div>';
    document.body.appendChild(dbg);
    window._vh_debug = {
      show: ()=> dbg.style.display='block',
      hide: ()=> dbg.style.display='none',
      set: (t)=> { const el=document.getElementById('vh_dbg_text'); if(el) el.textContent = t; }
    };
    setInterval(()=>{
      try{
        const el = document.getElementById('vh_dbg_text');
        if(!el) return;
        el.textContent = `money:${window.GAME.money || 0} alarm:${Math.floor(window.GAME.alarm||0)} stealth:${Math.floor(window.GAME.stealth||0)} inv:${(window.GAME.inventory||[]).length} equip:${(window.GAME.equipped && window.GAME.equipped.weaponId) || '—'}`;
      }catch(e){}
    }, CFG.DBG_INTERVAL_MS);
  })();

  // --------- final logs & integration notes ----------
  console.log('[VH-Part4] Integration patches installed: hack button, buy/equip wrappers, PvC sync helpers, GL toggle fix, high-tier extension support, guard enhancer.');

  // ---------- Where to paste when splitting files ----------
  // If you split: order MUST be Part1 -> Part2 -> Part3 -> Part4 (this file).
  // If hack button disappears, confirm Part4 executed and startDialHack exists.
  // If guards not moving, ensure updateGuardsEnhanced exists (Part2) and window.currentMap is set.
})();
</script>
</body>
</html>

