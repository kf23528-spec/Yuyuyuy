<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Vault Heist — Part1 (Enhanced Offline 3D Core)</title>
<style>
:root{ --bg: #06101a; --panel: rgba(6,8,10,0.78); --accent: #ffde59; --muted: #9fb1bd; --good:#2ecc71; --bad:#e74c3c;}
html,body{height:100%;margin:0;padding:0;background:var(--bg);color:#e8eef6;font-family:system-ui,-apple-system,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif}
#app{position:fixed;inset:0;display:flex;flex-direction:column}
header{height:64px;padding:8px 12px;display:flex;align-items:center;background:linear-gradient(90deg,#07101a,#0b1220);box-shadow:0 6px 18px rgba(0,0,0,0.45);z-index:110}
header h1{margin:0;font-size:16px}
.header-right{margin-left:auto;display:flex;gap:8px;align-items:center}
.btn{appearance:none;border:none;padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.03);color:inherit;cursor:pointer}
.select{appearance:none;padding:8px;border-radius:8px;background:rgba(255,255,255,0.03);color:inherit;border:1px solid rgba(255,255,255,0.03)}
#sceneWrap{flex:1;position:relative;overflow:hidden}
canvas#glcanvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#072033,#04101a);touch-action:none}
#hud{position:absolute;right:12px;top:88px;width:320px;background:var(--panel);border-radius:12px;padding:12px;backdrop-filter:blur(6px);z-index:130;border:1px solid rgba(255,255,255,0.03)}
#hud h2{margin:0;font-size:13px}
.hud-row{display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.02)}
#minimap{position:absolute;left:12px;top:88px;width:180px;height:180px;background:rgba(0,0,0,0.36);border-radius:10px;padding:8px;z-index:130;border:1px solid rgba(255,255,255,0.03)}
#minimap canvas{width:100%;height:100%}
#controlsMobile{position:absolute;left:12px;bottom:12px;z-index:150;display:flex;gap:12px;align-items:flex-end}
.stickOuter{width:120px;height:120px;border-radius:999px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;touch-action:none}
.stickInner{width:52px;height:52px;border-radius:999px;background:rgba(255,255,255,0.06);transform:translate(0,0)}
.notifBox{position:absolute;right:12px;bottom:12px;z-index:160;display:flex;flex-direction:column-reverse;gap:8px}
.notif{background:rgba(0,0,0,0.6);padding:8px 10px;border-radius:10px;color:#eaf1f6;font-size:13px}
.modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#0b0c0f;padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);z-index:210;display:none;max-width:96%}
.modal.open{display:block}
.legend{font-size:12px;color:#cfdfe6;margin-top:8px}
.footer{height:48px;display:flex;align-items:center;justify-content:center;color:var(--muted);background:linear-gradient(90deg,#03050a,#061018)}
.controls-bottom{display:flex;gap:8px;align-items:center}
.small{font-size:12px;padding:6px 8px;border-radius:8px}
.panel-section{margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.02)}
@media(max-width:720px){ #hud{width:220px} #minimap{width:120px;height:120px} .header-right{display:none} }
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>Vault Heist — Part1 (Enhanced Offline 3D Core)</h1>
    <div class="header-right">
      <select id="graphicsQuality" class="select small" title="描画品質"><option value="low">低</option><option value="med" selected>中</option><option value="high">高</option></select>
      <select id="difficultySel" class="select small" title="難易度"><option value="EASY">EASY</option><option value="NORMAL" selected>NORMAL</option><option value="HARD">HARD</option></select>
      <button id="btnNewMap" class="btn">新しいマップ</button>
      <button id="btnSave" class="btn">保存</button>
    </div>
  </header>

  <div id="sceneWrap">
    <canvas id="glcanvas"></canvas>

    <div id="minimap">
      <canvas id="mini" width="320" height="320"></canvas>
      <div class="legend">凡例: <span style="color:#2ecc71">銀行</span> <span style="color:#3498db">コンビニ</span> <span style="color:#e67e22">パチンコ</span></div>
    </div>

    <div id="hud">
      <h2>ステータス</h2>
      <div class="hud-row"><div>所持金</div><div id="money">¥0</div></div>
      <div class="hud-row"><div>銃</div><div id="guns">0</div></div>
      <div class="hud-row"><div>車</div><div id="cars">0</div></div>
      <div class="hud-row"><div>警戒度</div><div id="heat">0</div></div>
      <div class="panel-section">
        <div style="display:flex;justify-content:space-between;align-items:center"><div>マップ</div><div>600×600</div></div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px"><div>金庫数</div><div id="vaultCount">0</div></div>
      </div>
      <div class="panel-section">
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button id="btnInteract" class="btn small">行動</button>
          <button id="btnVault" class="btn small">金庫</button>
        </div>
      </div>
    </div>

    <div id="controlsMobile">
      <div class="stickOuter" id="joyZone"><div class="stickInner" id="stickInner"></div></div>
      <div style="display:flex;flex-direction:column;gap:8px">
        <button id="btnFire" class="btn small">発砲</button>
        <button id="btnEnter" class="btn small">侵入</button>
      </div>
    </div>

    <div class="notifBox" id="notifBox"></div>

    <div id="vaultModal" class="modal" aria-hidden="true">
      <h3>金庫（プレースホルダ）</h3>
      <p id="vaultMsg">Part2 でダイヤル/UI を実装予定。ここで金額等を確認できます。</p>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button id="closeVault" class="btn">閉じる</button>
      </div>
    </div>

    <div id="shopModal" class="modal" aria-hidden="true">
      <h3 id="shopTitle">ショップ</h3>
      <div id="shopBody"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button id="closeShop" class="btn">閉じる</button>
      </div>
    </div>

  </div>

  <div class="footer">完成度向上済み Part1 — 次はPart2（ダイヤル演出）を統合します</div>
</div>

<script>
/* ================
   Enhanced Part1 — single-file offline 3D core
   - WebGL safe init (no external libs)
   - Improved map generation, lighting, camera, controls
   - Vehicles placeholder, shops, vaults, minimap, save/load, difficulty, performance options
   - Hooks for Part2/Part3 integration exposed as window._part1_*
   ================ */

/* -----------------------
   Utilities
   ----------------------- */
function el(id){ return document.getElementById(id); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function fmtMoney(n){ return '¥' + Math.floor(n).toLocaleString('ja-JP'); }
function notify(msg, ttl=2600){
  const box = el('notifBox'); const d=document.createElement('div'); d.className='notif'; d.textContent = msg; box.appendChild(d);
  setTimeout(()=>{ d.style.opacity='0'; setTimeout(()=>d.remove(),320); }, ttl);
}

/* -----------------------
   Game state
   ----------------------- */
const STATE = {
  mapSize: 600,
  player: { x:300, z:300, y:0, money:18000, guns:1, cars:0, speed:2.6, hp:100 },
  buildings: [], // {kind,x,z,sx,sz,height}
  vaults: [],   // {buildingIndex,locked,attempts,dialSolution,reward}
  vehicles: [], // runtime vehicles {x,z,type}
  shops: [],    // references to certain building indices
  difficulty: 'NORMAL',
  graphics: 'med',
  heat: 0,
  lastSaved: null
};

/* export for other parts */
window._vh_state = STATE;

/* -----------------------
   WebGL safe initialization
   ----------------------- */
const canvas = el('glcanvas');
let gl = null;
function initGL(){
  const opts = { antialias:false, alpha:false, depth:true, stencil:false, preserveDrawingBuffer:false, powerPreference:'default', failIfMajorPerformanceCaveat:false };
  gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts);
  if (!gl) {
    el('sceneWrap').innerHTML = '<div style="color:#fff;padding:20px">WebGL が利用できません。管理者に相談してください。</div>';
    return false;
  }
  gl.clearColor(0.03,0.06,0.09,1.0);
  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LEQUAL);
  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);
  return true;
}

/* -----------------------
   Minimal shaders (Lambert-like) optimized for compatibility
   ----------------------- */
const VSH = `
attribute vec3 aPos; attribute vec3 aNormal; attribute vec4 aColor;
uniform mat4 uMVP; uniform mat4 uModel; uniform mat4 uNormal;
varying vec3 vNormal; varying vec4 vColor;
void main(){
  gl_Position = uMVP * vec4(aPos, 1.0);
  vNormal = mat3(uNormal) * aNormal;
  vColor = aColor;
}
`;
const FSH = `
precision mediump float;
varying vec3 vNormal; varying vec4 vColor;
uniform vec3 uLightDir; uniform vec3 uAmbient;
void main(){
  vec3 n = normalize(vNormal);
  float d = max(dot(n, normalize(uLightDir)), 0.0);
  vec3 col = vColor.rgb * (uAmbient + d * 0.9);
  gl_FragColor = vec4(col, vColor.a);
}
`;

function compile(src, type){
  const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) { console.error('Shader error', gl.getShaderInfoLog(s)); return null; }
  return s;
}
function linkProgram(vs, fs){
  const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) { console.error('Program link error', gl.getProgramInfoLog(p)); return null; }
  return p;
}

/* -----------------------
   VBO utilities: create box mesh arrays
   ----------------------- */
function makeBoxData(sx, sy, sz, color){
  const x = sx/2, y = sy/2, z = sz/2;
  const positions = [
    // front
    -x,-y,z,  x,-y,z,  x,y,z, -x,y,z,
    // back
    x,-y,-z, -x,-y,-z, -x,y,-z, x,y,-z,
    // left
    -x,-y,-z, -x,-y,z, -x,y,z, -x,y,-z,
    // right
    x,-y,z, x,-y,-z, x,y,-z, x,y,z,
    // top
    -x,y,z, x,y,z, x,y,-z, -x,y,-z,
    // bottom
    -x,-y,-z, x,-y,-z, x,-y,z, -x,-y,z
  ];
  const normals = [
    // front...
    0,0,1, 0,0,1, 0,0,1, 0,0,1,
    0,0,-1,0,0,-1,0,0,-1,0,0,-1,
    -1,0,0,-1,0,0,-1,0,0,-1,0,0,
    1,0,0,1,0,0,1,0,0,1,0,0,
    0,1,0,0,1,0,0,1,0,0,1,0,
    0,-1,0,0,-1,0,0,-1,0,0,-1,0
  ];
  const indices = [
    0,1,2,0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11,
    12,13,14,12,14,15, 16,17,18,16,18,19, 20,21,22,20,22,23
  ];
  const colors = [];
  for (let i=0;i<24;i++){ colors.push(color[0], color[1], color[2], 1.0); }
  return { positions: new Float32Array(positions), normals: new Float32Array(normals), colors: new Float32Array(colors), indices: new Uint16Array(indices) };
}

/* -----------------------
   GL program and buffers
   ----------------------- */
let program = null, attrs = {}, unis = {};
let vboPos=null, vboNorm=null, vboColor=null, ibo=null;
let totalIndices = 0;
function setupGLProgram(){
  const vs = compile(VSH, gl.VERTEX_SHADER), fs = compile(FSH, gl.FRAGMENT_SHADER);
  if (!vs || !fs) return false;
  program = linkProgram(vs, fs);
  attrs.aPos = gl.getAttribLocation(program, 'aPos');
  attrs.aNormal = gl.getAttribLocation(program, 'aNormal');
  attrs.aColor = gl.getAttribLocation(program, 'aColor');
  unis.uMVP = gl.getUniformLocation(program, 'uMVP');
  unis.uModel = gl.getUniformLocation(program, 'uModel');
  unis.uNormal = gl.getUniformLocation(program, 'uNormal');
  unis.uLightDir = gl.getUniformLocation(program, 'uLightDir');
  unis.uAmbient = gl.getUniformLocation(program, 'uAmbient');

  vboPos = gl.createBuffer(); vboNorm = gl.createBuffer(); vboColor = gl.createBuffer(); ibo = gl.createBuffer();
  return true;
}

/* -----------------------
   Build scene VBO: ground + all buildings + test markers + player marker
   We'll pack them in big buffers; rebuilding is triggered when map or player marker changes.
   ----------------------- */
function buildBuffers(){
  const posArr = [], normArr = [], colArr = [], idxArr = [];
  let idxOffset = 0;
  // ground: thin box
  const ground = makeBoxData(STATE.mapSize, 2, STATE.mapSize, [0.09,0.16,0.20]);
  appendMesh(ground, [0, -1, 0]);
  // buildings
  STATE.buildings.forEach(b=>{
    const color = hexToNorm(kindToHex(b.kind));
    const mesh = makeBoxData(b.sx, b.height, b.sz, color);
    appendMesh(mesh, [b.x - STATE.mapSize/2, b.height/2, b.z - STATE.mapSize/2]);
  });
  // vehicles icons (small boxes)
  STATE.vehicles.forEach(v=>{
    const col = v.type==='car'?[0.6,0.25,0.16]:[0.4,0.7,0.2];
    const m = makeBoxData(6,4,10, col);
    appendMesh(m, [v.x - STATE.mapSize/2, 2, v.z - STATE.mapSize/2]);
  });
  // big test box center to ensure visible
  const test = makeBoxData(28,28,28, [1.0,0.3,0.26]); appendMesh(test, [0,14,0]);
  // player marker
  const pm = makeBoxData(8,18,8, [1.0,0.78,0.34]); appendMesh(pm, [STATE.player.x - STATE.mapSize/2, 9, STATE.player.z - STATE.mapSize/2]);

  function appendMesh(m, translate){
    const base = posArr.length/3;
    // positions
    for (let i=0;i<m.positions.length;i+=3){
      posArr.push(m.positions[i]+translate[0], m.positions[i+1]+translate[1], m.positions[i+2]+translate[2]);
    }
    for (let i=0;i<m.normals.length;i++) normArr.push(m.normals[i]);
    for (let i=0;i<m.colors.length;i++) colArr.push(m.colors[i]);
    for (let i=0;i<m.indices.length;i++) idxArr.push(m.indices[i] + base);
  }

  // upload buffers
  const positions = new Float32Array(posArr), normals = new Float32Array(normArr), colors = new Float32Array(colArr), indices = new Uint16Array(idxArr);
  gl.bindBuffer(gl.ARRAY_BUFFER, vboPos); gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, vboNorm); gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, vboColor); gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
  totalIndices = indices.length;
}

/* -----------------------
   Basic math / matrices (small helpers)
   ----------------------- */
function mat4Identity(){ return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }
function mat4Multiply(a,b){
  const o = new Float32Array(16);
  for (let i=0;i<4;i++){
    for (let j=0;j<4;j++){
      let s=0; for (let k=0;k<4;k++) s += a[i*4+k]*b[k*4+j]; o[i*4+j] = s;
    }
  }
  return o;
}
function mat4Translate(t){ const m = mat4Identity(); m[12]=t[0]; m[13]=t[1]; m[14]=t[2]; return m; }
function mat4RotateY(a){ const c=Math.cos(a), s=Math.sin(a); return new Float32Array([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]); }
function mat4RotateX(a){ const c=Math.cos(a), s=Math.sin(a); return new Float32Array([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]); }
function mat4Scale(x,y,z){ const m = mat4Identity(); m[0]=x; m[5]=y; m[10]=z; return m; }
function mat4Perspective(fovy, aspect, near, far){
  const f = 1.0/Math.tan(fovy/2); const nf = 1/(near - far);
  const out = new Float32Array(16);
  out[0]=f/aspect; out[5]=f; out[10]=(far+near)*nf; out[11]=-1; out[14]=(2*far*near)*nf;
  return out;
}
function mat4LookAt(eye, center, up){
  let zx = eye[0]-center[0], zy=eye[1]-center[1], zz=eye[2]-center[2]; let l = Math.hypot(zx,zy,zz); if(l===0){ zx=0;zy=0;zz=1; } else { zx/=l;zy/=l;zz/=l; }
  let xx = up[1]*zz - up[2]*zy, xy = up[2]*zx - up[0]*zz, xz = up[0]*zy - up[1]*zx; l=Math.hypot(xx,xy,xz); if(l===0){ xx=0;xy=0;xz=0; } else { xx/=l;xy/=l;xz/=l; }
  let yx = zy*xz - zz*xy, yy = zz*xx - zx*xz, yz = zx*xy - zy*xx;
  const out = mat4Identity();
  out[0]=xx; out[1]=yx; out[2]=zx; out[3]=0;
  out[4]=xy; out[5]=yy; out[6]=zy; out[7]=0;
  out[8]=xz; out[9]=yz; out[10]=zz; out[11]=0;
  out[12]=-(xx*eye[0] + xy*eye[1] + xz*eye[2]);
  out[13]=-(yx*eye[0] + yy*eye[1] + yz*eye[2]);
  out[14]=-(zx*eye[0] + zy*eye[1] + zz*eye[2]);
  out[15]=1;
  return out;
}

/* -----------------------
   Draw loop
   ----------------------- */
let cam = { x: STATE.player.x - STATE.mapSize/2 + 0, y:260, z: STATE.player.z + 360, yaw: -Math.PI/2+0.7, pitch: -0.45 };
let lastTime = performance.now(), rebuildDebounce = 0;
function update(dt){
  // keyboard movement
  processKeyboard(dt);
  // stick movement -> already applied when moving
  // update camera to orbit around player
  updateCameraFromAngles();
  // dynamic day/night: simple cycle
  const dayT = (performance.now()/1000/30) % 1.0; // 30s per cycle
  const ambientBase = 0.28 + 0.22 * Math.sin(dayT*Math.PI*2);
  // draw frame
  renderFrame(ambientBase);
  // rebuild buffers occasionally if scheduled
  if (rebuildDebounce > 0) { rebuildDebounce -= dt; if (rebuildDebounce <= 0) { buildBuffers(); } }
  // HUD update
  updateHUD();
}
function renderFrame(ambient){
  // resize canvas if necessary
  fitCanvas();
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.useProgram(program);
  // compute matrices
  const eye = [cam.x, cam.y, cam.z];
  const center = [STATE.player.x - STATE.mapSize/2, 0, STATE.player.z - STATE.mapSize/2];
  const proj = mat4Perspective(60*Math.PI/180, canvas.width/canvas.height, 0.1, 2000);
  const view = mat4LookAt(eye, center, [0,1,0]);
  const mvp = mat4Multiply(proj, view);
  const model = mat4Identity(); const normal = mat4Identity();
  // bind attributes
  gl.bindBuffer(gl.ARRAY_BUFFER, vboPos); gl.enableVertexAttribArray(attrs.aPos); gl.vertexAttribPointer(attrs.aPos, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, vboNorm); gl.enableVertexAttribArray(attrs.aNormal); gl.vertexAttribPointer(attrs.aNormal, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, vboColor); gl.enableVertexAttribArray(attrs.aColor); gl.vertexAttribPointer(attrs.aColor, 4, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.uniformMatrix4fv(unis.uMVP, false, mvp);
  gl.uniformMatrix4fv(unis.uModel, false, model);
  gl.uniformMatrix4fv(unis.uNormal, false, normal);
  gl.uniform3fv(unis.uLightDir, new Float32Array([0.5, 0.8, 0.2]));
  gl.uniform3fv(unis.uAmbient, new Float32Array([ambient, ambient, ambient]));
  gl.drawElements(gl.TRIANGLES, totalIndices, gl.UNSIGNED_SHORT, 0);
  // call external part updates
  try { if (window._part2_update) window._part2_update(0.016); if (window._part3_update) window._part3_update(0.016); } catch(e) {}
}

/* -----------------------
   Camera & Input Helpers
   ----------------------- */
function updateCameraFromAngles(){
  const targetX = STATE.player.x - STATE.mapSize/2, targetZ = STATE.player.z - STATE.mapSize/2;
  const radius = 360;
  cam.x = targetX + Math.cos(cam.pitch) * Math.cos(cam.yaw) * radius;
  cam.y = Math.max(48, Math.sin(-cam.pitch) * 260 + 30);
  cam.z = targetZ + Math.cos(cam.pitch) * Math.sin(cam.yaw) * radius;
}

function fitCanvas(){
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const w = Math.max(640, Math.floor(canvas.clientWidth * dpr));
  const h = Math.max(480, Math.floor(canvas.clientHeight * dpr));
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
}

/* -----------------------
   Keyboard & Stick input
   ----------------------- */
const KEYS = {};
window.addEventListener('keydown', e=>{ KEYS[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e=>{ KEYS[e.key.toLowerCase()] = false; });

function processKeyboard(dt){
  let mx = 0, mz = 0;
  if (KEYS['w']||KEYS['arrowup']) mz -= 1;
  if (KEYS['s']||KEYS['arrowdown']) mz += 1;
  if (KEYS['a']||KEYS['arrowleft']) mx -= 1;
  if (KEYS['d']||KEYS['arrowright']) mx += 1;
  if (mx !== 0 || mz !== 0){
    const forward = [-Math.cos(cam.yaw), 0, -Math.sin(cam.yaw)];
    const right = [Math.sin(cam.yaw), 0, -Math.cos(cam.yaw)];
    const len = Math.hypot(mx, mz) || 1;
    const nx = (right[0]*mx + forward[0]*mz)/len;
    const nz = (right[2]*mx + forward[2]*mz)/len;
    STATE.player.x += nx * STATE.player.speed * 40 * dt;
    STATE.player.z += nz * STATE.player.speed * 40 * dt;
    STATE.player.x = clamp(STATE.player.x, 0, STATE.mapSize);
    STATE.player.z = clamp(STATE.player.z, 0, STATE.mapSize);
    scheduleRebuild();
  }
}

/* virtual stick */
let stickCenter = null, draggingStick = false;
const stickOuter = el('joyZone'), stickInner = el('stickInner');
stickOuter.addEventListener('pointerdown', e=>{ e.preventDefault(); draggingStick=true; stickOuter.setPointerCapture(e.pointerId); const r = stickOuter.getBoundingClientRect(); stickCenter={x:r.left+r.width/2, y:r.top+r.height/2}; onStickMove(e.clientX, e.clientY); });
window.addEventListener('pointermove', e=>{ if (draggingStick) onStickMove(e.clientX, e.clientY); });
window.addEventListener('pointerup', e=>{ if (draggingStick){ draggingStick=false; stickInner.style.transform='translate(0,0)'; STATE.inputStick={x:0,y:0}; } });
function onStickMove(cx, cy){
  const dx = cx - stickCenter.x, dy = cy - stickCenter.y; const max = 44;
  const nx = clamp(dx/max, -1, 1), ny = clamp(dy/max, -1, 1);
  stickInner.style.transform = `translate(${clamp(dx,-max,max)}px, ${clamp(dy,-max,max)}px)`;
  // feed movement
  const ang = cam.yaw;
  const vx = nx * Math.cos(ang) - ny * Math.sin(ang);
  const vz = nx * Math.sin(ang) + ny * Math.cos(ang);
  STATE.player.x += vx * STATE.player.speed * 20 * 0.016;
  STATE.player.z += vz * STATE.player.speed * 20 * 0.016;
  STATE.player.x = clamp(STATE.player.x, 0, STATE.mapSize);
  STATE.player.z = clamp(STATE.player.z, 0, STATE.mapSize);
  scheduleRebuild();
}

/* pointer drag to rotate view */
let dragging = false, lastPointer = null;
canvas.addEventListener('pointerdown', e=>{ if (isUI(e.target)) return; dragging=true; lastPointer={x:e.clientX,y:e.clientY}; canvas.setPointerCapture(e.pointerId); });
canvas.addEventListener('pointermove', e=>{ if (!dragging) return; const dx = e.clientX - lastPointer.x, dy = e.clientY - lastPointer.y; lastPointer={x:e.clientX,y:e.clientY}; cam.yaw -= dx * 0.006; cam.pitch = clamp(cam.pitch - dy * 0.004, -1.2, -0.12); });
canvas.addEventListener('pointerup', e=>{ dragging=false; lastPointer=null; });
function isUI(target){ return target.closest && (target.closest('#hud') || target.closest('#minimap') || target.closest('.modal') || target.closest('#controlsMobile')); }

/* -----------------------
   Map generation & shops & vehicles
   ----------------------- */
function kindToHex(kind){
  switch(kind){
    case 'bank': return 0x2ecc71;
    case 'conbini': return 0x3498db;
    case 'pachinko': return 0xe67e22;
    case 'carshop': return 0x9b59b6;
    case 'slots': return 0xf1c40f;
    case 'blackmarket': return 0xe84393;
    default: return 0x95a5a6;
  }
}
function hexToNorm(hex){ return [(hex>>16 & 0xff)/255, (hex>>8 & 0xff)/255, (hex & 0xff)/255]; }

function generateMap(){
  STATE.buildings = []; STATE.vaults = []; STATE.vehicles = []; STATE.shops = [];
  const cell = 60; const cols = Math.floor(STATE.mapSize / cell);
  for (let r=0;r<cols;r++){
    for (let c=0;c<cols;c++){
      const x = c*cell + rand(8, cell-8), z = r*cell + rand(8, cell-8);
      const roll = Math.random();
      let kind = 'dummy';
      if (roll < 0.02) kind='bank';
      else if (roll < 0.07) kind='conbini';
      else if (roll < 0.11) kind='pachinko';
      else if (roll < 0.14) kind='carshop';
      else if (roll < 0.16) kind='slots';
      else if (roll < 0.17) kind='blackmarket';
      const sx = rand(12,38), sz = rand(12,38), h = rand(20,86);
      STATE.buildings.push({kind,x,z,sx,sz,height:h});
      if (kind==='bank' || kind==='conbini' || kind==='pachinko'){
        STATE.vaults.push({buildingIndex: STATE.buildings.length-1, locked:true, attempts:0, dialSolution:[rand(0,9),rand(0,9),rand(0,9),rand(0,9)], reward: kind==='bank'?50000:(kind==='pachinko'?15000:4200)});
      }
      if (kind==='carshop' || kind==='slots' || kind==='blackmarket') STATE.shops.push(STATE.buildings.length-1);
    }
  }
  if (!STATE.buildings.some(b=>b.kind==='bank')) { const x=rand(80,STATE.mapSize-80), z=rand(80,STATE.mapSize-80); STATE.buildings.push({kind:'bank',x,z,sx:56,sz:56,height:72}); STATE.vaults.push({buildingIndex:STATE.buildings.length-1,locked:true,attempts:0,dialSolution:[rand(0,9),rand(0,9),rand(0,9),rand(0,9)],reward:50000}); }
  // spawn some vehicles
  for (let i=0;i<10;i++){ const vx = rand(40, STATE.mapSize-40), vz = rand(40, STATE.mapSize-40); STATE.vehicles.push({x:vx,z:vz,type:'car'}); }
  el('vaultCount').textContent = STATE.vaults.length;
  scheduleRebuild();
  drawMiniImmediate();
}

/* -----------------------
   Minimap
   ----------------------- */
const mini = el('mini'), mctx = mini.getContext('2d');
function drawMiniImmediate(){
  const W = mini.width, H = mini.height; mctx.clearRect(0,0,W,H);
  mctx.fillStyle = '#02111a'; mctx.fillRect(0,0,W,H);
  const s = W / STATE.mapSize;
  STATE.buildings.forEach(b=>{
    const x = Math.round(b.x * s), y = Math.round(b.z * s), w = clamp(Math.round(b.sx * s), 3, 18), h = clamp(Math.round(b.sz * s), 3, 18);
    const col = kindToHex(b.kind);
    mctx.fillStyle = `#${('00000'+(col.toString(16))).slice(-6)}`; mctx.fillRect(x-w/2, y-h/2, w, h);
  });
  // vehicles
  STATE.vehicles.forEach(v=>{ mctx.fillStyle='#ffcc55'; mctx.fillRect(Math.round(v.x*s)-2, Math.round(v.z*s)-2, 4,4); });
  // player
  const px = Math.round(STATE.player.x * (W/STATE.mapSize)), pz = Math.round(STATE.player.z * (H/STATE.mapSize));
  mctx.beginPath(); mctx.fillStyle = '#ffde59'; mctx.arc(px,pz,6,0,Math.PI*2); mctx.fill();
}

/* -----------------------
   HUD update
   ----------------------- */
function updateHUD(){
  el('money').textContent = fmtMoney(STATE.player.money);
  el('guns').textContent = STATE.player.guns;
  el('cars').textContent = STATE.player.cars;
  el('heat').textContent = Math.round(STATE.heat);
}

/* -----------------------
   Buffer rebuild scheduling
   ----------------------- */
let rebuildScheduled = false;
function scheduleRebuild(){
  if (!rebuildScheduled){ rebuildScheduled = true; setTimeout(()=>{ rebuildScheduled=false; buildBuffers(); }, 160); }
}

/* -----------------------
   UI wiring
   ----------------------- */
el('btnNewMap').addEventListener('click', ()=>{ generateMap(); drawMiniImmediate(); notify('新しいマップを生成しました'); });
el('btnSave').addEventListener('click', ()=>{ try{ const save = { player: STATE.player, buildings: STATE.buildings, vaults: STATE.vaults, time: Date.now() }; localStorage.setItem('vh_part1_save', JSON.stringify(save)); notify('保存しました'); }catch(e){ notify('保存に失敗しました'); }});
el('btnInteract').addEventListener('click', ()=> tryInteractNearby());
el('btnVault').addEventListener('click', ()=> openVaultNearby());
el('btnEnter').addEventListener('click', ()=> tryEnterNearby());
el('closeVault').addEventListener('click', ()=>{ el('vaultModal').classList.remove('open'); el('vaultModal').setAttribute('aria-hidden','true'); });

el('graphicsQuality').addEventListener('change', e=>{ STATE.graphics = e.target.value; notify('描画品質: '+e.target.value); scheduleRebuild(); });
el('difficultySel').addEventListener('change', e=>{ STATE.difficulty = e.target.value; notify('難易度: '+e.target.value); });

/* -----------------------
   Interaction helpers (vault/shop/enter)
   ----------------------- */
function findNearestBuilding(range=36){
  let nearest=null, nd=1e9, idx=-1;
  STATE.buildings.forEach((b,i)=>{ const d = Math.hypot(b.x-STATE.player.x, b.z-STATE.player.z); if (d < nd){ nd=d; nearest=b; idx=i; } });
  if (nearest && nd <= range) return { building: nearest, index: idx, dist: nd }; return null;
}

function tryInteractNearby(){ const n = findNearestBuilding(); if (!n){ notify('近くに入れる建物がありません'); return; } notify('建物: '+n.building.kind); if (n.building.kind === 'carshop' || n.building.kind==='slots' || n.building.kind==='blackmarket'){ openShop(n.index); } else { notify('ここは侵入できるタイプではありません'); } }

function openVaultNearby(){
  const n = findNearestBuilding(); if (!n){ notify('近くに金庫はありません'); return; }
  const vault = STATE.vaults.find(v => v.buildingIndex === n.index && v.locked);
  if (!vault){ notify('この建物に金庫はありません（または既に解錠済み）'); return; }
  // show modal
  el('vaultModal').classList.add('open'); el('vaultModal').setAttribute('aria-hidden','false');
  el('vaultMsg').textContent = `金庫: 報酬 ${fmtMoney(vault.reward)} — Part2でダイヤルUIを実装します。`;
  window._currentVault = vault;
}

function openShop(buildingIndex){
  const b = STATE.buildings[buildingIndex];
  el('shopTitle').textContent = `ショップ: ${b.kind}`;
  const body = el('shopBody'); body.innerHTML = '';
  if (b.kind==='carshop'){
    body.innerHTML = `<div>車を購入できます（デモ）</div><div style="margin-top:8px"><button id="buyCar" class="btn small">車を購入 ¥12000</button></div>`;
    setTimeout(()=>{ el('buyCar').addEventListener('click', ()=>{ if (STATE.player.money >= 12000){ STATE.player.money -= 12000; STATE.player.cars += 1; notify('車を購入しました'); updateHUD(); } else notify('所持金が足りません'); }); }, 10);
  } else if (b.kind==='slots'){
    body.innerHTML = `<div>スロット（デモ） - 1回 ¥200</div><div style="margin-top:8px"><button id="playSlot" class="btn small">プレイ</button></div>`;
    setTimeout(()=>{ el('playSlot').addEventListener('click', ()=>{ if (STATE.player.money >= 200){ STATE.player.money -= 200; const win = Math.random() < 0.08; if (win){ const r = rand(600,8000); STATE.player.money += r; notify('当たり！ '+fmtMoney(r)); } else notify('ハズレ'); updateHUD(); } else notify('所持金が足りません'); }); },10);
  } else if (b.kind==='blackmarket'){
    body.innerHTML = `<div>闇銃屋（デモ） — 銃を購入できます</div><div style="margin-top:8px"><button id="buyGun" class="btn small">銃を購入 ¥4000</button></div>`;
    setTimeout(()=>{ el('buyGun').addEventListener('click', ()=>{ if (STATE.player.money >= 4000){ STATE.player.money -= 4000; STATE.player.guns += 1; notify('銃を購入しました'); updateHUD(); } else notify('所持金が足りません'); }); },10);
  } else {
    body.innerHTML = `<div>このショップはまだ中身がありません。</div>`;
  }
  el('shopModal').classList.add('open'); el('shopModal').setAttribute('aria-hidden','false');
  el('closeShop').addEventListener('click', ()=>{ el('shopModal').classList.remove('open'); el('shopModal').setAttribute('aria-hidden','true'); });
}

function tryEnterNearby(){
  const n = findNearestBuilding(); if (!n){ notify('近くに建物がありません'); return; }
  notify('建物に侵入: ' + n.building.kind + '（内部はPart3で実装）');
  // expose a hook for Part3 to handle actual interior scene
  if (window.enterBuilding) window.enterBuilding(n.index);
}

/* -----------------------
   Utility: schedule buffer rebuild (debounce)
   ----------------------- */
function scheduleRebuild(){
  rebuildScheduled = true;
  if (typeof scheduleRebuildTimer !== 'undefined') clearTimeout(scheduleRebuildTimer);
  scheduleRebuildTimer = setTimeout(()=>{ rebuildScheduled=false; buildBuffers(); }, 200);
}

/* -----------------------
   Kind color helper
   ----------------------- */
function kindToHex(kind){
  switch(kind){ case 'bank': return 0x2ecc71; case 'conbini': return 0x3498db; case 'pachinko': return 0xe67e22; case 'carshop': return 0x9b59b6; case 'slots': return 0xf1c40f; case 'blackmarket': return 0xe84393; default: return 0x95a5a6; }
}

/* -----------------------
   Initialization
   ----------------------- */
let bufferBuilt = false;
let frameReq = null, lastT = performance.now();
function start(){
  if (!initGL()) return;
  const vs = compile(VSH, gl.VERTEX_SHADER), fs = compile(FSH, gl.FRAGMENT_SHADER);
  if (!vs || !fs) { notify('シェーダ初期化失敗'); return; }
  if (!setupGLProgram()) { notify('GLプログラム構築失敗'); return; }
  // create initial data
  generateMap();
  // build buffers and start loop
  buildBuffers();
  drawMiniImmediate();
  updateHUD();
  // animation loop using rAF
  function loop(t){
    const dt = Math.min(0.05, (t - lastT)/1000); lastT = t;
    processKeyboard(dt);
    update(dt);
    frameReq = requestAnimationFrame(loop);
  }
  frameReq = requestAnimationFrame(loop);
  // expose hooks
  window._part1_ready = true;
  window._part1_update = function(dt){}; // placeholder for other parts
  window._part1_rebuild = scheduleRebuild;
  notify('Part1 初期化完了 — 3D表示中');
}

/* -----------------------
   Expose useful functions for Part2/Part3
   ----------------------- */
window.generateMap = generateMap;
window.drawMinimap = drawMiniImmediate;
window.updateHUD = updateHUD;
window.tryInteractNearby = tryInteractNearby;
window.openVaultModal = function(v){ window._currentVault = v; el('vaultModal').classList.add('open'); el('vaultModal').setAttribute('aria-hidden','false'); el('vaultMsg').textContent = `金庫: ${fmtMoney(v.reward)}（Part2でUI）`; };
window.enterBuilding = function(bIndex){ notify('enterBuilding hook called (Part3 may render interior)'); };

/* -----------------------
   Kick off
   ----------------------- */
start();

</script>
</body>
</html>
