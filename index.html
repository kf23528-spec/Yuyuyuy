<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Vault Heist — Part1 (Offline-safe)</title>
<style>
  :root{ --bg:#06101a; --panel:rgba(6,8,10,0.72); --accent:#ffde59; --muted:#98a8b3; }
  html,body{height:100%;margin:0;padding:0;background:var(--bg);color:#e6eef6;font-family:system-ui,-apple-system,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif}
  #app{position:fixed;inset:0;display:flex;flex-direction:column}
  header{height:56px;display:flex;align-items:center;padding:8px 12px;background:linear-gradient(90deg,#071428,#081726);box-shadow:0 6px 16px rgba(0,0,0,0.45);z-index:40}
  header h1{margin:0;font-size:15px}
  header .controls{margin-left:auto;display:flex;gap:8px;align-items:center}
  .btn{appearance:none;border:none;padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.03);color:inherit;cursor:pointer}
  #sceneWrap{flex:1;position:relative;overflow:hidden}
  canvas#viewport{display:block;width:100%;height:100%;background:linear-gradient(180deg,#072033,#04101a);touch-action:none}
  #hud{position:absolute;right:12px;top:72px;width:260px;background:var(--panel);border-radius:10px;padding:10px;backdrop-filter:blur(6px);z-index:55;border:1px solid rgba(255,255,255,0.03)}
  #minimap{position:absolute;left:12px;top:72px;width:160px;height:160px;background:rgba(0,0,0,0.36);border-radius:8px;padding:8px;z-index:55;border:1px solid rgba(255,255,255,0.03)}
  #controlsMobile{position:absolute;left:12px;bottom:12px;z-index:70;display:flex;gap:12px;align-items:flex-end}
  .stickOuter{width:120px;height:120px;border-radius:999px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;touch-action:none}
  .stickInner{width:54px;height:54px;border-radius:999px;background:rgba(255,255,255,0.06);transform:translate(0,0)}
  .smallBtns{display:flex;flex-direction:column;gap:8px}
  .notifBox{position:absolute;right:12px;bottom:12px;z-index:90;display:flex;flex-direction:column-reverse;gap:8px}
  .notif{background:rgba(0,0,0,0.6);padding:8px 10px;border-radius:10px;color:#eaf1f6;font-size:13px}
  .modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#0b0c0f;padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);z-index:200;display:none;max-width:96%}
  .modal.open{display:block}
  footer{height:44px;display:flex;align-items:center;justify-content:center;color:var(--muted);background:linear-gradient(90deg,#03050a,#061018)}
  /* small responsive */
  @media(max-width:720px){ #hud{width:200px} #minimap{width:120px;height:120px} }
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>Vault Heist — Part1 (Offline-safe)</h1>
    <div class="controls">
      <select id="viewMode" class="btn" title="表示モード">
        <option value="perspective">3D風パース</option>
        <option value="topdown">トップダウン</option>
      </select>
      <button id="btnNewMap" class="btn">新しいマップ</button>
      <button id="btnSave" class="btn">保存</button>
    </div>
  </header>

  <div id="sceneWrap">
    <canvas id="viewport" width="1600" height="900"></canvas>

    <div id="minimap"><canvas id="mini" width="300" height="300" style="width:100%;height:100%"></canvas><div style="font-size:12px;color:#cbd6dc;margin-top:6px">ミニマップ</div></div>

    <div id="hud">
      <div style="font-weight:700;margin-bottom:6px">プレイヤー</div>
      <div>お金: <span id="money">¥0</span></div>
      <div>銃: <span id="guns">0</span></div>
      <div>車: <span id="cars">0</span></div>
      <div>警戒度: <span id="heat">0</span></div>
      <hr style="border:none;height:1px;background:rgba(255,255,255,0.03);margin:8px 0">
      <div style="font-weight:700">マップ情報</div>
      <div>サイズ: 600 × 600</div>
      <div>金庫数: <span id="vaultCount">0</span></div>
      <div style="height:8px"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end"><button id="btnInteract" class="btn">行動</button><button id="btnVault" class="btn">金庫</button></div>
    </div>

    <div id="controlsMobile">
      <div class="stickOuter" id="joyZone"><div class="stickInner" id="stickInner"></div></div>
      <div class="smallBtns"><button id="btnFire" class="btn">発砲</button><button id="btnReload" class="btn">リロード</button></div>
    </div>

    <div class="notifBox" id="notifBox"></div>

    <div id="vaultModal" class="modal" aria-hidden="true">
      <h3>金庫（プレースホルダ）</h3>
      <p id="vaultMsg">金庫ダイヤルUIは Part2 で完全実装します。近くの金庫の基本情報:</p>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button id="closeVault" class="btn">閉じる</button>
      </div>
    </div>

  </div>

  <footer>学校タブレット対応版 — 外部ライブラリ無しで動作</footer>
</div>

<script>
/* ==========================
   Part1 Offline-safe (no external libs)
   - Canvas2D renderer with pseudo-3D perspective
   - Robust mobile + desktop controls
   - Map auto-generation (600x600)
   - Minimap, HUD, simple interactions
   ========================== */

/* --------------------------
   Utilities
   -------------------------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function fmtMoney(n){ return '¥' + Math.floor(n).toLocaleString('ja-JP'); }
function el(id){ return document.getElementById(id); }
function now(){ return performance.now(); }
function notify(msg, ttl=2600){
  const box = el('notifBox');
  const d = document.createElement('div'); d.className='notif'; d.textContent = msg;
  box.appendChild(d);
  setTimeout(()=>{ d.style.opacity='0'; setTimeout(()=>d.remove(),300) }, ttl);
}

/* --------------------------
   Global game state
   -------------------------- */
const GAME = {
  mapSize:600,
  tileSize:10, // logical; for drawing we compute scale
  player: { x:300, z:300, money:12000, guns:1, cars:0, speed:1.8 },
  buildings: [], // {kind,x,z,sx,sz}
  vaults: [], // {buildingIndex,locked, attempts, dialSolution, reward}
  view: { mode:'perspective', angle: -0.35, tilt:0.45, zoom:1.0, offsetX:0, offsetY:0 },
  input: { mx:0, my:0, moveX:0, moveY:0, firing:false },
  lastFrame: now()
};

/* --------------------------
   Asset loading (optional / graceful fallback)
   -------------------------- */
const ASSET_BASE = './assets';
const ASSETS = {
  safe_dial: ASSET_BASE + '/safe_dial.png',
  safe_body: ASSET_BASE + '/safe_body.png',
  led_green: ASSET_BASE + '/led_green.png',
  led_red: ASSET_BASE + '/led_red.png',
  click: ASSET_BASE + '/click.mp3',
  latch: ASSET_BASE + '/latch_open.mp3',
  alarm: ASSET_BASE + '/alarm.mp3'
};
const AS = { imgs: {}, audio: {} };

(function tryPreload(){
  // images
  ['safe_dial','safe_body','led_green','led_red'].forEach(k=>{
    const img = new Image();
    img.onload = ()=>{ AS.imgs[k] = img; };
    img.onerror = ()=>{ /* missing is OK */ };
    img.src = ASSETS[k];
  });
  // audio: create Audio elements but do not require them
  ['click','latch','alarm'].forEach(k=>{
    try {
      const a = new Audio(); a.src = ASSETS[k]; a.preload = 'auto'; AS.audio[k] = a;
    } catch(e){ /* ignore */ }
  });
})();

/* --------------------------
   Canvas & contexts
   -------------------------- */
const canvas = el('viewport');
const ctx = canvas.getContext('2d');
const mini = el('mini'); const mctx = mini.getContext('2d');

/* resize handling */
function fitCanvas(){
  const wrap = canvas.parentElement;
  canvas.width = Math.max(800, Math.floor(wrap.clientWidth * 1.0));
  canvas.height = Math.max(500, Math.floor(wrap.clientHeight * 1.0));
}
window.addEventListener('resize', ()=>{ fitCanvas(); drawOnce(); });

/* --------------------------
   Map generation (600x600) with building placement
   -------------------------- */
function generateMap(){
  GAME.buildings = []; GAME.vaults = [];
  const cell = 60;
  const cols = Math.floor(GAME.mapSize / cell);
  for (let r=0;r<cols;r++){
    for (let c=0;c<cols;c++){
      const x = c*cell + rand(6, cell-6);
      const z = r*cell + rand(6, cell-6);
      const roll = Math.random();
      let kind = 'dummy';
      if (roll < 0.02) kind = 'bank';
      else if (roll < 0.07) kind = 'conbini';
      else if (roll < 0.11) kind = 'pachinko';
      else if (roll < 0.14) kind = 'carshop';
      else if (roll < 0.16) kind = 'slots';
      else if (roll < 0.17) kind = 'blackmarket';
      const sx = rand(12,36), sz = rand(12,36);
      GAME.buildings.push({ kind, x, z, sx, sz });
      if (kind === 'bank' || kind === 'conbini' || kind === 'pachinko'){
        GAME.vaults.push({ buildingIndex: GAME.buildings.length-1, locked:true, attempts:0, dialSolution:[rand(0,9),rand(0,9),rand(0,9),rand(0,9)], reward: kind==='bank'?50000:(kind==='pachinko'?15000:4200) });
      }
    }
  }
  // ensure at least one bank
  if (!GAME.buildings.some(b=>b.kind==='bank')) {
    const x = rand(80, GAME.mapSize-80), z = rand(80, GAME.mapSize-80);
    GAME.buildings.push({ kind:'bank', x, z, sx:56, sz:56 });
    GAME.vaults.push({ buildingIndex: GAME.buildings.length-1, locked:true, attempts:0, dialSolution:[rand(0,9),rand(0,9),rand(0,9),rand(0,9)], reward:50000 });
  }
  el('vaultCount').textContent = GAME.vaults.length;
}

/* --------------------------
   Coordinate transforms and drawing helpers
   We render a pseudo-3D perspective: map is drawn flat, and "3D effect" is achieved by skewing building rectangles
   and applying a simple depth shading based on z-distance from camera.
   -------------------------- */
function worldToScreen(wx, wz){
  // center the map
  const ms = GAME.mapSize;
  const cx = (wx - GAME.player.x) * renderScale() + canvas.width/2 + GAME.view.offsetX;
  const cy = (wz - GAME.player.z) * renderScale() + canvas.height/2 + GAME.view.offsetY;
  return { x: cx, y: cy };
}
function renderScale(){ // pixels per map unit (zoom)
  const base = Math.min(canvas.width, canvas.height) / (GAME.mapSize * 0.9);
  return base * GAME.view.zoom;
}

/* shade color helper */
function shadeColor(hex, percent){
  // hex as number e.g. 0x112233 ; percent -1..1
  const r = (hex>>16) & 0xff, g = (hex>>8) & 0xff, b = hex & 0xff;
  const nr = clamp(Math.round(r*(1+percent)),0,255), ng = clamp(Math.round(g*(1+percent)),0,255), nb = clamp(Math.round(b*(1+percent)),0,255);
  return `rgb(${nr},${ng},${nb})`;
}

/* building base colors */
function kindToColor(k){
  switch(k){
    case 'bank': return 0x2ecc71;
    case 'conbini': return 0x3498db;
    case 'pachinko': return 0xe67e22;
    case 'carshop': return 0x9b59b6;
    case 'slots': return 0xf1c40f;
    case 'blackmarket': return 0xe84393;
    default: return 0x95a5a6;
  }
}

/* draw entire scene once (called each frame by animate) */
function drawScene(dt){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background gradient
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,'#072033'); g.addColorStop(1,'#04101a');
  ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

  // compute scale
  const s = renderScale();

  // draw ground grid (subtle)
  ctx.save();
  ctx.globalAlpha = 0.18;
  ctx.strokeStyle = '#03181f';
  ctx.lineWidth = 1;
  const step = 60 * s;
  const offsetX = (canvas.width/2 + GAME.view.offsetX) % step;
  const offsetY = (canvas.height/2 + GAME.view.offsetY) % step;
  for (let x = -step*3 + offsetX; x < canvas.width+step*3; x += step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
  for (let y = -step*3 + offsetY; y < canvas.height+step*3; y += step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
  ctx.restore();

  // draw buildings (sort by z to simulate depth)
  const bcopy = GAME.buildings.map((b,idx)=>({...b, idx}));
  bcopy.sort((a,b)=> (a.z - GAME.player.z) - (b.z - GAME.player.z) ); // back to front
  bcopy.forEach(b=>{
    drawBuilding(b, s);
  });

  // draw player as a simple icon (in middle)
  drawPlayer();

  // draw HUD overlay elements like labels for nearest building if needed
}

/* draw a building with pseudo-3D */
function drawBuilding(b, s){
  // center location relative to player
  const sx = b.sx * s, sz = b.sz * s;
  const screen = worldToScreen(b.x, b.z);
  // use tilt to create perspective: roof offset
  const tilt = GAME.view.tilt; // 0..1
  const depth = sz * tilt * 0.5;
  // compute face polygon
  const left = screen.x - sx/2, right = screen.x + sx/2;
  const top = screen.y - sz/2 - depth, bottom = screen.y + sz/2;
  // color and shading by distance
  const dist = Math.hypot((b.x - GAME.player.x), (b.z - GAME.player.z));
  const shade = clamp(1 - (dist / (GAME.mapSize*0.8)), 0.3, 1.0);
  const baseColor = kindToColor(b.kind);
  ctx.fillStyle = shadeColor(baseColor, (shade - 1) * 0.35);
  // draw front face rectangle (as building body)
  ctx.beginPath();
  ctx.moveTo(left, top);
  ctx.lineTo(right, top);
  ctx.lineTo(right, bottom);
  ctx.lineTo(left, bottom);
  ctx.closePath();
  ctx.fill();
  // draw roof (shift upwards a bit)
  ctx.fillStyle = shadeColor(baseColor, (shade - 1) * 0.55);
  ctx.beginPath();
  ctx.moveTo(left, top - depth);
  ctx.lineTo(right, top - depth);
  ctx.lineTo(right, top);
  ctx.lineTo(left, top);
  ctx.closePath();
  ctx.fill();
  // outline
  ctx.strokeStyle = 'rgba(0,0,0,0.25)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // small label text
  ctx.fillStyle = '#eaf1f6';
  ctx.font = `${Math.max(10, Math.min(14, Math.round(12 * (s*0.6))))}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText(b.kind, screen.x, top - 6);
}

/* player draw */
function drawPlayer(){
  const midX = canvas.width/2 + GAME.view.offsetX;
  const midY = canvas.height/2 + GAME.view.offsetY;
  // shadow
  ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.ellipse(midX, midY+18, 18, 8, 0, 0, Math.PI*2); ctx.fill();
  // body
  ctx.beginPath(); ctx.fillStyle = '#ffc857'; ctx.arc(midX, midY, 12, 0, Math.PI*2); ctx.fill();
  // facing indicator (a triangle)
  ctx.beginPath(); ctx.fillStyle = '#332211'; ctx.moveTo(midX, midY-14); ctx.lineTo(midX-6, midY-4); ctx.lineTo(midX+6, midY-4); ctx.closePath(); ctx.fill();
}

/* --------------------------
   Minimap rendering
   -------------------------- */
function drawMinimap(){
  const W = mini.width, H = mini.height; mctx.clearRect(0,0,W,H);
  mctx.fillStyle = '#02111a'; mctx.fillRect(0,0,W,H);
  const s = W / GAME.mapSize;
  GAME.buildings.forEach(b=>{
    const x = Math.round(b.x * s), y = Math.round(b.z * s);
    const w = clamp(Math.round(b.sx * s), 2, 12), h = clamp(Math.round(b.sz * s), 2, 12);
    const col = (b.kind==='bank'?'#2ecc71':(b.kind==='conbini'?'#3498db':(b.kind==='pachinko'?'#e67e22':'#95a5a6')));
    mctx.fillStyle = col; mctx.fillRect(x-w/2,y-h/2,w,h);
  });
  // player
  const px = Math.round(GAME.player.x * (W/GAME.mapSize)), pz = Math.round(GAME.player.z * (H/GAME.mapSize));
  mctx.beginPath(); mctx.fillStyle = '#ffde59'; mctx.arc(px,pz,6,0,Math.PI*2); mctx.fill();
}

/* --------------------------
   Controls (virtual stick + mouse drag + keyboard)
   -------------------------- */
let stickCenter = null, draggingStick = false;
const stickEl = el('stickInner'), outerEl = el('joyZone');
outerEl.addEventListener('pointerdown', e=>{ e.preventDefault(); draggingStick = true; outerEl.setPointerCapture(e.pointerId); const r = outerEl.getBoundingClientRect(); stickCenter = { x:r.left + r.width/2, y:r.top + r.height/2 }; onStickMove(e.clientX, e.clientY); });
window.addEventListener('pointermove', e=>{ if (draggingStick) onStickMove(e.clientX, e.clientY); });
window.addEventListener('pointerup', e=>{ if (draggingStick) { draggingStick=false; stickInnerReset(); GAME.input.moveX=0; GAME.input.moveY=0; } });

function onStickMove(cx, cy){
  const dx = cx - stickCenter.x, dy = cy - stickCenter.y;
  const max = 44;
  const nx = clamp(dx / max, -1, 1), ny = clamp(dy / max, -1, 1);
  stickEl.style.transform = `translate(${clamp(dx,-max,max)}px, ${clamp(dy,-max,max)}px)`;
  // note: moveY positive = down; we invert to typical forward/up usage
  GAME.input.moveX = nx; GAME.input.moveY = ny;
}
function stickInnerReset(){ stickEl.style.transform = 'translate(0,0)'; }

/* mouse drag to rotate view */
let draggingView = false, lastViewPos = null;
canvas.addEventListener('pointerdown', (e)=>{
  if (e.button === 0 && !isOnUI(e)) { draggingView = true; lastViewPos = {x:e.clientX, y:e.clientY}; canvas.setPointerCapture(e.pointerId); }
});
canvas.addEventListener('pointermove', (e)=>{ if (draggingView && lastViewPos){ const dx = e.clientX - lastViewPos.x, dy = e.clientY - lastViewPos.y; lastViewPos = {x:e.clientX, y:e.clientY};
  // rotate angle and tilt
  GAME.view.angle += dx * 0.002; GAME.view.tilt = clamp(GAME.view.tilt + dy * -0.002, 0.15, 0.9);
}});
canvas.addEventListener('pointerup', (e)=>{ draggingView=false; lastViewPos=null; });

function isOnUI(e){
  // don't treat UI clicks as dragging the scene; check if target is HUD/controls/modal
  const p = e.target;
  return p.closest && (p.closest('#hud') || p.closest('#minimap') || p.closest('#vaultModal') || p.closest('.btn') || p.closest('#controlsMobile'));
}

/* keyboard */
window.addEventListener('keydown', e=>{
  if (e.key === 'w' || e.key === 'ArrowUp') GAME.input.moveY = -1;
  if (e.key === 's' || e.key === 'ArrowDown') GAME.input.moveY = 1;
  if (e.key === 'a' || e.key === 'ArrowLeft') GAME.input.moveX = -1;
  if (e.key === 'd' || e.key === 'ArrowRight') GAME.input.moveX = 1;
  if (e.key === ' ') { GAME.input.firing = true; setTimeout(()=>GAME.input.firing=false,140); }
});
window.addEventListener('keyup', e=>{
  if (['w','s','ArrowUp','ArrowDown'].includes(e.key)) GAME.input.moveY = 0;
  if (['a','d','ArrowLeft','ArrowRight'].includes(e.key)) GAME.input.moveX = 0;
});

/* pinch zoom (mobile) */
let pinchStart = null;
canvas.addEventListener('touchstart', e=>{
  if (e.touches.length === 2) {
    const a = e.touches[0], b = e.touches[1];
    pinchStart = Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
  }
});
canvas.addEventListener('touchmove', e=>{
  if (e.touches.length === 2 && pinchStart) {
    const a = e.touches[0], b = e.touches[1];
    const cur = Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
    const diff = (cur - pinchStart) * 0.002;
    GAME.view.zoom = clamp(GAME.view.zoom + diff, 0.6, 2.2);
    pinchStart = cur;
  }
});
canvas.addEventListener('touchend', e=>{ if (e.touches.length < 2) pinchStart = null; });

/* --------------------------
   Interaction: tryInteractNearby / openVaultIfNearby
   -------------------------- */
function tryInteractNearby(){
  let nearest=null, nd=1e9, idx=-1;
  GAME.buildings.forEach((b,i)=>{ const d = Math.hypot(b.x - GAME.player.x, b.z - GAME.player.z); if (d < nd){ nd=d; nearest=b; idx=i; } });
  if (nearest && nd < 36){
    notify('建物: ' + nearest.kind);
    if (['bank','conbini','pachinko'].includes(nearest.kind)){
      // find vault
      const vault = GAME.vaults.find(v => v.buildingIndex === idx && v.locked);
      if (vault){ openVaultModal(vault); return; }
      else notify('この建物の金庫は既に解錠済み'); return;
    } else {
      // other building: enter (Part3 will expand)
      notify('建物に侵入できます（Part3で室内を表示）');
      return;
    }
  } else notify('近くに入れる建物がありません');
}

function openVaultIfNearby(){ tryInteractNearby(); }

/* modal for vault placeholder */
function openVaultModal(v){
  const modal = el('vaultModal'); modal.classList.add('open'); modal.setAttribute('aria-hidden','false');
  el('vaultMsg').textContent = `近くの金庫 (報酬: ${fmtMoney(v.reward)}) 。Part2でダイヤルUI実装予定。`; 
  // record current vault for Part2 when available
  window._currentVault = v;
}
el('closeVault').addEventListener('click', ()=>{ const m = el('vaultModal'); m.classList.remove('open'); m.setAttribute('aria-hidden','true'); });

/* --------------------------
   Main update loop
   -------------------------- */
function update(dt){
  // movement from input (joystick or keyboard)
  const mx = GAME.input.moveX || 0, my = GAME.input.moveY || 0;
  if (mx !== 0 || my !== 0){
    // transform movement by view.angle so forward is camera-up
    const ang = GAME.view.angle;
    const vx = mx * Math.cos(ang) - my * Math.sin(ang);
    const vz = mx * Math.sin(ang) + my * Math.cos(ang);
    GAME.player.x += vx * GAME.player.speed * 18 * dt;
    GAME.player.z += vz * GAME.player.speed * 18 * dt;
    GAME.player.x = clamp(GAME.player.x, 0, GAME.mapSize);
    GAME.player.z = clamp(GAME.player.z, 0, GAME.mapSize);
  }

  // friction on offsets (camera smoothing)
  GAME.view.offsetX *= 0.92; GAME.view.offsetY *= 0.92;

  // update HUD
  el('money').textContent = fmtMoney(GAME.player.money);
  el('guns').textContent = GAME.player.guns;
  el('cars').textContent = GAME.player.cars;
  el('heat').textContent = Math.round(GAME.heat||0);

  // redraw scene
  drawScene(dt);
  drawMinimap();

  // Part2/Part3 hooks if available (non-blocking)
  try { if (window._part2_update) window._part2_update(dt); if (window._part3_update) window._part3_update(dt); } catch(e){ /* ignore */ }
}

/* animation loop */
function loop(t){
  const last = GAME.lastFrame || t; const dt = Math.min(0.05, (t - last)/1000); GAME.lastFrame = t;
  update(dt);
  requestAnimationFrame(loop);
}

/* draw once (for immediate resize) */
function drawOnce(){ drawScene(0); drawMinimap(); }

/* --------------------------
   UI wiring
   -------------------------- */
el('btnNewMap').addEventListener('click', ()=>{ generateMap(); drawOnce(); notify('マップを再生成しました'); });
el('btnSave').addEventListener('click', ()=>{ try{ const s = { player: GAME.player, buildings: GAME.buildings, vaults: GAME.vaults }; localStorage.setItem('vh_save_part1', JSON.stringify(s)); notify('保存しました'); } catch(e){ notify('保存に失敗しました'); } });
el('btnInteract').addEventListener('click', ()=> tryInteractNearby());
el('btnVault').addEventListener('click', ()=> openVaultIfNearby());
el('btnFire').addEventListener('click', ()=> { notify('発砲（HUD） — Part3で弾可視化を実装'); });
el('viewMode').addEventListener('change', (e)=>{ GAME.view.mode = e.target.value; notify('表示モード: ' + e.target.value); });

/* --------------------------
   Init
   -------------------------- */
function init(){
  fitCanvas();
  generateMap();
  drawOnce();
  requestAnimationFrame(loop);
  notify('Part1 (オフライン版) が起動しました');
}
init();

/* expose APIs for later parts */
window.generateMap = generateMap;
window.openVaultModal = openVaultModal;
window.tryInteractNearby = tryInteractNearby;
window.openVaultIfNearby = openVaultIfNearby;

</script>
</body>
</html>
