<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Vault Heist — Part1 Expanded (Front)</title>
<style>
:root{
  --bg:#051219; --panel:rgba(8,10,12,0.78); --accent:#ffde59; --muted:#9fb1bd;
}
html,body{height:100%;margin:0;padding:0;background:var(--bg);color:#e8eef6;font-family:system-ui,-apple-system,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif}
#app{position:fixed;inset:0;display:flex;flex-direction:column}
header{height:64px;display:flex;align-items:center;padding:10px 14px;background:linear-gradient(90deg,#07101a,#0b1220);box-shadow:0 6px 20px rgba(0,0,0,0.45);z-index:40}
header h1{margin:0;font-size:16px}
.controls{margin-left:auto;display:flex;gap:10px;align-items:center}
.btn{appearance:none;border:none;padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.03);color:inherit;cursor:pointer}
#sceneWrap{flex:1;position:relative;overflow:hidden}
canvas#glcanvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#072033,#04101a);touch-action:none}
#hud{position:absolute;right:12px;top:82px;width:300px;background:var(--panel);border-radius:10px;padding:12px;backdrop-filter:blur(6px);z-index:60;border:1px solid rgba(255,255,255,0.03)}
#minimap{position:absolute;left:12px;top:82px;width:200px;height:200px;background:rgba(0,0,0,0.36);border-radius:8px;padding:8px;z-index:60;border:1px solid rgba(255,255,255,0.03)}
#controlsMobile{position:absolute;left:12px;bottom:12px;z-index:70;display:flex;gap:12px;align-items:flex-end}
.stickOuter{width:120px;height:120px;border-radius:999px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;touch-action:none}
.stickInner{width:52px;height:52px;border-radius:999px;background:rgba(255,255,255,0.06);transform:translate(0,0)}
.notifBox{position:absolute;right:12px;bottom:12px;z-index:90;display:flex;flex-direction:column-reverse;gap:8px}
.notif{background:rgba(0,0,0,0.6);padding:8px 10px;border-radius:10px;color:#eaf1f6;font-size:13px}
.modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#0b0c0f;padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);z-index:200;display:none;max-width:96%}
.modal.open{display:block}
.footer{height:44px;display:flex;align-items:center;justify-content:center;color:var(--muted);background:linear-gradient(90deg,#03050a,#061018)}
.debugOverlay{position:absolute;left:12px;bottom:12px;color:#cbd6dc;font-size:12px;z-index:95}
@media(max-width:720px){ #hud{width:220px} #minimap{width:140px;height:140px} }
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>Vault Heist — Part1 Expanded (Front)</h1>
    <div class="controls">
      <select id="presetSelect" class="btn" title="見た目プリセット">
        <option value="trash">普通にゴミ</option>
        <option value="normal" selected>普通</option>
        <option value="god">普通に神</option>
      </select>
      <select id="timeSpeed" class="btn" title="時間の速さ">
        <option value="1">リアルタイム</option>
        <option value="6" selected>6x（検証向け）</option>
        <option value="60">60x（速い）</option>
      </select>
      <button id="btnNewMap" class="btn">新しく</button>
      <button id="btnSave" class="btn">保存</button>
    </div>
  </header>

  <div id="sceneWrap">
    <canvas id="glcanvas"></canvas>

    <div id="minimap">
      <canvas id="mini" width="300" height="300" style="width:100%;height:100%"></canvas>
      <div style="font-size:12px;color:#cbd6dc;margin-top:6px">ミニマップ</div>
    </div>

    <div id="hud">
      <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:800">プレイヤー</div><div style="font-size:12px;color:#9fb1bd">時間: <span id="timeLabel">午前 06:00</span></div></div>
      <div style="margin-top:8px">お金: <span id="money">¥0</span></div>
      <div>銃: <span id="guns">0</span></div>
      <div>車: <span id="cars">0</span></div>
      <div>警戒度: <span id="heat">0</span></div>
      <hr style="border:none;height:1px;background:rgba(255,255,255,0.03);margin:10px 0">
      <div style="font-weight:700">マップ情報</div>
      <div>サイズ: 600×600</div>
      <div>金庫数: <span id="vaultCount">0</span></div>
      <div style="height:8px"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end"><button id="btnInteract" class="btn">行動</button><button id="btnVault" class="btn">金庫</button></div>
    </div>

    <div id="controlsMobile">
      <div class="stickOuter" id="joyZone"><div class="stickInner" id="stickInner"></div></div>
    </div>

    <div class="notifBox" id="notifBox"></div>
    <div class="debugOverlay" id="debugOverlay"></div>

    <div id="vaultModal" class="modal" aria-hidden="true">
      <h3>金庫（プレースホルダ）</h3>
      <p id="vaultMsg">Part2でリッチなダイヤル演出を追加します。</p>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button id="closeVault" class="btn">閉じる</button>
      </div>
    </div>

  </div>

  <div class="footer">Part1 Expanded — Front: Rendering & World</div>
</div>

<script>
/* Part1 Expanded (Front)
   - WebGL safe initialization and robust pipeline
   - Map + roads + buildings placed along roads
   - Moving vehicles with simple pathing
   - Day/night cycle and lighting adjustments
   - Camera controls & mobile joystick
   - Minimap shows player + vehicles
   - Hooks:
       window._part1_update(dt)
       window._vehicles (array)
       window._sceneObjects (meta)
*/

/* =========================
   Basic utilities
   ========================= */
function el(id){ return document.getElementById(id); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function fmtMoney(n){ return '¥' + Math.floor(n).toLocaleString('ja-JP'); }
function nowMs(){ return performance.now(); }
function notify(text, ttl=2600){ const box = el('notifBox'); const d = document.createElement('div'); d.className='notif'; d.textContent=text; box.appendChild(d); setTimeout(()=>{ d.style.opacity='0'; setTimeout(()=>d.remove(),300) }, ttl); }

/* =========================
   State
   ========================= */
const STATE = {
  mapSize:600,
  player: { x:300, z:300, money:20000, guns:1, cars:0, speed:2.2 },
  buildings: [],
  vaults: [],
  vehicles: [], // dynamic
  timeOfDay: 6*3600, // seconds since midnight (start 6:00)
  timeSpeed: parseFloat(el('timeSpeed')?.value || 6), // times realtime
  preset: 'normal'
};
window._vehicles = STATE.vehicles;
window._sceneObjects = { buildings: STATE.buildings, vaults: STATE.vaults };

/* =========================
   WebGL safe init (like previous, but extended)
   ========================= */
const canvas = el('glcanvas');
let gl = null;
function initGL(){
  const opts = {
    antialias: false,
    alpha: false,
    depth: true,
    stencil: false,
    preserveDrawingBuffer: false,
    powerPreference: "default",
    failIfMajorPerformanceCaveat: false
  };
  gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts);
  if (!gl) { el('sceneWrap').innerHTML = '<div style="color:#fff;padding:20px">WebGL が利用できません。管理者に相談してください。</div>'; return false; }
  gl.clearColor(0.03, 0.08, 0.12, 1.0);
  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LEQUAL);
  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);
  return true;
}

/* Simple shader sources (Lambert-like) */
const VERT = `
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec4 aColor;
uniform mat4 uMVP;
uniform mat4 uModel;
uniform mat4 uNormal;
varying vec3 vNormal;
varying vec4 vColor;
void main(){
  gl_Position = uMVP * vec4(aPosition,1.0);
  vNormal = mat3(uNormal) * aNormal;
  vColor = aColor;
}
`;
const FRAG = `
precision mediump float;
varying vec3 vNormal;
varying vec4 vColor;
uniform vec3 uLightDir;
uniform float uLightIntensity;
uniform vec3 uAmbient;
uniform vec3 uFogColor;
uniform float uFogNear;
uniform float uFogFar;
void main(){
  vec3 n = normalize(vNormal);
  float diff = max(dot(n, normalize(uLightDir)), 0.0);
  vec3 col = vColor.rgb * (uAmbient + uLightIntensity * diff);
  // simple distance-based fog
  float z = gl_FragCoord.z / gl_FragCoord.w;
  float fog = clamp((uFogFar - z) / (uFogFar - uFogNear), 0.0, 1.0);
  col = mix(uFogColor, col, fog);
  gl_FragColor = vec4(col, vColor.a);
}
`;

/* compile helpers */
function compile(src, type){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error('Shader error', gl.getShaderInfoLog(s));
    return null;
  }
  return s;
}
function createProgram(vs, fs){
  const vsS = compile(vs, gl.VERTEX_SHADER), fsS = compile(fs, gl.FRAGMENT_SHADER);
  if (!vsS || !fsS) return null;
  const prog = gl.createProgram();
  gl.attachShader(prog, vsS); gl.attachShader(prog, fsS); gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)){
    console.error('Program link error', gl.getProgramInfoLog(prog));
    return null;
  }
  return prog;
}

/* =========================
   Geometry utilities
   ========================= */
/* build a box mesh (positions, normals, colors, indices) centered at origin */
function makeBox(sx, sy, sz, color){
  const x = sx/2, y = sy/2, z = sz/2;
  const positions = new Float32Array([
    -x,-y,z,  x,-y,z,  x,y,z,  -x,y,z,
    x,-y,-z, -x,-y,-z, -x,y,-z, x,y,-z,
    -x,-y,-z, -x,-y,z, -x,y,z, -x,y,-z,
    x,-y,z, x,-y,-z, x,y,-z, x,y,z,
    -x,y,z, x,y,z, x,y,-z, -x,y,-z,
    -x,-y,-z, x,-y,-z, x,-y,z, -x,-y,z
  ]);
  const normals = new Float32Array([
    0,0,1,0,0,1,0,0,1,0,0,1,
    0,0,-1,0,0,-1,0,0,-1,0,0,-1,
    -1,0,0,-1,0,0,-1,0,0,-1,0,0,
    1,0,0,1,0,0,1,0,0,1,0,0,
    0,1,0,0,1,0,0,1,0,0,1,0,
    0,-1,0,0,-1,0,0,-1,0,0,-1,0
  ]);
  const cols = new Float32Array(24*4);
  for (let i=0;i<24;i++){
    cols[i*4+0] = color[0]; cols[i*4+1] = color[1]; cols[i*4+2] = color[2]; cols[i*4+3] = 1.0;
  }
  const indices = new Uint16Array([
    0,1,2, 0,2,3, 4,5,6, 4,6,7,
    8,9,10, 8,10,11, 12,13,14, 12,14,15,
    16,17,18, 16,18,19, 20,21,22, 20,22,23
  ]);
  return { positions, normals, cols, indices };
}

/* =========================
   GL program & buffers
   ========================= */
let prog = null, attrib = {}, uni = {};
let vboPos=null, vboNorm=null, vboCol=null, ibo=null, indexCount=0;
function prepareGL(){
  prog = createProgram(VERT, FRAG);
  if (!prog) return false;
  attrib.aPosition = gl.getAttribLocation(prog, 'aPosition');
  attrib.aNormal = gl.getAttribLocation(prog, 'aNormal');
  attrib.aColor = gl.getAttribLocation(prog, 'aColor');
  uni.uMVP = gl.getUniformLocation(prog, 'uMVP');
  uni.uModel = gl.getUniformLocation(prog, 'uModel');
  uni.uNormal = gl.getUniformLocation(prog, 'uNormal');
  uni.uLightDir = gl.getUniformLocation(prog, 'uLightDir');
  uni.uLightIntensity = gl.getUniformLocation(prog, 'uLightIntensity');
  uni.uAmbient = gl.getUniformLocation(prog, 'uAmbient');
  uni.uFogColor = gl.getUniformLocation(prog, 'uFogColor');
  uni.uFogNear = gl.getUniformLocation(prog, 'uFogNear');
  uni.uFogFar = gl.getUniformLocation(prog, 'uFogFar');

  vboPos = gl.createBuffer(); vboNorm = gl.createBuffer(); vboCol = gl.createBuffer(); ibo = gl.createBuffer();
  return true;
}

/* =========================
   Scene construction & buffering
   - We'll build a combined VBO containing ground + buildings + static objects
   - Vehicles are drawn separately each frame (small overhead)
   ========================= */
function buildSceneBuffer(){
  // accumulate arrays
  const posA = [], normA = [], colA = [], idxA = [];
  let vertOffset = 0;
  // ground (thin large box) at y = -1..+1
  const ground = makeBox(STATE.mapSize, 2, STATE.mapSize, [0.09,0.16,0.20]);
  appendMesh(ground, [0,-1,0]);
  // buildings (placed nearby)
  STATE.buildings.forEach(b=>{
    const matColor = hexToNorm(kindToColor(b.kind));
    const box = makeBox(b.sx, b.height, b.sz, matColor);
    appendMesh(box, [b.x - STATE.mapSize/2, b.height/2, b.z - STATE.mapSize/2]);
  });
  // a large test landmark box to confirm visibility
  const testBox = makeBox(28,28,28, [1.0,0.22,0.22]);
  appendMesh(testBox, [0,14,0]);

  function appendMesh(mesh, translate){
    const base = posA.length / 3;
    // positions
    for (let i=0;i<mesh.positions.length;i+=3){
      posA.push(mesh.positions[i] + translate[0], mesh.positions[i+1] + translate[1], mesh.positions[i+2] + translate[2]);
    }
    // normals
    for (let i=0;i<mesh.normals.length;i++) normA.push(mesh.normals[i]);
    // colors
    for (let i=0;i<mesh.cols.length;i++) colA.push(mesh.cols[i]);
    // indices (offset)
    for (let i=0;i<mesh.indices.length;i++) idxA.push(mesh.indices[i] + base);
  }

  // upload buffers
  const posF = new Float32Array(posA);
  const normF = new Float32Array(normA);
  const colF = new Float32Array(colA);
  const idxF = new Uint16Array(idxA);

  gl.bindBuffer(gl.ARRAY_BUFFER, vboPos); gl.bufferData(gl.ARRAY_BUFFER, posF, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, vboNorm); gl.bufferData(gl.ARRAY_BUFFER, normF, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, vboCol); gl.bufferData(gl.ARRAY_BUFFER, colF, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idxF, gl.STATIC_DRAW);
  indexCount = idxF.length;
}

/* helper */
function hexToNorm(hex){
  return [((hex>>16)&0xff)/255, ((hex>>8)&0xff)/255, (hex&0xff)/255];
}
function kindToColor(k){
  switch(k){
    case 'bank': return 0x2ecc71;
    case 'conbini': return 0x3498db;
    case 'pachinko': return 0xe67e22;
    case 'carshop': return 0x9b59b6;
    case 'slots': return 0xf1c40f;
    case 'blackmarket': return 0xe84393;
    default: return 0x95a5a6;
  }
}

/* =========================
   Road system & map placement
   - Create a grid road system and align buildings to road edges
   ========================= */
function buildRoadNetwork(){
  // simple orthogonal grid with main avenues
  const roads = [];
  const spacing = 120; // major roads every 120 units
  for (let x = 60; x < STATE.mapSize; x += spacing) roads.push({ axis:'x', pos:x });
  for (let z = 60; z < STATE.mapSize; z += spacing) roads.push({ axis:'z', pos:z });
  // now place buildings in cells between roads with some margin
  STATE.buildings = [];
  const cell = 60; const cols = Math.floor(STATE.mapSize / cell);
  for (let r=0;r<cols;r++){
    for (let c=0;c<cols;c++){
      const x = c*cell + rand(6,cell-6);
      const z = r*cell + rand(6,cell-6);
      // determine if near a road, prefer to place building near road edge
      let kind = 'dummy';
      const roll = Math.random();
      if (roll < 0.02) kind = 'bank';
      else if (roll < 0.07) kind = 'conbini';
      else if (roll < 0.11) kind = 'pachinko';
      else if (roll < 0.14) kind = 'carshop';
      else if (roll < 0.16) kind = 'slots';
      else if (roll < 0.17) kind = 'blackmarket';
      const sx = rand(12,36), sz = rand(12,36), height = rand(24, 84);
      STATE.buildings.push({ kind, x, z, sx, sz, height });
    }
  }
  // vault assignment
  STATE.vaults = [];
  STATE.buildings.forEach((b,i)=>{
    if (b.kind==='bank' || b.kind==='conbini' || b.kind==='pachinko'){
      STATE.vaults.push({ buildingIndex:i, locked:true, attempts:0, dialSolution:[rand(0,9),rand(0,9),rand(0,9),rand(0,9)], reward: b.kind==='bank'?60000:(b.kind==='pachinko'?16000:4800) });
    }
  });
  el('vaultCount').textContent = STATE.vaults.length;
}

/* =========================
   Vehicles: simple path follower for roads
   - Represented as small objects with position & direction; drawn as colored boxes each frame
   - Added to STATE.vehicles
   ========================= */
function spawnVehicles(count=24){
  STATE.vehicles.length = 0;
  for (let i=0;i<count;i++){
    // choose a random road-adjacent starting position
    const x = rand(40, STATE.mapSize-40);
    const z = rand(40, STATE.mapSize-40);
    const dir = Math.random() < 0.5 ? 1 : -1;
    const speed = 40 + Math.random()*60;
    const color = [Math.random()*0.9+0.1, Math.random()*0.9+0.1, Math.random()*0.9+0.1];
    STATE.vehicles.push({ x, z, dir, speed, color, lane: Math.random() < 0.5 ? 'x' : 'z' });
  }
  window._vehicles = STATE.vehicles;
}

/* vehicle update */
function updateVehicles(dt){
  for (let v of STATE.vehicles){
    // lane-based movement: if lane 'x', move along x axis; else along z axis
    if (v.lane === 'x'){
      v.x += v.dir * v.speed * dt;
      if (v.x < 0) v.x = STATE.mapSize; if (v.x > STATE.mapSize) v.x = 0;
    } else {
      v.z += v.dir * v.speed * dt;
      if (v.z < 0) v.z = STATE.mapSize; if (v.z > STATE.mapSize) v.z = 0;
    }
  }
}

/* =========================
   Rendering: matrix helpers & drawing
   ========================= */
/* minimal mat4 helpers (same as earlier but local) */
function mat4Identity(){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
function mat4Multiply(a,b){
  const o = new Array(16);
  for (let i=0;i<4;i++) for (let j=0;j<4;j++){
    let s = 0;
    for (let k=0;k<4;k++) s += a[i*4+k] * b[k*4+j];
    o[i*4+j] = s;
  }
  return o;
}
function mat4Perspective(fov, aspect, near, far){
  const f = 1.0 / Math.tan(fov/2);
  const nf = 1/(near - far);
  const out = new Array(16).fill(0);
  out[0] = f / aspect; out[5] = f; out[10] = (far + near) * nf; out[11] = -1; out[14] = (2*far*near) * nf;
  return out;
}
function mat4LookAt(eye, center, up){
  let zx = eye[0] - center[0], zy = eye[1] - center[1], zz = eye[2] - center[2];
  let len = Math.hypot(zx,zy,zz); if (len) { zx/=len; zy/=len; zz/=len; }
  let xx = up[1]*zz - up[2]*zy, xy = up[2]*zx - up[0]*zz, xz = up[0]*zy - up[1]*zx;
  len = Math.hypot(xx,xy,xz); if (len) { xx/=len; xy/=len; xz/=len; }
  let yx = zy * xz - zz * xy, yy = zz * xx - zx * xz, yz = zx * xy - zy * xx;
  const out = [ xx, yx, zx, 0, xy, yy, zy, 0, xz, yz, zz, 0, 0,0,0,1 ];
  const trans = mat4Identity(); trans[12] = -eye[0]; trans[13] = -eye[1]; trans[14] = -eye[2];
  return mat4Multiply(out, trans);
}

/* compute MVP and set uniforms */
function setCommonUniforms(proj, view){
  const model = mat4Identity();
  const normal = mat4Identity();
  const mvp = mat4Multiply(proj, view);
  gl.uniformMatrix4fv(uni.uMVP, false, new Float32Array(mvp));
  gl.uniformMatrix4fv(uni.uModel, false, new Float32Array(model));
  gl.uniformMatrix4fv(uni.uNormal, false, new Float32Array(normal));
  // lighting from time of day
  const sun = computeSunDirection();
  gl.uniform3fv(uni.uLightDir, new Float32Array(sun.dir));
  gl.uniform1f(uni.uLightIntensity, sun.intensity);
  gl.uniform3fv(uni.uAmbient, new Float32Array(sun.ambient));
  // fog color blends with sky color
  gl.uniform3fv(uni.uFogColor, new Float32Array(sun.fogColor));
  gl.uniform1f(uni.uFogNear, 80.0); gl.uniform1f(uni.uFogFar, 1000.0);
}

/* compute sun direction and ambient based on STATE.timeOfDay */
function computeSunDirection(){
  const t = (STATE.timeOfDay % 86400) / 86400; // 0..1
  // convert to angle: 0 = midnight, 0.25 = 6:00, 0.5 = noon, 0.75 = 18:00
  const angle = (t - 0.25) * Math.PI * 2; // so noon is angle 0
  // sun dir roughly from above and some rotation
  const dx = Math.cos(angle) * 0.6; const dy = Math.sin(angle) * 0.9; const dz = 0.2;
  const intensity = clamp(0.25 + (Math.max(0.0, dy) * 1.25), 0.25, 1.2);
  // ambient color warmer at dawn/dusk
  const ambient = dy > 0 ? [0.18,0.20,0.22] : [0.06,0.08,0.12];
  // fog / sky color
  const fogColor = dy > 0 ? [0.08 + (1-dy)*0.06, 0.12 + (1-dy)*0.08, 0.16 + (1-dy)*0.12] : [0.02,0.03,0.06];
  return { dir: [-dx, -dy, -dz], intensity, ambient, fogColor };
}

/* =========================
   Draw loop & updates
   ========================= */
let programReady = false;
let cam = { x: STATE.player.x - STATE.mapSize/2, y: 180, z: STATE.player.z + 220, yaw: -Math.PI/2 + 0.6, pitch: -0.45 };
let lastTime = nowMs();
function resizeCanvas(){
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const w = Math.max(640, Math.floor(canvas.clientWidth * dpr));
  const h = Math.max(480, Math.floor(canvas.clientHeight * dpr));
  if (canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
}

function render(now){
  const t = now || nowMs();
  const dt = Math.min(0.05, (t - lastTime)/1000);
  lastTime = t;

  // simulate timeOfDay
  const speed = parseFloat(el('timeSpeed').value || STATE.timeSpeed) || STATE.timeSpeed;
  STATE.timeOfDay = (STATE.timeOfDay + dt * speed) % 86400;
  updateTimeLabel();

  // update vehicles
  updateVehicles(dt);

  // process keyboard movement & joystick
  processMovement(dt);

  resizeCanvas();
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.useProgram(prog);

  // camera matrices
  const aspect = canvas.width / canvas.height;
  const proj = mat4Perspective(55 * Math.PI/180, aspect, 0.1, 2000);
  const px = STATE.player.x - STATE.mapSize/2, pz = STATE.player.z - STATE.mapSize/2;
  const eye = [ cam.x, cam.y, cam.z ];
  const center = [ px, 0, pz ];
  const view = mat4LookAt(eye, center, [0,1,0]);

  setCommonUniforms(proj, view);

  // bind buffers & attributes
  gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
  gl.enableVertexAttribArray(attrib.aPosition);
  gl.vertexAttribPointer(attrib.aPosition, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, vboNorm);
  gl.enableVertexAttribArray(attrib.aNormal);
  gl.vertexAttribPointer(attrib.aNormal, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, vboCol);
  gl.enableVertexAttribArray(attrib.aColor);
  gl.vertexAttribPointer(attrib.aColor, 4, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);

  gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);

  // draw vehicles as simple GL boxes with immediate buffer per-frame (cheap for small count)
  drawVehicles(proj, view);

  // debug overlay & minimap & HUD update
  drawMinimap();
  updateHUD();

  // call possible Part2/Part3 updates
  try { if (window._part2_update) window._part2_update(dt); if (window._part3_update) window._part3_update(dt); } catch(e){ /* ignore */ }

  requestAnimationFrame(render);
}

/* draw vehicles (simple GL draws) */
function drawVehicles(proj, view){
  // We'll draw each vehicle as a small box by creating CPU-side box and uploading per vehicle (ok for small number)
  for (let v of STATE.vehicles){
    const color = v.color;
    const box = makeBox(8, 4, 14, color); // vehicle oriented along z
    // create model transform: translate to vehicle position (convert map->world center)
    const tx = v.x - STATE.mapSize/2, tz = v.z - STATE.mapSize/2, ty = 2;
    // We'll upload a small temp buffer for this box (positions + normals + cols + indices) and draw
    const posF = box.positions.slice(); // copy
    for (let i=0;i<posF.length;i+=3){ posF[i] += tx; posF[i+1] += ty; posF[i+2] += tz; }
    const normF = box.normals;
    const colF = box.cols;
    const idxF = box.indices;

    // upload temps to ARRAY_BUFFERs (use the same vboPos/vboNorm/vboCol but with STREAM_DRAW)
    gl.bindBuffer(gl.ARRAY_BUFFER, vboPos); gl.bufferData(gl.ARRAY_BUFFER, posF, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, vboNorm); gl.bufferData(gl.ARRAY_BUFFER, normF, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, vboCol); gl.bufferData(gl.ARRAY_BUFFER, colF, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idxF, gl.DYNAMIC_DRAW);

    // set uniforms for this object (reuse common uMVP etc.)
    const model = mat4Identity();
    const normal = mat4Identity();
    const mvp = mat4Multiply(proj, view);
    gl.uniformMatrix4fv(uni.uMVP, false, new Float32Array(mvp));
    gl.uniformMatrix4fv(uni.uModel, false, new Float32Array(model));
    gl.uniformMatrix4fv(uni.uNormal, false, new Float32Array(normal));
    gl.drawElements(gl.TRIANGLES, idxF.length, gl.UNSIGNED_SHORT, 0);
    // restore scene buffers later — but we will rebuild main buffers every so often so it's fine
  }
  // after vehicles drawing, rebuild main buffers (if needed)
  // Actually to avoid flicker we will rebuild main scene buffers periodically elsewhere
}

/* =========================
   Movement handling & input
   ========================= */
const KEY = {};
window.addEventListener('keydown', (e)=>{ KEY[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', (e)=>{ KEY[e.key.toLowerCase()] = false; });

function processMovement(dt){
  let mx=0, mz=0;
  if (KEY['w']||KEY['arrowup']) mz -= 1;
  if (KEY['s']||KEY['arrowdown']) mz += 1;
  if (KEY['a']||KEY['arrowleft']) mx -= 1;
  if (KEY['d']||KEY['arrowright']) mx += 1;
  // joystick input
  if (STATE.inputStick){ mx += STATE.inputStick.x; mz += -STATE.inputStick.y; }
  if (mx!==0 || mz!==0){
    const len = Math.hypot(mx,mz) || 1;
    const nx = mx / len, nz = mz / len;
    // transform by camera yaw
    const yaw = cam.yaw;
    const worldX = nx * Math.cos(yaw) - nz * Math.sin(yaw);
    const worldZ = nx * Math.sin(yaw) + nz * Math.cos(yaw);
    STATE.player.x += worldX * STATE.player.speed * 40 * dt;
    STATE.player.z += worldZ * STATE.player.speed * 40 * dt;
    STATE.player.x = clamp(STATE.player.x, 0, STATE.mapSize);
    STATE.player.z = clamp(STATE.player.z, 0, STATE.mapSize);
    // move camera target smoothly
    updateCameraTarget();
    // schedule rebuild of player marker periodically
    scheduleBufferRebuild();
  }
}

/* joystick handlers (virtual stick) */
const stickOuter = el('joyZone'), stickInner = el('stickInner');
let stickCenter = null, draggingStick = false;
stickOuter.addEventListener('pointerdown', (e)=>{ e.preventDefault(); draggingStick=true; stickOuter.setPointerCapture(e.pointerId); const r = stickOuter.getBoundingClientRect(); stickCenter={x:r.left + r.width/2, y:r.top + r.height/2}; handleStick(e.clientX, e.clientY);} );
window.addEventListener('pointermove', (e)=>{ if (draggingStick) handleStick(e.clientX, e.clientY); });
window.addEventListener('pointerup', (e)=>{ if (draggingStick){ draggingStick=false; stickInner.style.transform='translate(0,0)'; STATE.inputStick = null; } });
function handleStick(cx, cy){
  const dx = cx - stickCenter.x, dy = cy - stickCenter.y;
  const max = 44; const nx = clamp(dx / max, -1, 1), ny = clamp(dy / max, -1, 1);
  stickInner.style.transform = `translate(${clamp(dx,-max,max)}px, ${clamp(dy,-max,max)}px)`;
  STATE.inputStick = { x: nx, y: ny };
}

/* camera orbit update */
function updateCameraTarget(){
  const px = STATE.player.x - STATE.mapSize/2, pz = STATE.player.z - STATE.mapSize/2;
  const radius = 220;
  cam.x = px + Math.cos(cam.pitch) * Math.cos(cam.yaw) * radius;
  cam.y = Math.sin(-cam.pitch) * 220 + 40;
  cam.z = pz + Math.cos(cam.pitch) * Math.sin(cam.yaw) * radius;
}

/* pointer drag rotation */
let draggingView = false, lastPos = null;
canvas.addEventListener('pointerdown', (e)=>{ if (isUI(e.target)) return; draggingView=true; lastPos={x:e.clientX,y:e.clientY}; canvas.setPointerCapture(e.pointerId); });
canvas.addEventListener('pointermove', (e)=>{ if(!draggingView) return; const dx=e.clientX-lastPos.x, dy=e.clientY-lastPos.y; lastPos={x:e.clientX,y:e.clientY}; cam.yaw -= dx * 0.006; cam.pitch = clamp(cam.pitch - dy * 0.004, -1.2, -0.12); updateCameraTarget(); });
canvas.addEventListener('pointerup', (e)=>{ draggingView=false; lastPos=null; });

function isUI(elem){ return elem.closest && (elem.closest('#hud') || elem.closest('#minimap') || elem.closest('#vaultModal') || elem.closest('.btn') || elem.closest('#controlsMobile')); }

/* schedule buffer rebuild */
let rebuildTimer = null;
function scheduleBufferRebuild(){
  if (rebuildTimer) clearTimeout(rebuildTimer);
  rebuildTimer = setTimeout(()=>{ buildSceneBuffer(); }, 220);
}

/* =========================
   Minimap draw
   ========================= */
const mini = el('mini'), mctx = mini.getContext('2d');
function drawMinimap(){
  const W = mini.width, H = mini.height;
  mctx.clearRect(0,0,W,H);
  mctx.fillStyle = '#02111a'; mctx.fillRect(0,0,W,H);
  const s = W / STATE.mapSize;
  for (let i=0;i<STATE.buildings.length;i++){
    const b = STATE.buildings[i];
    const x = Math.round(b.x * s), y = Math.round(b.z * s);
    const w = clamp(Math.round(b.sx * s), 2, 12), h = clamp(Math.round(b.sz * s), 2, 12);
    mctx.fillStyle = (b.kind==='bank'?'#2ecc71':(b.kind==='conbini'?'#3498db':(b.kind==='pachinko'?'#e67e22':'#95a5a6')));
    mctx.fillRect(x - w/2, y - h/2, w, h);
  }
  // player
  const px = Math.round(STATE.player.x * (W/STATE.mapSize)), pz = Math.round(STATE.player.z * (H/STATE.mapSize));
  mctx.beginPath(); mctx.fillStyle = '#ffde59'; mctx.arc(px,pz,6,0,Math.PI*2); mctx.fill();
  // vehicles
  for (let v of STATE.vehicles){
    const vx = Math.round(v.x * (W/STATE.mapSize)), vz = Math.round(v.z * (H/STATE.mapSize));
    mctx.fillStyle = 'rgba(255,200,120,0.95)'; mctx.fillRect(vx-2, vz-2, 4,4);
  }
}

/* =========================
   HUD updates & time label
   ========================= */
function updateHUD(){
  el('money').textContent = fmtMoney(STATE.player.money);
  el('guns').textContent = STATE.player.guns;
  el('cars').textContent = STATE.player.cars;
  el('heat').textContent = Math.round(STATE.heat || 0);
  // debug overlay
  el('debugOverlay').textContent = `Objects: ${STATE.buildings.length} | Vehicles: ${STATE.vehicles.length} | Time: ${formatTimeLabel(STATE.timeOfDay)}`;
}

/* time label */
function formatTimeLabel(sec){
  const h = Math.floor(sec/3600)%24, m = Math.floor((sec%3600)/60);
  const ampm = h < 12 ? '午前' : '午後';
  const hh = ((h % 12) === 0) ? 12 : (h % 12);
  return `${ampm} ${('0'+hh).slice(-2)}:${('0'+m).slice(-2)}`;
}
function updateTimeLabel(){ el('timeLabel').textContent = formatTimeLabel(STATE.timeOfDay); }

/* =========================
   Save/load quick
   ========================= */
el('btnSave').addEventListener('click', ()=>{
  try {
    const save = { player: STATE.player, buildings: STATE.buildings, vaults: STATE.vaults, vehicles: STATE.vehicles, timeOfDay: STATE.timeOfDay };
    localStorage.setItem('vh_part1_expanded_save', JSON.stringify(save));
    notify('セーブしました');
  } catch(e){ notify('セーブ失敗'); }
});

/* new map button */
el('btnNewMap').addEventListener('click', ()=>{
  buildRoadNetwork();
  buildSceneBuffer();
  spawnVehicles(28);
  drawMinimap();
  notify('新しい町を生成しました');
});

/* interactions */
el('btnInteract').addEventListener('click', ()=> tryInteractNearby());
el('btnVault').addEventListener('click', ()=> openVaultNearby());
el('closeVault').addEventListener('click', ()=> { el('vaultModal').classList.remove('open'); el('vaultModal').setAttribute('aria-hidden','true'); window._currentVault = null; });

/* try interact / open vault */
function tryInteractNearby(){
  let nearest=null, nd=1e9, idx=-1;
  STATE.buildings.forEach((b,i)=>{ const d=Math.hypot(b.x-STATE.player.x,b.z-STATE.player.z); if (d<nd){ nd=d; nearest=b; idx=i; } });
  if (nearest && nd<36){ notify('建物: '+nearest.kind); if (['bank','conbini','pachinko'].includes(nearest.kind)){ const vault = STATE.vaults.find(v=>v.buildingIndex===idx && v.locked); if (vault){ openVaultModal(vault); } else notify('金庫は既に解錠済み'); } else notify('建物に侵入可能（Part2で室内）'); }
  else notify('近くに入れる建物がありません');
}
function openVaultNearby(){ tryInteractNearby(); }
function openVaultModal(v){
  el('vaultModal').classList.add('open'); el('vaultModal').setAttribute('aria-hidden','false');
  el('vaultMsg').textContent = `近くの金庫（報酬：${fmtMoney(v.reward)}） — Part2でダイヤル演出を追加します`;
  window._currentVault = v;
}

/* =========================
   Init flow
   ========================= */
function start(){
  // ensure canvas size
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const w = Math.max(800, Math.floor(window.innerWidth * dpr));
  const h = Math.max(480, Math.floor((window.innerHeight - 64) * dpr));
  canvas.width = w; canvas.height = h;

  if (!initGL()) return;
  if (!prepareGL()) return;

  buildRoadNetwork();
  buildSceneBuffer();
  spawnVehicles(28);
  updateTimeLabel();
  drawMinimap();
  updateHUD();
  requestAnimationFrame(render);
  // periodic HUD updates & small buffer rebuild triggers
  setInterval(()=>{ updateHUD(); }, 800);
  window._part1_update = function(dt){}; // hook for later parts
  notify('Part1 Expanded 初期化完了');
}

/* initial run */
start();

/* expose for later parts */
window.generateMap = buildRoadNetwork;
window.buildSceneBuffers = buildSceneBuffer;
window.drawMinimap = drawMinimap;
window._part1_ready = true;
window._vehicles = STATE.vehicles;
window._sceneObjects = { buildings: STATE.buildings, vaults: STATE.vaults };

</script>
</body>
</html>
