<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Vault Heist — Part1 (WebGL Safe Core)</title>
<style>
:root{
  --bg:#06101a; --panel:rgba(6,8,10,0.78); --accent:#ffde59; --muted:#9fb1bd;
}
html,body{height:100%;margin:0;padding:0;background:var(--bg);color:#e8eef6;font-family:system-ui,-apple-system,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif}
#app{position:fixed;inset:0;display:flex;flex-direction:column}
header{height:56px;display:flex;align-items:center;padding:8px 12px;background:linear-gradient(90deg,#07101a,#0b1220);box-shadow:0 6px 18px rgba(0,0,0,0.45);z-index:40}
header h1{margin:0;font-size:15px}
.controls{margin-left:auto;display:flex;gap:8px;align-items:center}
.btn{appearance:none;border:none;padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.03);color:inherit;cursor:pointer}
#sceneWrap{flex:1;position:relative;overflow:hidden}
canvas#glcanvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#072033,#04101a);touch-action:none}
#hud{position:absolute;right:12px;top:72px;width:280px;background:var(--panel);border-radius:10px;padding:10px;backdrop-filter:blur(6px);z-index:60;border:1px solid rgba(255,255,255,0.03)}
#minimap{position:absolute;left:12px;top:72px;width:160px;height:160px;background:rgba(0,0,0,0.36);border-radius:8px;padding:8px;z-index:60;border:1px solid rgba(255,255,255,0.03)}
#controlsMobile{position:absolute;left:12px;bottom:12px;z-index:70;display:flex;gap:12px;align-items:flex-end}
.stickOuter{width:120px;height:120px;border-radius:999px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;touch-action:none}
.stickInner{width:52px;height:52px;border-radius:999px;background:rgba(255,255,255,0.06);transform:translate(0,0)}
.notifBox{position:absolute;right:12px;bottom:12px;z-index:90;display:flex;flex-direction:column-reverse;gap:8px}
.notif{background:rgba(0,0,0,0.6);padding:8px 10px;border-radius:10px;color:#eaf1f6;font-size:13px}
.modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#0b0c0f;padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);z-index:200;display:none;max-width:96%}
.modal.open{display:block}
footer{height:44px;display:flex;align-items:center;justify-content:center;color:var(--muted);background:linear-gradient(90deg,#03050a,#061018)}
@media(max-width:720px){ #hud{width:200px} #minimap{width:120px;height:120px} }
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>Vault Heist — Part1 (WebGL Safe Core)</h1>
    <div class="controls">
      <select id="presetSelect" class="btn" title="見た目プリセット">
        <option value="trash">普通にゴミ</option>
        <option value="normal" selected>普通</option>
        <option value="god">普通に神</option>
      </select>
      <button id="btnNewMap" class="btn">新しいマップ</button>
      <button id="btnSave" class="btn">保存</button>
    </div>
  </header>

  <div id="sceneWrap">
    <canvas id="glcanvas"></canvas>

    <div id="minimap">
      <canvas id="mini" width="300" height="300" style="width:100%;height:100%"></canvas>
      <div style="font-size:12px;color:#cbd6dc;margin-top:6px">ミニマップ</div>
    </div>

    <div id="hud">
      <div style="font-weight:700;margin-bottom:8px">プレイヤー</div>
      <div>お金: <span id="money">¥0</span></div>
      <div>銃: <span id="guns">0</span></div>
      <div>車: <span id="cars">0</span></div>
      <div>警戒度: <span id="heat">0</span></div>
      <hr style="border:none;height:1px;background:rgba(255,255,255,0.02);margin:8px 0">
      <div style="font-weight:700">マップ情報</div>
      <div>サイズ: 600×600</div>
      <div>金庫数: <span id="vaultCount">0</span></div>
    </div>

    <div id="controlsMobile">
      <div class="stickOuter" id="joyZone"><div class="stickInner" id="stickInner"></div></div>
      <div style="display:flex;flex-direction:column;gap:8px">
        <button class="btn" id="btnInteract">行動</button>
        <button class="btn" id="btnFire">発砲</button>
      </div>
    </div>

    <div class="notifBox" id="notifBox"></div>

    <div id="vaultModal" class="modal" aria-hidden="true">
      <h3>金庫（プレースホルダ）</h3>
      <p id="vaultMsg">金庫ダイヤルUIは Part2 で実装します。</p>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button id="closeVault" class="btn">閉じる</button>
      </div>
    </div>

  </div>

  <footer>WebGL: 安全モード初期化 — まず表示を優先</footer>
</div>

<script>
/* Part1 — WebGL-safe core (no external libs)
   - Creates a simple WebGL renderer (safe flags)
   - Renders ground + many boxes as buildings
   - Camera controls: mouse drag / touch swipe / virtual stick / keyboard
   - Minimap and HUD
   - Exposes hooks for Part2/Part3
*/

/* ===========================
   Utilities
   =========================== */
function el(id){ return document.getElementById(id); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function fmtMoney(n){ return '¥' + Math.floor(n).toLocaleString('ja-JP'); }
function notify(msg, ttl=2400){
  const box = el('notifBox'); const d = document.createElement('div'); d.className='notif'; d.textContent = msg; box.appendChild(d);
  setTimeout(()=> { d.style.opacity='0'; setTimeout(()=> d.remove(), 300); }, ttl);
}

/* ===========================
   Game State
   =========================== */
const STATE = {
  mapSize: 600,
  player: { x:300, z:300, y:0, money:15000, guns:1, cars:0, speed:2.0, hp:100 },
  buildings: [], // {kind,x,z,sx,sz,height}
  vaults: [], // {buildingIndex, locked, attempts, dialSolution, reward}
  police: [],
  heat: 0,
  preset: 'normal'
};

/* expose for other parts */
window.vh_state = STATE;

/* ===========================
   WebGL Bootstrap (safe)
   =========================== */
const canvas = el('glcanvas');
let gl = null;
function initGL(){
  // Try to get WebGL context with conservative options
  const opts = {
    antialias: false,
    alpha: false,
    depth: true,
    stencil: false,
    preserveDrawingBuffer: false,
    powerPreference: "default",
    failIfMajorPerformanceCaveat: false
  };
  gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts);
  if (!gl) {
    // if WebGL unavailable (shouldn't be in your case), show message and fallback to 2D canvas later
    console.error('WebGL not available.');
    el('sceneWrap').innerHTML = '<div style="color:#fff;padding:20px">WebGL が利用できません。管理者に相談してください。</div>';
    return false;
  }
  // set basic GL state
  gl.clearColor(0.03, 0.08, 0.12, 1.0);
  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LEQUAL);
  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);
  return true;
}

/* ===========================
   Shaders (minimal lambert + color)
   =========================== */
const VERT_SRC = `
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec4 aColor;
uniform mat4 uMVP;
uniform mat4 uModel;
uniform mat4 uNormalMat;
varying vec3 vNormal;
varying vec4 vColor;
void main(){
  gl_Position = uMVP * vec4(aPosition, 1.0);
  vNormal = mat3(uNormalMat) * aNormal;
  vColor = aColor;
}
`;
const FRAG_SRC = `
precision mediump float;
varying vec3 vNormal;
varying vec4 vColor;
uniform vec3 uLightDir;
uniform float uLightIntensity;
void main(){
  vec3 n = normalize(vNormal);
  float diff = max(dot(n, normalize(uLightDir)), 0.0);
  vec3 base = vColor.rgb;
  vec3 ambient = base * 0.28;
  vec3 diffuse = base * diff * uLightIntensity;
  gl_FragColor = vec4(ambient + diffuse, vColor.a);
}
`;

/* Shader helper */
function compileShader(src, type){
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}
function createProgram(vsSrc, fsSrc){
  const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
  const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
  if (!vs || !fs) return null;
  const prog = gl.createProgram();
  gl.attachShader(prog, vs); gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(prog));
    return null;
  }
  return prog;
}

/* ===========================
   Geometry helpers (box)
   =========================== */
function createBoxMesh(sx, sy, sz, color){
  // returns typed arrays for positions, normals, colors, indices
  // cube centered at origin
  const x = sx/2, y = sy/2, z = sz/2;
  const positions = new Float32Array([
    // front
    -x,-y, z,  x,-y, z,  x, y, z,  -x,y,z,
    // back
    x,-y,-z, -x,-y,-z, -x,y,-z,  x,y,-z,
    // left
    -x,-y,-z, -x,-y, z, -x,y,z, -x,y,-z,
    // right
    x,-y, z, x,-y,-z, x,y,-z, x,y,z,
    // top
    -x,y,z, x,y,z, x,y,-z, -x,y,-z,
    // bottom
    -x,-y,-z, x,-y,-z, x,-y,z, -x,-y,z
  ]);
  const normals = new Float32Array([
    // front
    0,0,1, 0,0,1, 0,0,1, 0,0,1,
    // back
    0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,
    // left
    -1,0,0,-1,0,0,-1,0,0,-1,0,0,
    // right
    1,0,0,1,0,0,1,0,0,1,0,0,
    // top
    0,1,0,0,1,0,0,1,0,0,1,0,
    // bottom
    0,-1,0,0,-1,0,0,-1,0,0,-1,0
  ]);
  // color per vertex
  const c = color; // RGB [0..1]
  const colors = new Float32Array(4*6*4); // 24 vertices
  for (let i=0;i<24;i++){ colors[i*4+0]=c[0]; colors[i*4+1]=c[1]; colors[i*4+2]=c[2]; colors[i*4+3]=1.0; }
  const indices = new Uint16Array([
    0,1,2, 0,2,3,    4,5,6, 4,6,7,
    8,9,10, 8,10,11, 12,13,14, 12,14,15,
    16,17,18, 16,18,19, 20,21,22, 20,22,23
  ]);
  return { positions, normals, colors, indices };
}

/* ===========================
   GL Program & Buffers
   =========================== */
let program = null;
let attribs = {}, uniforms = {};
let vboPos=null, vboNorm=null, vboColor=null, ibo=null;
let vertexCount = 0;
function prepareGL(){
  program = createProgram(VERT_SRC, FRAG_SRC);
  if (!program) { console.error('Failed to create GL program'); return false; }
  attribs.aPosition = gl.getAttribLocation(program, 'aPosition');
  attribs.aNormal = gl.getAttribLocation(program, 'aNormal');
  attribs.aColor = gl.getAttribLocation(program, 'aColor');
  uniforms.uMVP = gl.getUniformLocation(program, 'uMVP');
  uniforms.uModel = gl.getUniformLocation(program, 'uModel');
  uniforms.uNormalMat = gl.getUniformLocation(program, 'uNormalMat');
  uniforms.uLightDir = gl.getUniformLocation(program, 'uLightDir');
  uniforms.uLightIntensity = gl.getUniformLocation(program, 'uLightIntensity');

  // create buffers
  vboPos = gl.createBuffer(); vboNorm = gl.createBuffer(); vboColor = gl.createBuffer(); ibo = gl.createBuffer();
  return true;
}

/* ===========================
   Scene data (single VBO with repeated boxes)
   We'll upload many boxes by concatenating vertex arrays for each building.
   =========================== */
function buildSceneBuffers(){
  // Build geometry for all buildings + ground + player marker + big test box
  const parts = [];
  const idxMap = []; // holds offsets for each part
  let vertexOffset = 0, indexOffset = 0;
  const indicesArray = [];
  const positionsArray = [];
  const normalsArray = [];
  const colorsArray = [];
  // ground: a large flat box (very thin)
  const ground = createBoxMesh(STATE.mapSize, 2, STATE.mapSize, [0.09,0.16,0.20]);
  appendMesh(ground, [0, -1, 0]); // model at y=-1 so top at y=0
  // buildings
  STATE.buildings.forEach((b, i)=>{
    // box at (b.x - map/2, height/2, b.z - map/2)
    const h = b.height || rand(22, 86);
    const col = hexToRgbNorm(kindColor(b.kind));
    const mesh = createBoxMesh(b.sx, h, b.sz, col);
    appendMesh(mesh, [b.x - STATE.mapSize/2, h/2, b.z - STATE.mapSize/2]);
  });
  // big test box (easy to spot)
  const testMesh = createBoxMesh(28, 28, 28, [1.0, 0.25, 0.25]);
  appendMesh(testMesh, [0, 14, 0]); // center
  // player marker box
  const pm = createBoxMesh(8, 18, 8, [1.0, 0.78, 0.34]);
  appendMesh(pm, [STATE.player.x - STATE.mapSize/2, 9, STATE.player.z - STATE.mapSize/2]);

  // helper functions to accumulate
  function appendMesh(mesh, modelTranslate){
    const basePosLen = positionsArray.length/3;
    // model transform: translate vertices by modelTranslate
    for (let i=0;i<mesh.positions.length/3;i++){
      const vx = mesh.positions[i*3+0] + modelTranslate[0];
      const vy = mesh.positions[i*3+1] + modelTranslate[1];
      const vz = mesh.positions[i*3+2] + modelTranslate[2];
      positionsArray.push(vx, vy, vz);
    }
    for (let i=0;i<mesh.normals.length;i++) normalsArray.push(mesh.normals[i]);
    for (let i=0;i<mesh.colors.length;i++) colorsArray.push(mesh.colors[i]);
    for (let i=0;i<mesh.indices.length;i++){
      indicesArray.push(mesh.indices[i] + basePosLen);
    }
  }

  // upload to GL
  const posArr = new Float32Array(positionsArray);
  const normArr = new Float32Array(normalsArray);
  const colArr = new Float32Array(colorsArray);
  const idxArr = new Uint16Array(indicesArray);

  gl.bindBuffer(gl.ARRAY_BUFFER, vboPos); gl.bufferData(gl.ARRAY_BUFFER, posArr, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, vboNorm); gl.bufferData(gl.ARRAY_BUFFER, normArr, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, vboColor); gl.bufferData(gl.ARRAY_BUFFER, colArr, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idxArr, gl.STATIC_DRAW);

  vertexCount = idxArr.length;
}

/* ===========================
   Helpers
   =========================== */
function hexToRgbNorm(hex){
  const r = ((hex>>16)&0xff)/255, g = ((hex>>8)&0xff)/255, b = (hex&0xff)/255;
  return [r,g,b];
}

/* ===========================
   Camera and Matrices
   =========================== */
// minimal mat4 functions (no external lib)
function mat4Identity(){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
function mat4Multiply(a,b){
  const o = new Array(16);
  for (let i=0;i<4;i++){
    for (let j=0;j<4;j++){
      o[i*4+j] = 0;
      for (let k=0;k<4;k++) o[i*4+j] += a[i*4+k] * b[k*4+j];
    }
  }
  return o;
}
function mat4Translate(t){ const m = mat4Identity(); m[12]=t[0]; m[13]=t[1]; m[14]=t[2]; return m; }
function mat4RotateY(a){ const c=Math.cos(a), s=Math.sin(a); return [c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]; }
function mat4RotateX(a){ const c=Math.cos(a), s=Math.sin(a); return [1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]; }
function mat4Scale(sx,sy,sz){ const m=mat4Identity(); m[0]=sx; m[5]=sy; m[10]=sz; return m; }
function mat4Perspective(fov, aspect, near, far){
  const f = 1.0 / Math.tan(fov/2);
  const nf = 1/(near - far);
  const out = new Array(16).fill(0);
  out[0]=f/aspect; out[5]=f; out[10]=(far+near)*nf; out[11]=-1; out[14]=(2*far*near)*nf;
  return out;
}
function mat4LookAt(eye, center, up){
  const zx = eye[0] - center[0], zy = eye[1] - center[1], zz = eye[2] - center[2];
  let len = Math.hypot(zx,zy,zz); if (len===0) { zx=0; zy=0; zz=1; } else { zx/=len; zy/=len; zz/=len; }
  let xx = up[1]*zz - up[2]*zy, xy = up[2]*zx - up[0]*zz, xz = up[0]*zy - up[1]*zx;
  len = Math.hypot(xx,xy,xz); if(len===0){ xx=0; xy=0; xz=0; } else { xx/=len; xy/=len; xz/=len; }
  let yx = zy * xz - zz * xy, yy = zz * xx - zx * xz, yz = zx * xy - zy * xx;
  const out = [ xx, yx, zx, 0, xy, yy, zy, 0, xz, yz, zz, 0, 0,0,0,1 ];
  const trans = mat4Translate([-eye[0], -eye[1], -eye[2]]);
  return mat4Multiply(out, trans);
}

/* ===========================
   Render loop
   =========================== */
let cam = { x: STATE.player.x - STATE.mapSize/2, y:180, z: STATE.player.z + 220, yaw: -Math.PI/2 + 0.6, pitch: -0.45 };
let lastTime = performance.now();
function resizeCanvas(){
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const w = Math.max(480, Math.floor(canvas.clientWidth * dpr));
  const h = Math.max(320, Math.floor(canvas.clientHeight * dpr));
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
}
function renderFrame(nowTime){
  const t = nowTime || performance.now();
  const dt = Math.min(0.05, (t - lastTime)/1000);
  lastTime = t;
  // update player position via input smoothing (external input modifies STATE.player)
  // compute camera target to look at player position
  const px = STATE.player.x - STATE.mapSize/2, pz = STATE.player.z - STATE.mapSize/2, py = 0;
  const eye = [cam.x, cam.y, cam.z];
  const center = [px, py + 12, pz];
  // update yaw/pitch - controls modify cam.yaw/cam.pitch
  const cosYaw = Math.cos(cam.yaw), sinYaw = Math.sin(cam.yaw);
  // set view matrix
  const aspect = canvas.width / canvas.height;
  const proj = mat4Perspective(60 * Math.PI/180, aspect, 0.1, 2000);
  const view = mat4LookAt(eye, center, [0,1,0]);
  // model matrix identity for global combined VBO (we baked translations into vertex positions)
  const model = mat4Identity();
  // normal matrix is inverse-transpose of model; for identity it's identity
  const normalMat = mat4Identity();
  const mvp = mat4Multiply(proj, view);

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.useProgram(program);

  // bind buffers & attributes
  gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
  gl.enableVertexAttribArray(attribs.aPosition);
  gl.vertexAttribPointer(attribs.aPosition, 3, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, vboNorm);
  gl.enableVertexAttribArray(attribs.aNormal);
  gl.vertexAttribPointer(attribs.aNormal, 3, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, vboColor);
  gl.enableVertexAttribArray(attribs.aColor);
  gl.vertexAttribPointer(attribs.aColor, 4, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);

  // uniforms
  gl.uniformMatrix4fv(uniforms.uMVP, false, new Float32Array(mvp));
  gl.uniformMatrix4fv(uniforms.uModel, false, new Float32Array(model));
  gl.uniformMatrix4fv(uniforms.uNormalMat, false, new Float32Array(normalMat));
  const lightDir = [0.5, 0.8, 0.2];
  gl.uniform3fv(uniforms.uLightDir, new Float32Array(lightDir));
  gl.uniform1f(uniforms.uLightIntensity, 1.0);

  // draw
  gl.drawElements(gl.TRIANGLES, vertexCount, gl.UNSIGNED_SHORT, 0);

  // update small HUD overlays (player marker in 3D, etc)
  updatePlayerMarker();

  // call part2/part3 updates if present (non-blocking)
  try{ if (window._part2_update) window._part2_update(dt); if (window._part3_update) window._part3_update(dt); } catch(e){ /* ignore */ }

  requestAnimationFrame(renderFrame);
}

/* ===========================
   Input Handling (mouse drag, touch swipe, keyboard, virtual stick)
   =========================== */
let dragging = false, lastMouse = null;
canvas.addEventListener('pointerdown', (e)=>{
  if (isElementUI(e.target)) return;
  dragging = true; lastMouse = {x:e.clientX, y:e.clientY}; canvas.setPointerCapture(e.pointerId);
});
canvas.addEventListener('pointermove', (e)=>{
  if (!dragging) return;
  const dx = e.clientX - lastMouse.x, dy = e.clientY - lastMouse.y;
  lastMouse = {x:e.clientX, y:e.clientY};
  // update camera yaw/pitch
  cam.yaw -= dx * 0.006; cam.pitch = clamp(cam.pitch - dy * 0.004, -1.2, -0.12);
  updateCameraFromAngles();
});
canvas.addEventListener('pointerup', (e)=>{ dragging = false; lastMouse = null; });

function isElementUI(elm){ return elm.closest && (elm.closest('#hud') || elm.closest('#minimap') || elm.closest('#vaultModal') || elm.closest('.btn') || elm.closest('#controlsMobile')); }

// touch swipe fallback (single touch)
let lastTouch = null;
canvas.addEventListener('touchstart', (e)=>{ if (e.touches.length===1){ lastTouch = {x:e.touches[0].clientX, y:e.touches[0].clientY}; } });
canvas.addEventListener('touchmove', (e)=>{ if (e.touches.length===1 && lastTouch){ const dx = e.touches[0].clientX - lastTouch.x, dy = e.touches[0].clientY - lastTouch.y; lastTouch = {x:e.touches[0].clientX, y:e.touches[0].clientY}; cam.yaw -= dx * 0.006; cam.pitch = clamp(cam.pitch - dy * 0.004, -1.2, -0.12); updateCameraFromAngles(); } }, {passive:false});
canvas.addEventListener('touchend', ()=>{ lastTouch=null; });

// keyboard movement WASD
const KEY = {};
window.addEventListener('keydown', (e)=>{ KEY[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', (e)=>{ KEY[e.key.toLowerCase()] = false; });

function processKeyboard(dt){
  let mx=0, mz=0;
  if (KEY['w']||KEY['arrowup']) mz -= 1;
  if (KEY['s']||KEY['arrowdown']) mz += 1;
  if (KEY['a']||KEY['arrowleft']) mx -= 1;
  if (KEY['d']||KEY['arrowright']) mx += 1;
  if (mx!==0 || mz!==0){
    // move in camera-relative direction projected to XZ
    const forward = [-Math.cos(cam.yaw), 0, -Math.sin(cam.yaw)]; // note: front vector
    const right = [Math.sin(cam.yaw), 0, -Math.cos(cam.yaw)];
    const len = Math.hypot(mx, mz) || 1;
    const nx = (right[0]*mx + forward[0]*mz)/len;
    const nz = (right[2]*mx + forward[2]*mz)/len;
    STATE.player.x += nx * STATE.player.speed * 40 * dt;
    STATE.player.z += nz * STATE.player.speed * 40 * dt;
    // clamp
    STATE.player.x = clamp(STATE.player.x, 0, STATE.mapSize);
    STATE.player.z = clamp(STATE.player.z, 0, STATE.mapSize);
    // update player marker in GL buffers requires rebuild next frame; for simplicity we rebuild occasionally below
    scheduleBufferRebuild();
  }
}

/* virtual joystick */
let stickCenter=null, draggingStick=false;
const stickOuter = el('joyZone'), stickInner = el('stickInner');
stickOuter.addEventListener('pointerdown', (e)=>{ e.preventDefault(); draggingStick = true; stickOuter.setPointerCapture(e.pointerId); const r = stickOuter.getBoundingClientRect(); stickCenter = {x:r.left + r.width/2, y:r.top + r.height/2}; onStickMove(e.clientX, e.clientY); });
window.addEventListener('pointermove', (e)=>{ if (draggingStick) onStickMove(e.clientX, e.clientY); });
window.addEventListener('pointerup', (e)=>{ if (draggingStick){ draggingStick=false; stickInner.style.transform = 'translate(0,0)'; STATE.inputStick = {x:0,y:0}; } });
function onStickMove(cx, cy){
  const dx = cx - stickCenter.x, dy = cy - stickCenter.y;
  const max = 44;
  const nx = clamp(dx/max, -1, 1), ny = clamp(dy/max, -1, 1);
  stickInner.style.transform = `translate(${clamp(dx,-max,max)}px, ${clamp(dy,-max,max)}px)`;
  STATE.inputStick = { x: nx, y: ny };
  // convert to player move
  const ang = cam.yaw;
  const vx = nx * Math.cos(ang) - ny * Math.sin(ang);
  const vz = nx * Math.sin(ang) + ny * Math.cos(ang);
  STATE.player.x += vx * STATE.player.speed * 20 * 0.016;
  STATE.player.z += vz * STATE.player.speed * 20 * 0.016;
  scheduleBufferRebuild();
}

/* update camera position from yaw/pitch and ensure above ground */
function updateCameraFromAngles(){
  // camera orbits around player target
  const targetX = STATE.player.x - STATE.mapSize/2;
  const targetZ = STATE.player.z - STATE.mapSize/2;
  const radius = 220; // distance
  cam.x = targetX + Math.cos(cam.pitch) * Math.cos(cam.yaw) * radius;
  cam.y = targetX*0 + Math.sin(-cam.pitch) * 220 + 30; // keep above ground
  cam.z = targetZ + Math.cos(cam.pitch) * Math.sin(cam.yaw) * radius;
}

/* ===========================
   Buffer rebuild scheduling
   =========================== */
let rebuildScheduled = false;
function scheduleBufferRebuild(){
  if (!rebuildScheduled){
    rebuildScheduled = true;
    setTimeout(()=>{ rebuildScheduled = false; buildSceneBuffers(); }, 200);
  }
}

/* ===========================
   World generation (buildings + vaults)
   =========================== */
function generateMap(seed){
  STATE.buildings = []; STATE.vaults = [];
  const cell = 60;
  const cols = Math.floor(STATE.mapSize / cell);
  for (let r=0;r<cols;r++){
    for (let c=0;c<cols;c++){
      const x = c*cell + rand(8, cell-8);
      const z = r*cell + rand(8, cell-8);
      const roll = Math.random();
      let kind = 'dummy';
      if (roll < 0.02) kind = 'bank';
      else if (roll < 0.07) kind = 'conbini';
      else if (roll < 0.11) kind = 'pachinko';
      else if (roll < 0.14) kind = 'carshop';
      else if (roll < 0.16) kind = 'slots';
      else if (roll < 0.17) kind = 'blackmarket';
      const sx = rand(12,36), sz = rand(12,36), h = rand(22, 86);
      STATE.buildings.push({ kind, x, z, sx, sz, height: h });
      if (kind === 'bank' || kind === 'conbini' || kind === 'pachinko') {
        STATE.vaults.push({ buildingIndex: STATE.buildings.length-1, locked:true, attempts:0, dialSolution:[rand(0,9),rand(0,9),rand(0,9),rand(0,9)], reward: kind==='bank'?50000:(kind==='pachinko'?15000:4200) });
      }
    }
  }
  if (!STATE.buildings.some(b=>b.kind==='bank')){
    const x = rand(80, STATE.mapSize-80), z = rand(80, STATE.mapSize-80);
    STATE.buildings.push({ kind:'bank', x, z, sx:56, sz:56, height:72 });
    STATE.vaults.push({ buildingIndex: STATE.buildings.length-1, locked:true, attempts:0, dialSolution:[rand(0,9),rand(0,9),rand(0,9),rand(0,9)], reward:50000 });
  }
  el('vaultCount').textContent = STATE.vaults.length;
  scheduleBufferRebuild();
}

/* ===========================
   Minimap drawing (2D)
   =========================== */
const mini = el('mini'); const mctx = mini.getContext('2d');
function drawMinimap(){
  const W = mini.width, H = mini.height; mctx.clearRect(0,0,W,H);
  mctx.fillStyle = '#02111a'; mctx.fillRect(0,0,W,H);
  const s = W / STATE.mapSize;
  STATE.buildings.forEach(b=>{
    const x = b.x * s, y = b.z * s, w = clamp(b.sx * s, 3, 18), h = clamp(b.sz * s, 3, 18);
    mctx.fillStyle = (b.kind==='bank'?'#2ecc71':(b.kind==='conbini'?'#3498db':(b.kind==='pachinko'?'#e67e22':'#95a5a6')));
    mctx.fillRect(x - w/2, y - h/2, w, h);
  });
  const px = STATE.player.x * s, pz = STATE.player.z * s; mctx.fillStyle = '#ffde59'; mctx.beginPath(); mctx.arc(px,pz,6,0,Math.PI*2); mctx.fill();
}

/* ===========================
   Player marker update (synchronize last inserted player mesh to current pos)
   Because we baked player mesh into buffers, easiest is to rebuild occasionally.
   We'll rebuild every 250ms if player moved.
   =========================== */
let lastPlayerPos = {x:STATE.player.x, z:STATE.player.z}, lastRebuildTime = 0;
function updatePlayerMarker(){
  const now = performance.now();
  if (Math.abs(STATE.player.x - lastPlayerPos.x) > 1 || Math.abs(STATE.player.z - lastPlayerPos.z) > 1) {
    if (now - lastRebuildTime > 250) { lastRebuildTime = now; lastPlayerPos = {x:STATE.player.x, z:STATE.player.z}; scheduleBufferRebuild(); }
  }
}

/* ===========================
   HUD / UI wiring
   =========================== */
el('btnNewMap').addEventListener('click', ()=>{ generateMap(); drawMinimap(); notify('マップを生成しました'); });
el('btnSave').addEventListener('click', ()=>{ try{ const dat = { player: STATE.player, buildings: STATE.buildings, vaults: STATE.vaults, time: Date.now() }; localStorage.setItem('vh_save_core', JSON.stringify(dat)); notify('保存しました'); }catch(e){ notify('保存に失敗しました'); }});
el('btnInteract').addEventListener('click', ()=> tryInteractNearby());
el('btnFire').addEventListener('click', ()=> notify('発砲: Part3で演出を実装します'));
el('presetSelect').addEventListener('change', (e)=>{ STATE.preset = e.target.value; notify('プリセット: ' + e.target.value); });

function tryInteractNearby(){
  let nearest = null, nd = 1e9, idx = -1;
  STATE.buildings.forEach((b,i)=>{ const d = Math.hypot(b.x - STATE.player.x, b.z - STATE.player.z); if (d < nd){ nd=d; nearest = b; idx=i; } });
  if (nearest && nd < 36) {
    notify('建物: ' + nearest.kind);
    if (['bank','conbini','pachinko'].includes(nearest.kind)){
      const vault = STATE.vaults.find(v=>v.buildingIndex===idx && v.locked);
      if (vault) { openVaultModal(vault); return; } else notify('この建物の金庫は解錠済み'); return;
    } else {
      notify('建物に侵入できます（Part3で室内を実装）'); return;
    }
  } else notify('近くに入れる建物がありません');
}

function openVaultModal(v){
  el('vaultModal').classList.add('open'); el('vaultModal').setAttribute('aria-hidden','false');
  el('vaultMsg').textContent = `近くの金庫 (報酬: ${fmtMoney(v.reward)}) 。Part2でダイヤルUIを実装します。`;
  window._currentVault = v;
}
el('closeVault').addEventListener('click', ()=>{ el('vaultModal').classList.remove('open'); el('vaultModal').setAttribute('aria-hidden','true'); window._currentVault = null; });

/* ===========================
   Build buffers and start
   =========================== */
let buffersPrepared = false;
function start(){
  fitCanvasToDisplay();
  if (!initGL()) { return; }
  if (!prepareGL()) { return; }
  generateMap();
  // build initial buffers and start render
  buildSceneBuffers(); // will populate VBOs
  drawMinimap();
  updateHUD();
  updateCameraFromAngles();
  requestAnimationFrame(renderFrame);
  // kick periodic keyboard/joystick processing
  setInterval(()=>{ processKeyboard(0.04); updateHUD(); }, 40);
  window._part1_ready = true;
  window._part1_update = function(dt){}; // placeholder for other parts
  notify('Part1: WebGL描画初期化完了');
}

/* canvas size fitting (pixel ratio aware) */
function fitCanvasToDisplay(){
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const w = Math.max(600, Math.floor(canvas.clientWidth * dpr));
  const h = Math.max(400, Math.floor(canvas.clientHeight * dpr));
  canvas.width = w; canvas.height = h;
  if (gl) gl.viewport(0,0,canvas.width, canvas.height);
}

/* update HUD numbers */
function updateHUD(){
  el('money').textContent = fmtMoney(STATE.player.money);
  el('guns').textContent = STATE.player.guns;
  el('cars').textContent = STATE.player.cars;
  el('heat').textContent = Math.round(STATE.heat || 0);
}

/* ensure resize handling */
window.addEventListener('resize', ()=>{ fitCanvasToDisplay(); drawMinimap(); });

/* small utility: createBoxMesh used in buildSceneBuffers needs to be in-scope - already defined above */

/* Finally, init GL and start */
start();

/* expose some useful hooks for Part2/Part3 */
window.generateMap = generateMap;
window.buildSceneBuffers = buildSceneBuffers;
window.drawMinimap = drawMinimap;
window.updateHUD = updateHUD;
window.tryInteractNearby = tryInteractNearby;
window.openVaultModal = openVaultModal;

</script>
</body>
</html>
